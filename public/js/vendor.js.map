{"version":3,"sources":["download.js","hammer.js","jquery.are-you-sure.js","jquery.colorpicker.min.js","jquery.cropbox.js","jquery.events.min.js","jquery.mousewheel.js","jquery.mutate.min.js","jquery.pickadate.js","jquery.rotate.js","medium.merged.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC54CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChMA;AACA;AACA;AACA;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChRA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5IA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"vendor.js","sourcesContent":["//download.js v4.2, by dandavis; 2008-2016. [CCBY2] see http://danml.com/download.html for tests/usage\n// v1 landed a FF+Chrome compat way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime\n// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs\n// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support. 3.1 improved safari handling.\n// v4 adds AMD/UMD, commonJS, and plain browser support\n// v4.1 adds url download capability via solo URL argument (same domain/CORS only)\n// v4.2 adds semantic variable names, long (over 2MB) dataURL support, and hidden by default temp anchors\n// https://github.com/rndme/download\n\n(function (root, factory) {\n\tif (typeof define === 'function' && define.amd) {\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([], factory);\n\t} else if (typeof exports === 'object') {\n\t\t// Node. Does not work with strict CommonJS, but\n\t\t// only CommonJS-like environments that support module.exports,\n\t\t// like Node.\n\t\tmodule.exports = factory();\n\t} else {\n\t\t// Browser globals (root is window)\n\t\troot.download = factory();\n\t}\n}(this, function () {\n\n\treturn function download(data, strFileName, strMimeType) {\n\n\t\tvar self = window, // this script is only for browsers anyway...\n\t\t\tdefaultMime = \"application/octet-stream\", // this default mime also triggers iframe downloads\n\t\t\tmimeType = strMimeType || defaultMime,\n\t\t\tpayload = data,\n\t\t\turl = !strFileName && !strMimeType && payload,\n\t\t\tanchor = document.createElement(\"a\"),\n\t\t\ttoString = function(a){return String(a);},\n\t\t\tmyBlob = (self.Blob || self.MozBlob || self.WebKitBlob || toString),\n\t\t\tfileName = strFileName || \"download\",\n\t\t\tblob,\n\t\t\treader;\n\t\tmyBlob= myBlob.call ? myBlob.bind(self) : Blob ;\n\n\t\tif(String(this)===\"true\"){ //reverse arguments, allowing download.bind(true, \"text/xml\", \"export.xml\") to act as a callback\n\t\t\tpayload=[payload, mimeType];\n\t\t\tmimeType=payload[0];\n\t\t\tpayload=payload[1];\n\t\t}\n\n\n\t\tif(url && url.length< 2048){ // if no filename and no mime, assume a url was passed as the only argument\n\t\t\tfileName = url.split(\"/\").pop().split(\"?\")[0];\n\t\t\tanchor.href = url; // assign href prop to temp anchor\n\t\t\tif(anchor.href.indexOf(url) !== -1){ // if the browser determines that it's a potentially valid url path:\n\t\t\t\tvar ajax=new XMLHttpRequest();\n\t\t\t\tajax.open( \"GET\", url, true);\n\t\t\t\tajax.responseType = 'blob';\n\t\t\t\tajax.onload= function(e){\n\t\t\t\t\tdownload(e.target.response, fileName, defaultMime);\n\t\t\t\t};\n\t\t\t\tsetTimeout(function(){ ajax.send();}, 0); // allows setting custom ajax headers using the return:\n\t\t\t\treturn ajax;\n\t\t\t} // end if valid url?\n\t\t} // end if url?\n\n\n\t\t//go ahead and download dataURLs right away\n\t\tif(/^data\\:[\\w+\\-]+\\/[\\w+\\-]+[,;]/.test(payload)){\n\n\t\t\tif(payload.length > (1024*1024*1.999) && myBlob !== toString ){\n\t\t\t\tpayload=dataUrlToBlob(payload);\n\t\t\t\tmimeType=payload.type || defaultMime;\n\t\t\t}else{\n\t\t\t\treturn navigator.msSaveBlob ?  // IE10 can't do a[download], only Blobs:\n\t\t\t\t\tnavigator.msSaveBlob(dataUrlToBlob(payload), fileName) :\n\t\t\t\t\tsaver(payload) ; // everyone else can save dataURLs un-processed\n\t\t\t}\n\n\t\t}//end if dataURL passed?\n\n\t\tblob = payload instanceof myBlob ?\n\t\t\tpayload :\n\t\t\tnew myBlob([payload], {type: mimeType}) ;\n\n\n\t\tfunction dataUrlToBlob(strUrl) {\n\t\t\tvar parts= strUrl.split(/[:;,]/),\n\t\t\t\ttype= parts[1],\n\t\t\t\tdecoder= parts[2] == \"base64\" ? atob : decodeURIComponent,\n\t\t\t\tbinData= decoder( parts.pop() ),\n\t\t\t\tmx= binData.length,\n\t\t\t\ti= 0,\n\t\t\t\tuiArr= new Uint8Array(mx);\n\n\t\t\tfor(i;i<mx;++i) uiArr[i]= binData.charCodeAt(i);\n\n\t\t\treturn new myBlob([uiArr], {type: type});\n\t\t}\n\n\t\tfunction saver(url, winMode){\n\n\t\t\tif ('download' in anchor) { //html5 A[download]\n\t\t\t\tanchor.href = url;\n\t\t\t\tanchor.setAttribute(\"download\", fileName);\n\t\t\t\tanchor.className = \"download-js-link\";\n\t\t\t\tanchor.innerHTML = \"downloading...\";\n\t\t\t\tanchor.style.display = \"none\";\n\t\t\t\tdocument.body.appendChild(anchor);\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tanchor.click();\n\t\t\t\t\tdocument.body.removeChild(anchor);\n\t\t\t\t\tif(winMode===true){setTimeout(function(){ self.URL.revokeObjectURL(anchor.href);}, 250 );}\n\t\t\t\t}, 66);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// handle non-a[download] safari as best we can:\n\t\t\tif(/(Version)\\/(\\d+)\\.(\\d+)(?:\\.(\\d+))?.*Safari\\//.test(navigator.userAgent)) {\n\t\t\t\turl=url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime);\n\t\t\t\tif(!window.open(url)){ // popup blocked, offer direct download:\n\t\t\t\t\tif(confirm(\"Displaying New Document\\n\\nUse Save As... to download, then click back to return to this page.\")){ location.href=url; }\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t//do iframe dataURL download (old ch+FF):\n\t\t\tvar f = document.createElement(\"iframe\");\n\t\t\tdocument.body.appendChild(f);\n\n\t\t\tif(!winMode){ // force a mime that will download:\n\t\t\t\turl=\"data:\"+url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime);\n\t\t\t}\n\t\t\tf.src=url;\n\t\t\tsetTimeout(function(){ document.body.removeChild(f); }, 333);\n\n\t\t}//end saver\n\n\n\n\n\t\tif (navigator.msSaveBlob) { // IE10+ : (has Blob, but not a[download] or URL)\n\t\t\treturn navigator.msSaveBlob(blob, fileName);\n\t\t}\n\n\t\tif(self.URL){ // simple fast and modern way using Blob and URL:\n\t\t\tsaver(self.URL.createObjectURL(blob), true);\n\t\t}else{\n\t\t\t// handle non-Blob()+non-URL browsers:\n\t\t\tif(typeof blob === \"string\" || blob.constructor===toString ){\n\t\t\t\ttry{\n\t\t\t\t\treturn saver( \"data:\" +  mimeType   + \";base64,\"  +  self.btoa(blob)  );\n\t\t\t\t}catch(y){\n\t\t\t\t\treturn saver( \"data:\" +  mimeType   + \",\" + encodeURIComponent(blob)  );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Blob but not URL support:\n\t\t\treader=new FileReader();\n\t\t\treader.onload=function(e){\n\t\t\t\tsaver(this.result);\n\t\t\t};\n\t\t\treader.readAsDataURL(blob);\n\t\t}\n\t\treturn true;\n\t}; /* end download() */\n}));","/*! Hammer.JS - v1.0.5 - 2013-04-07\n * http://eightmedia.github.com/hammer.js\n *\n * Copyright (c) 2013 Jorik Tangelder <j.tangelder@gmail.com>;\n * Licensed under the MIT license */\n\n(function(window, undefined) {\n    'use strict';\n\n/**\n * Hammer\n * use this to create instances\n * @param   {HTMLElement}   element\n * @param   {Object}        options\n * @returns {Hammer.Instance}\n * @constructor\n */\nvar Hammer = function(element, options) {\n    return new Hammer.Instance(element, options || {});\n};\n\n// default settings\nHammer.defaults = {\n    // add styles and attributes to the element to prevent the browser from doing\n    // its native behavior. this doesnt prevent the scrolling, but cancels\n    // the contextmenu, tap highlighting etc\n    // set to false to disable this\n    stop_browser_behavior: {\n\t\t// this also triggers onselectstart=false for IE\n        userSelect: 'none',\n\t\t// this makes the element blocking in IE10 >, you could experiment with the value\n\t\t// see for more options this issue; https://github.com/EightMedia/hammer.js/issues/241\n        touchAction: 'none',\n\t\ttouchCallout: 'none',\n        contentZooming: 'none',\n        userDrag: 'none',\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n\n    // more settings are defined per gesture at gestures.js\n};\n\n// detect touchevents\nHammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;\nHammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);\n\n// dont use mouseevents on mobile devices\nHammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nHammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && navigator.userAgent.match(Hammer.MOBILE_REGEX);\n\n// eventtypes per touchevent (start, move, end)\n// are filled by Hammer.event.determineEventTypes on setup\nHammer.EVENT_TYPES = {};\n\n// direction defines\nHammer.DIRECTION_DOWN = 'down';\nHammer.DIRECTION_LEFT = 'left';\nHammer.DIRECTION_UP = 'up';\nHammer.DIRECTION_RIGHT = 'right';\n\n// pointer type\nHammer.POINTER_MOUSE = 'mouse';\nHammer.POINTER_TOUCH = 'touch';\nHammer.POINTER_PEN = 'pen';\n\n// touch event defines\nHammer.EVENT_START = 'start';\nHammer.EVENT_MOVE = 'move';\nHammer.EVENT_END = 'end';\n\n// hammer document where the base events are added at\nHammer.DOCUMENT = document;\n\n// plugins namespace\nHammer.plugins = {};\n\n// if the window events are set...\nHammer.READY = false;\n\n/**\n * setup events to detect gestures on the document\n */\nfunction setup() {\n    if(Hammer.READY) {\n        return;\n    }\n\n    // find what eventtypes we add listeners to\n    Hammer.event.determineEventTypes();\n\n    // Register all gestures inside Hammer.gestures\n    for(var name in Hammer.gestures) {\n        if(Hammer.gestures.hasOwnProperty(name)) {\n            Hammer.detection.register(Hammer.gestures[name]);\n        }\n    }\n\n    // Add touch events on the document\n    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_MOVE, Hammer.detection.detect);\n    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_END, Hammer.detection.detect);\n\n    // Hammer is ready...!\n    Hammer.READY = true;\n}\n\n/**\n * create new hammer instance\n * all methods should return the instance itself, so it is chainable.\n * @param   {HTMLElement}       element\n * @param   {Object}            [options={}]\n * @returns {Hammer.Instance}\n * @constructor\n */\nHammer.Instance = function(element, options) {\n    var self = this;\n\n    // setup HammerJS window events and register all gestures\n    // this also sets up the default options\n    setup();\n\n    this.element = element;\n\n    // start/stop detection option\n    this.enabled = true;\n\n    // merge options\n    this.options = Hammer.utils.extend(\n        Hammer.utils.extend({}, Hammer.defaults),\n        options || {});\n\n    // add some css to the element to prevent the browser from doing its native behavoir\n    if(this.options.stop_browser_behavior) {\n        Hammer.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);\n    }\n\n    // start detection on touchstart\n    Hammer.event.onTouch(element, Hammer.EVENT_START, function(ev) {\n        if(self.enabled) {\n            Hammer.detection.startDetect(self, ev);\n        }\n    });\n\n    // return instance\n    return this;\n};\n\n\nHammer.Instance.prototype = {\n    /**\n     * bind events to the instance\n     * @param   {String}      gesture\n     * @param   {Function}    handler\n     * @returns {Hammer.Instance}\n     */\n    on: function onEvent(gesture, handler){\n        var gestures = gesture.split(' ');\n        for(var t=0; t<gestures.length; t++) {\n            this.element.addEventListener(gestures[t], handler, false);\n        }\n        return this;\n    },\n\n\n    /**\n     * unbind events to the instance\n     * @param   {String}      gesture\n     * @param   {Function}    handler\n     * @returns {Hammer.Instance}\n     */\n    off: function offEvent(gesture, handler){\n        var gestures = gesture.split(' ');\n        for(var t=0; t<gestures.length; t++) {\n            this.element.removeEventListener(gestures[t], handler, false);\n        }\n        return this;\n    },\n\n\n    /**\n     * trigger gesture event\n     * @param   {String}      gesture\n     * @param   {Object}      eventData\n     * @returns {Hammer.Instance}\n     */\n    trigger: function triggerEvent(gesture, eventData){\n        // create DOM event\n        var event = Hammer.DOCUMENT.createEvent('Event');\n\t\tevent.initEvent(gesture, true, true);\n\t\tevent.gesture = eventData;\n\n        // trigger on the target if it is in the instance element,\n        // this is for event delegation tricks\n        var element = this.element;\n        if(Hammer.utils.hasParent(eventData.target, element)) {\n            element = eventData.target;\n        }\n\n        element.dispatchEvent(event);\n        return this;\n    },\n\n\n    /**\n     * enable of disable hammer.js detection\n     * @param   {Boolean}   state\n     * @returns {Hammer.Instance}\n     */\n    enable: function enable(state) {\n        this.enabled = state;\n        return this;\n    }\n};\n\n/**\n * this holds the last move event,\n * used to fix empty touchend issue\n * see the onTouch event for an explanation\n * @type {Object}\n */\nvar last_move_event = null;\n\n\n/**\n * when the mouse is hold down, this is true\n * @type {Boolean}\n */\nvar enable_detect = false;\n\n\n/**\n * when touch events have been fired, this is true\n * @type {Boolean}\n */\nvar touch_triggered = false;\n\n\nHammer.event = {\n    /**\n     * simple addEventListener\n     * @param   {HTMLElement}   element\n     * @param   {String}        type\n     * @param   {Function}      handler\n     */\n    bindDom: function(element, type, handler) {\n        var types = type.split(' ');\n        for(var t=0; t<types.length; t++) {\n            element.addEventListener(types[t], handler, false);\n        }\n    },\n\n\n    /**\n     * touch events with mouse fallback\n     * @param   {HTMLElement}   element\n     * @param   {String}        eventType        like Hammer.EVENT_MOVE\n     * @param   {Function}      handler\n     */\n    onTouch: function onTouch(element, eventType, handler) {\n\t\tvar self = this;\n\n        this.bindDom(element, Hammer.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {\n            var sourceEventType = ev.type.toLowerCase();\n\n            // onmouseup, but when touchend has been fired we do nothing.\n            // this is for touchdevices which also fire a mouseup on touchend\n            if(sourceEventType.match(/mouse/) && touch_triggered) {\n                return;\n            }\n\n            // mousebutton must be down or a touch event\n            else if( sourceEventType.match(/touch/) ||   // touch events are always on screen\n                sourceEventType.match(/pointerdown/) || // pointerevents touch\n                (sourceEventType.match(/mouse/) && ev.which === 1)   // mouse is pressed\n            ){\n                enable_detect = true;\n            }\n\n            // we are in a touch event, set the touch triggered bool to true,\n            // this for the conflicts that may occur on ios and android\n            if(sourceEventType.match(/touch|pointer/)) {\n                touch_triggered = true;\n            }\n\n            // count the total touches on the screen\n            var count_touches = 0;\n\n            // when touch has been triggered in this detection session\n            // and we are now handling a mouse event, we stop that to prevent conflicts\n            if(enable_detect) {\n                // update pointerevent\n                if(Hammer.HAS_POINTEREVENTS && eventType != Hammer.EVENT_END) {\n                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);\n                }\n                // touch\n                else if(sourceEventType.match(/touch/)) {\n                    count_touches = ev.touches.length;\n                }\n                // mouse\n                else if(!touch_triggered) {\n                    count_touches = sourceEventType.match(/up/) ? 0 : 1;\n                }\n\n                // if we are in a end event, but when we remove one touch and\n                // we still have enough, set eventType to move\n                if(count_touches > 0 && eventType == Hammer.EVENT_END) {\n                    eventType = Hammer.EVENT_MOVE;\n                }\n                // no touches, force the end event\n                else if(!count_touches) {\n                    eventType = Hammer.EVENT_END;\n                }\n\n                // because touchend has no touches, and we often want to use these in our gestures,\n                // we send the last move event as our eventData in touchend\n                if(!count_touches && last_move_event !== null) {\n                    ev = last_move_event;\n                }\n                // store the last move event\n                else {\n                    last_move_event = ev;\n                }\n\n                // trigger the handler\n                handler.call(Hammer.detection, self.collectEventData(element, eventType, ev));\n\n                // remove pointerevent from list\n                if(Hammer.HAS_POINTEREVENTS && eventType == Hammer.EVENT_END) {\n                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);\n                }\n            }\n\n            //debug(sourceEventType +\" \"+ eventType);\n\n            // on the end we reset everything\n            if(!count_touches) {\n                last_move_event = null;\n                enable_detect = false;\n                touch_triggered = false;\n                Hammer.PointerEvent.reset();\n            }\n        });\n    },\n\n\n    /**\n     * we have different events for each device/browser\n     * determine what we need and set them in the Hammer.EVENT_TYPES constant\n     */\n    determineEventTypes: function determineEventTypes() {\n        // determine the eventtype we want to set\n        var types;\n\n        // pointerEvents magic\n        if(Hammer.HAS_POINTEREVENTS) {\n            types = Hammer.PointerEvent.getEvents();\n        }\n        // on Android, iOS, blackberry, windows mobile we dont want any mouseevents\n        else if(Hammer.NO_MOUSEEVENTS) {\n            types = [\n                'touchstart',\n                'touchmove',\n                'touchend touchcancel'];\n        }\n        // for non pointer events browsers and mixed browsers,\n        // like chrome on windows8 touch laptop\n        else {\n            types = [\n                'touchstart mousedown',\n                'touchmove mousemove',\n                'touchend touchcancel mouseup'];\n        }\n\n        Hammer.EVENT_TYPES[Hammer.EVENT_START]  = types[0];\n        Hammer.EVENT_TYPES[Hammer.EVENT_MOVE]   = types[1];\n        Hammer.EVENT_TYPES[Hammer.EVENT_END]    = types[2];\n    },\n\n\n    /**\n     * create touchlist depending on the event\n     * @param   {Object}    ev\n     * @param   {String}    eventType   used by the fakemultitouch plugin\n     */\n    getTouchList: function getTouchList(ev/*, eventType*/) {\n        // get the fake pointerEvent touchlist\n        if(Hammer.HAS_POINTEREVENTS) {\n            return Hammer.PointerEvent.getTouchList();\n        }\n        // get the touchlist\n        else if(ev.touches) {\n            return ev.touches;\n        }\n        // make fake touchlist from mouse position\n        else {\n            return [{\n                identifier: 1,\n                pageX: ev.pageX,\n                pageY: ev.pageY,\n                target: ev.target\n            }];\n        }\n    },\n\n\n    /**\n     * collect event data for Hammer js\n     * @param   {HTMLElement}   element\n     * @param   {String}        eventType        like Hammer.EVENT_MOVE\n     * @param   {Object}        eventData\n     */\n    collectEventData: function collectEventData(element, eventType, ev) {\n        var touches = this.getTouchList(ev, eventType);\n\n        // find out pointerType\n        var pointerType = Hammer.POINTER_TOUCH;\n        if(ev.type.match(/mouse/) || Hammer.PointerEvent.matchType(Hammer.POINTER_MOUSE, ev)) {\n            pointerType = Hammer.POINTER_MOUSE;\n        }\n\n        return {\n            center      : Hammer.utils.getCenter(touches),\n            timeStamp   : new Date().getTime(),\n            target      : ev.target,\n            touches     : touches,\n            eventType   : eventType,\n            pointerType : pointerType,\n            srcEvent    : ev,\n\n            /**\n             * prevent the browser default actions\n             * mostly used to disable scrolling of the browser\n             */\n            preventDefault: function() {\n                if(this.srcEvent.preventManipulation) {\n                    this.srcEvent.preventManipulation();\n                }\n\n                if(this.srcEvent.preventDefault) {\n                    this.srcEvent.preventDefault();\n                }\n            },\n\n            /**\n             * stop bubbling the event up to its parents\n             */\n            stopPropagation: function() {\n                this.srcEvent.stopPropagation();\n            },\n\n            /**\n             * immediately stop gesture detection\n             * might be useful after a swipe was detected\n             * @return {*}\n             */\n            stopDetect: function() {\n                return Hammer.detection.stopDetect();\n            }\n        };\n    }\n};\n\nHammer.PointerEvent = {\n    /**\n     * holds all pointers\n     * @type {Object}\n     */\n    pointers: {},\n\n    /**\n     * get a list of pointers\n     * @returns {Array}     touchlist\n     */\n    getTouchList: function() {\n        var self = this;\n        var touchlist = [];\n\n        // we can use forEach since pointerEvents only is in IE10\n        Object.keys(self.pointers).sort().forEach(function(id) {\n            touchlist.push(self.pointers[id]);\n        });\n        return touchlist;\n    },\n\n    /**\n     * update the position of a pointer\n     * @param   {String}   type             Hammer.EVENT_END\n     * @param   {Object}   pointerEvent\n     */\n    updatePointer: function(type, pointerEvent) {\n        if(type == Hammer.EVENT_END) {\n            this.pointers = {};\n        }\n        else {\n            pointerEvent.identifier = pointerEvent.pointerId;\n            this.pointers[pointerEvent.pointerId] = pointerEvent;\n        }\n\n        return Object.keys(this.pointers).length;\n    },\n\n    /**\n     * check if ev matches pointertype\n     * @param   {String}        pointerType     Hammer.POINTER_MOUSE\n     * @param   {PointerEvent}  ev\n     */\n    matchType: function(pointerType, ev) {\n        if(!ev.pointerType) {\n            return false;\n        }\n\n        var types = {};\n        types[Hammer.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == Hammer.POINTER_MOUSE);\n        types[Hammer.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == Hammer.POINTER_TOUCH);\n        types[Hammer.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == Hammer.POINTER_PEN);\n        return types[pointerType];\n    },\n\n\n    /**\n     * get events\n     */\n    getEvents: function() {\n        return [\n            'pointerdown MSPointerDown',\n            'pointermove MSPointerMove',\n            'pointerup pointercancel MSPointerUp MSPointerCancel'\n        ];\n    },\n\n    /**\n     * reset the list\n     */\n    reset: function() {\n        this.pointers = {};\n    }\n};\n\n\nHammer.utils = {\n    /**\n     * extend method,\n     * also used for cloning when dest is an empty object\n     * @param   {Object}    dest\n     * @param   {Object}    src\n\t * @parm\t{Boolean}\tmerge\t\tdo a merge\n     * @returns {Object}    dest\n     */\n    extend: function extend(dest, src, merge) {\n        for (var key in src) {\n\t\t\tif(dest[key] !== undefined && merge) {\n\t\t\t\tcontinue;\n\t\t\t}\n            dest[key] = src[key];\n        }\n        return dest;\n    },\n\n\n    /**\n     * find if a node is in the given parent\n     * used for event delegation tricks\n     * @param   {HTMLElement}   node\n     * @param   {HTMLElement}   parent\n     * @returns {boolean}       has_parent\n     */\n    hasParent: function(node, parent) {\n        while(node){\n            if(node == parent) {\n                return true;\n            }\n            node = node.parentNode;\n        }\n        return false;\n    },\n\n\n    /**\n     * get the center of all the touches\n     * @param   {Array}     touches\n     * @returns {Object}    center\n     */\n    getCenter: function getCenter(touches) {\n        var valuesX = [], valuesY = [];\n\n        for(var t= 0,len=touches.length; t<len; t++) {\n            valuesX.push(touches[t].pageX);\n            valuesY.push(touches[t].pageY);\n        }\n\n        return {\n            pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),\n            pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)\n        };\n    },\n\n\n    /**\n     * calculate the velocity between two points\n     * @param   {Number}    delta_time\n     * @param   {Number}    delta_x\n     * @param   {Number}    delta_y\n     * @returns {Object}    velocity\n     */\n    getVelocity: function getVelocity(delta_time, delta_x, delta_y) {\n        return {\n            x: Math.abs(delta_x / delta_time) || 0,\n            y: Math.abs(delta_y / delta_time) || 0\n        };\n    },\n\n\n    /**\n     * calculate the angle between two coordinates\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {Number}    angle\n     */\n    getAngle: function getAngle(touch1, touch2) {\n        var y = touch2.pageY - touch1.pageY,\n            x = touch2.pageX - touch1.pageX;\n        return Math.atan2(y, x) * 180 / Math.PI;\n    },\n\n\n    /**\n     * angle to direction define\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {String}    direction constant, like Hammer.DIRECTION_LEFT\n     */\n    getDirection: function getDirection(touch1, touch2) {\n        var x = Math.abs(touch1.pageX - touch2.pageX),\n            y = Math.abs(touch1.pageY - touch2.pageY);\n\n        if(x >= y) {\n            return touch1.pageX - touch2.pageX > 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;\n        }\n        else {\n            return touch1.pageY - touch2.pageY > 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;\n        }\n    },\n\n\n    /**\n     * calculate the distance between two touches\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {Number}    distance\n     */\n    getDistance: function getDistance(touch1, touch2) {\n        var x = touch2.pageX - touch1.pageX,\n            y = touch2.pageY - touch1.pageY;\n        return Math.sqrt((x*x) + (y*y));\n    },\n\n\n    /**\n     * calculate the scale factor between two touchLists (fingers)\n     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n     * @param   {Array}     start\n     * @param   {Array}     end\n     * @returns {Number}    scale\n     */\n    getScale: function getScale(start, end) {\n        // need two fingers...\n        if(start.length >= 2 && end.length >= 2) {\n            return this.getDistance(end[0], end[1]) /\n                this.getDistance(start[0], start[1]);\n        }\n        return 1;\n    },\n\n\n    /**\n     * calculate the rotation degrees between two touchLists (fingers)\n     * @param   {Array}     start\n     * @param   {Array}     end\n     * @returns {Number}    rotation\n     */\n    getRotation: function getRotation(start, end) {\n        // need two fingers\n        if(start.length >= 2 && end.length >= 2) {\n            return this.getAngle(end[1], end[0]) -\n                this.getAngle(start[1], start[0]);\n        }\n        return 0;\n    },\n\n\n    /**\n     * boolean if the direction is vertical\n     * @param    {String}    direction\n     * @returns  {Boolean}   is_vertical\n     */\n    isVertical: function isVertical(direction) {\n        return (direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN);\n    },\n\n\n    /**\n     * stop browser default behavior with css props\n     * @param   {HtmlElement}   element\n     * @param   {Object}        css_props\n     */\n    stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_props) {\n        var prop,\n            vendors = ['webkit','khtml','moz','ms','o',''];\n\n        if(!css_props || !element.style) {\n            return;\n        }\n\n        // with css properties for modern browsers\n        for(var i = 0; i < vendors.length; i++) {\n            for(var p in css_props) {\n                if(css_props.hasOwnProperty(p)) {\n                    prop = p;\n\n                    // vender prefix at the property\n                    if(vendors[i]) {\n                        prop = vendors[i] + prop.substring(0, 1).toUpperCase() + prop.substring(1);\n                    }\n\n                    // set the style\n                    element.style[prop] = css_props[p];\n                }\n            }\n        }\n\n        // also the disable onselectstart\n        if(css_props.userSelect == 'none') {\n            element.onselectstart = function() {\n                return false;\n            };\n        }\n    }\n};\n\nHammer.detection = {\n    // contains all registred Hammer.gestures in the correct order\n    gestures: [],\n\n    // data of the current Hammer.gesture detection session\n    current: null,\n\n    // the previous Hammer.gesture session data\n    // is a full clone of the previous gesture.current object\n    previous: null,\n\n    // when this becomes true, no gestures are fired\n    stopped: false,\n\n\n    /**\n     * start Hammer.gesture detection\n     * @param   {Hammer.Instance}   inst\n     * @param   {Object}            eventData\n     */\n    startDetect: function startDetect(inst, eventData) {\n        // already busy with a Hammer.gesture detection on an element\n        if(this.current) {\n            return;\n        }\n\n        this.stopped = false;\n\n        this.current = {\n            inst        : inst, // reference to HammerInstance we're working for\n            startEvent  : Hammer.utils.extend({}, eventData), // start eventData for distances, timing etc\n            lastEvent   : false, // last eventData\n            name        : '' // current gesture we're in/detected, can be 'tap', 'hold' etc\n        };\n\n        this.detect(eventData);\n    },\n\n\n    /**\n     * Hammer.gesture detection\n     * @param   {Object}    eventData\n     * @param   {Object}    eventData\n     */\n    detect: function detect(eventData) {\n        if(!this.current || this.stopped) {\n            return;\n        }\n\n        // extend event data with calculations about scale, distance etc\n        eventData = this.extendEventData(eventData);\n\n        // instance options\n        var inst_options = this.current.inst.options;\n\n        // call Hammer.gesture handlers\n        for(var g=0,len=this.gestures.length; g<len; g++) {\n            var gesture = this.gestures[g];\n\n            // only when the instance options have enabled this gesture\n            if(!this.stopped && inst_options[gesture.name] !== false) {\n                // if a handler returns false, we stop with the detection\n                if(gesture.handler.call(gesture, eventData, this.current.inst) === false) {\n                    this.stopDetect();\n                    break;\n                }\n            }\n        }\n\n        // store as previous event event\n        if(this.current) {\n            this.current.lastEvent = eventData;\n        }\n\n        // endevent, but not the last touch, so dont stop\n        if(eventData.eventType == Hammer.EVENT_END && !eventData.touches.length-1) {\n            this.stopDetect();\n        }\n\n        return eventData;\n    },\n\n\n    /**\n     * clear the Hammer.gesture vars\n     * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected\n     * to stop other Hammer.gestures from being fired\n     */\n    stopDetect: function stopDetect() {\n        // clone current data to the store as the previous gesture\n        // used for the double tap gesture, since this is an other gesture detect session\n        this.previous = Hammer.utils.extend({}, this.current);\n\n        // reset the current\n        this.current = null;\n\n        // stopped!\n        this.stopped = true;\n    },\n\n\n    /**\n     * extend eventData for Hammer.gestures\n     * @param   {Object}   ev\n     * @returns {Object}   ev\n     */\n    extendEventData: function extendEventData(ev) {\n        var startEv = this.current.startEvent;\n\n        // if the touches change, set the new touches over the startEvent touches\n        // this because touchevents don't have all the touches on touchstart, or the\n        // user must place his fingers at the EXACT same time on the screen, which is not realistic\n        // but, sometimes it happens that both fingers are touching at the EXACT same time\n        if(startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {\n            // extend 1 level deep to get the touchlist with the touch objects\n            startEv.touches = [];\n            for(var i=0,len=ev.touches.length; i<len; i++) {\n                startEv.touches.push(Hammer.utils.extend({}, ev.touches[i]));\n            }\n        }\n\n        var delta_time = ev.timeStamp - startEv.timeStamp,\n            delta_x = ev.center.pageX - startEv.center.pageX,\n            delta_y = ev.center.pageY - startEv.center.pageY,\n            velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y);\n\n        Hammer.utils.extend(ev, {\n            deltaTime   : delta_time,\n\n            deltaX      : delta_x,\n            deltaY      : delta_y,\n\n            velocityX   : velocity.x,\n            velocityY   : velocity.y,\n\n            distance    : Hammer.utils.getDistance(startEv.center, ev.center),\n            angle       : Hammer.utils.getAngle(startEv.center, ev.center),\n            direction   : Hammer.utils.getDirection(startEv.center, ev.center),\n\n            scale       : Hammer.utils.getScale(startEv.touches, ev.touches),\n            rotation    : Hammer.utils.getRotation(startEv.touches, ev.touches),\n\n            startEvent  : startEv\n        });\n\n        return ev;\n    },\n\n\n    /**\n     * register new gesture\n     * @param   {Object}    gesture object, see gestures.js for documentation\n     * @returns {Array}     gestures\n     */\n    register: function register(gesture) {\n        // add an enable gesture options if there is no given\n        var options = gesture.defaults || {};\n        if(options[gesture.name] === undefined) {\n            options[gesture.name] = true;\n        }\n\n        // extend Hammer default options with the Hammer.gesture options\n        Hammer.utils.extend(Hammer.defaults, options, true);\n\n        // set its index\n        gesture.index = gesture.index || 1000;\n\n        // add Hammer.gesture to the list\n        this.gestures.push(gesture);\n\n        // sort the list by index\n        this.gestures.sort(function(a, b) {\n            if (a.index < b.index) {\n                return -1;\n            }\n            if (a.index > b.index) {\n                return 1;\n            }\n            return 0;\n        });\n\n        return this.gestures;\n    }\n};\n\n\nHammer.gestures = Hammer.gestures || {};\n\n/**\n * Custom gestures\n * ==============================\n *\n * Gesture object\n * --------------------\n * The object structure of a gesture:\n *\n * { name: 'mygesture',\n *   index: 1337,\n *   defaults: {\n *     mygesture_option: true\n *   }\n *   handler: function(type, ev, inst) {\n *     // trigger gesture event\n *     inst.trigger(this.name, ev);\n *   }\n * }\n\n * @param   {String}    name\n * this should be the name of the gesture, lowercase\n * it is also being used to disable/enable the gesture per instance config.\n *\n * @param   {Number}    [index=1000]\n * the index of the gesture, where it is going to be in the stack of gestures detection\n * like when you build an gesture that depends on the drag gesture, it is a good\n * idea to place it after the index of the drag gesture.\n *\n * @param   {Object}    [defaults={}]\n * the default settings of the gesture. these are added to the instance settings,\n * and can be overruled per instance. you can also add the name of the gesture,\n * but this is also added by default (and set to true).\n *\n * @param   {Function}  handler\n * this handles the gesture detection of your custom gesture and receives the\n * following arguments:\n *\n *      @param  {Object}    eventData\n *      event data containing the following properties:\n *          timeStamp   {Number}        time the event occurred\n *          target      {HTMLElement}   target element\n *          touches     {Array}         touches (fingers, pointers, mouse) on the screen\n *          pointerType {String}        kind of pointer that was used. matches Hammer.POINTER_MOUSE|TOUCH\n *          center      {Object}        center position of the touches. contains pageX and pageY\n *          deltaTime   {Number}        the total time of the touches in the screen\n *          deltaX      {Number}        the delta on x axis we haved moved\n *          deltaY      {Number}        the delta on y axis we haved moved\n *          velocityX   {Number}        the velocity on the x\n *          velocityY   {Number}        the velocity on y\n *          angle       {Number}        the angle we are moving\n *          direction   {String}        the direction we are moving. matches Hammer.DIRECTION_UP|DOWN|LEFT|RIGHT\n *          distance    {Number}        the distance we haved moved\n *          scale       {Number}        scaling of the touches, needs 2 touches\n *          rotation    {Number}        rotation of the touches, needs 2 touches *\n *          eventType   {String}        matches Hammer.EVENT_START|MOVE|END\n *          srcEvent    {Object}        the source event, like TouchStart or MouseDown *\n *          startEvent  {Object}        contains the same properties as above,\n *                                      but from the first touch. this is used to calculate\n *                                      distances, deltaTime, scaling etc\n *\n *      @param  {Hammer.Instance}    inst\n *      the instance we are doing the detection for. you can get the options from\n *      the inst.options object and trigger the gesture event by calling inst.trigger\n *\n *\n * Handle gestures\n * --------------------\n * inside the handler you can get/set Hammer.detection.current. This is the current\n * detection session. It has the following properties\n *      @param  {String}    name\n *      contains the name of the gesture we have detected. it has not a real function,\n *      only to check in other gestures if something is detected.\n *      like in the drag gesture we set it to 'drag' and in the swipe gesture we can\n *      check if the current gesture is 'drag' by accessing Hammer.detection.current.name\n *\n *      @readonly\n *      @param  {Hammer.Instance}    inst\n *      the instance we do the detection for\n *\n *      @readonly\n *      @param  {Object}    startEvent\n *      contains the properties of the first gesture detection in this session.\n *      Used for calculations about timing, distance, etc.\n *\n *      @readonly\n *      @param  {Object}    lastEvent\n *      contains all the properties of the last gesture detect in this session.\n *\n * after the gesture detection session has been completed (user has released the screen)\n * the Hammer.detection.current object is copied into Hammer.detection.previous,\n * this is usefull for gestures like doubletap, where you need to know if the\n * previous gesture was a tap\n *\n * options that have been set by the instance can be received by calling inst.options\n *\n * You can trigger a gesture event by calling inst.trigger(\"mygesture\", event).\n * The first param is the name of your gesture, the second the event argument\n *\n *\n * Register gestures\n * --------------------\n * When an gesture is added to the Hammer.gestures object, it is auto registered\n * at the setup of the first Hammer instance. You can also call Hammer.detection.register\n * manually and pass your gesture object as a param\n *\n */\n\n/**\n * Hold\n * Touch stays at the same place for x time\n * @events  hold\n */\nHammer.gestures.Hold = {\n    name: 'hold',\n    index: 10,\n    defaults: {\n        hold_timeout\t: 500,\n        hold_threshold\t: 1\n    },\n    timer: null,\n    handler: function holdGesture(ev, inst) {\n        switch(ev.eventType) {\n            case Hammer.EVENT_START:\n                // clear any running timers\n                clearTimeout(this.timer);\n\n                // set the gesture so we can check in the timeout if it still is\n                Hammer.detection.current.name = this.name;\n\n                // set timer and if after the timeout it still is hold,\n                // we trigger the hold event\n                this.timer = setTimeout(function() {\n                    if(Hammer.detection.current.name == 'hold') {\n                        inst.trigger('hold', ev);\n                    }\n                }, inst.options.hold_timeout);\n                break;\n\n            // when you move or end we clear the timer\n            case Hammer.EVENT_MOVE:\n                if(ev.distance > inst.options.hold_threshold) {\n                    clearTimeout(this.timer);\n                }\n                break;\n\n            case Hammer.EVENT_END:\n                clearTimeout(this.timer);\n                break;\n        }\n    }\n};\n\n\n/**\n * Tap/DoubleTap\n * Quick touch at a place or double at the same place\n * @events  tap, doubletap\n */\nHammer.gestures.Tap = {\n    name: 'tap',\n    index: 100,\n    defaults: {\n        tap_max_touchtime\t: 250,\n        tap_max_distance\t: 10,\n\t\ttap_always\t\t\t: true,\n        doubletap_distance\t: 20,\n        doubletap_interval\t: 300\n    },\n    handler: function tapGesture(ev, inst) {\n        if(ev.eventType == Hammer.EVENT_END) {\n            // previous gesture, for the double tap since these are two different gesture detections\n            var prev = Hammer.detection.previous,\n\t\t\t\tdid_doubletap = false;\n\n            // when the touchtime is higher then the max touch time\n            // or when the moving distance is too much\n            if(ev.deltaTime > inst.options.tap_max_touchtime ||\n                ev.distance > inst.options.tap_max_distance) {\n                return;\n            }\n\n            // check if double tap\n            if(prev && prev.name == 'tap' &&\n                (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval &&\n                ev.distance < inst.options.doubletap_distance) {\n\t\t\t\tinst.trigger('doubletap', ev);\n\t\t\t\tdid_doubletap = true;\n            }\n\n\t\t\t// do a single tap\n\t\t\tif(!did_doubletap || inst.options.tap_always) {\n\t\t\t\tHammer.detection.current.name = 'tap';\n\t\t\t\tinst.trigger(Hammer.detection.current.name, ev);\n\t\t\t}\n        }\n    }\n};\n\n\n/**\n * Swipe\n * triggers swipe events when the end velocity is above the threshold\n * @events  swipe, swipeleft, swiperight, swipeup, swipedown\n */\nHammer.gestures.Swipe = {\n    name: 'swipe',\n    index: 40,\n    defaults: {\n        // set 0 for unlimited, but this can conflict with transform\n        swipe_max_touches  : 1,\n        swipe_velocity     : 0.7\n    },\n    handler: function swipeGesture(ev, inst) {\n        if(ev.eventType == Hammer.EVENT_END) {\n            // max touches\n            if(inst.options.swipe_max_touches > 0 &&\n                ev.touches.length > inst.options.swipe_max_touches) {\n                return;\n            }\n\n            // when the distance we moved is too small we skip this gesture\n            // or we can be already in dragging\n            if(ev.velocityX > inst.options.swipe_velocity ||\n                ev.velocityY > inst.options.swipe_velocity) {\n                // trigger swipe events\n                inst.trigger(this.name, ev);\n                inst.trigger(this.name + ev.direction, ev);\n            }\n        }\n    }\n};\n\n\n/**\n * Drag\n * Move with x fingers (default 1) around on the page. Blocking the scrolling when\n * moving left and right is a good practice. When all the drag events are blocking\n * you disable scrolling on that area.\n * @events  drag, drapleft, dragright, dragup, dragdown\n */\nHammer.gestures.Drag = {\n    name: 'drag',\n    index: 50,\n    defaults: {\n        drag_min_distance : 10,\n        // set 0 for unlimited, but this can conflict with transform\n        drag_max_touches  : 1,\n        // prevent default browser behavior when dragging occurs\n        // be careful with it, it makes the element a blocking element\n        // when you are using the drag gesture, it is a good practice to set this true\n        drag_block_horizontal   : false,\n        drag_block_vertical     : false,\n        // drag_lock_to_axis keeps the drag gesture on the axis that it started on,\n        // It disallows vertical directions if the initial direction was horizontal, and vice versa.\n        drag_lock_to_axis       : false,\n        // drag lock only kicks in when distance > drag_lock_min_distance\n        // This way, locking occurs only when the distance has become large enough to reliably determine the direction\n        drag_lock_min_distance : 25\n    },\n    triggered: false,\n    handler: function dragGesture(ev, inst) {\n        // current gesture isnt drag, but dragged is true\n        // this means an other gesture is busy. now call dragend\n        if(Hammer.detection.current.name != this.name && this.triggered) {\n            inst.trigger(this.name +'end', ev);\n            this.triggered = false;\n            return;\n        }\n\n        // max touches\n        if(inst.options.drag_max_touches > 0 &&\n            ev.touches.length > inst.options.drag_max_touches) {\n            return;\n        }\n\n        switch(ev.eventType) {\n            case Hammer.EVENT_START:\n                this.triggered = false;\n                break;\n\n            case Hammer.EVENT_MOVE:\n                // when the distance we moved is too small we skip this gesture\n                // or we can be already in dragging\n                if(ev.distance < inst.options.drag_min_distance &&\n                    Hammer.detection.current.name != this.name) {\n                    return;\n                }\n\n                // we are dragging!\n                Hammer.detection.current.name = this.name;\n\n                // lock drag to axis?\n                if(Hammer.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance<=ev.distance)) {\n                    ev.drag_locked_to_axis = true;\n                }\n                var last_direction = Hammer.detection.current.lastEvent.direction;\n                if(ev.drag_locked_to_axis && last_direction !== ev.direction) {\n                    // keep direction on the axis that the drag gesture started on\n                    if(Hammer.utils.isVertical(last_direction)) {\n                        ev.direction = (ev.deltaY < 0) ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;\n                    }\n                    else {\n                        ev.direction = (ev.deltaX < 0) ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;\n                    }\n                }\n\n                // first time, trigger dragstart event\n                if(!this.triggered) {\n                    inst.trigger(this.name +'start', ev);\n                    this.triggered = true;\n                }\n\n                // trigger normal event\n                inst.trigger(this.name, ev);\n\n                // direction event, like dragdown\n                inst.trigger(this.name + ev.direction, ev);\n\n                // block the browser events\n                if( (inst.options.drag_block_vertical && Hammer.utils.isVertical(ev.direction)) ||\n                    (inst.options.drag_block_horizontal && !Hammer.utils.isVertical(ev.direction))) {\n                    ev.preventDefault();\n                }\n                break;\n\n            case Hammer.EVENT_END:\n                // trigger dragend\n                if(this.triggered) {\n                    inst.trigger(this.name +'end', ev);\n                }\n\n                this.triggered = false;\n                break;\n        }\n    }\n};\n\n\n/**\n * Transform\n * User want to scale or rotate with 2 fingers\n * @events  transform, pinch, pinchin, pinchout, rotate\n */\nHammer.gestures.Transform = {\n    name: 'transform',\n    index: 45,\n    defaults: {\n        // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1\n        transform_min_scale     : 0.01,\n        // rotation in degrees\n        transform_min_rotation  : 1,\n        // prevent default browser behavior when two touches are on the screen\n        // but it makes the element a blocking element\n        // when you are using the transform gesture, it is a good practice to set this true\n        transform_always_block  : false\n    },\n    triggered: false,\n    handler: function transformGesture(ev, inst) {\n        // current gesture isnt drag, but dragged is true\n        // this means an other gesture is busy. now call dragend\n        if(Hammer.detection.current.name != this.name && this.triggered) {\n            inst.trigger(this.name +'end', ev);\n            this.triggered = false;\n            return;\n        }\n\n        // atleast multitouch\n        if(ev.touches.length < 2) {\n            return;\n        }\n\n        // prevent default when two fingers are on the screen\n        if(inst.options.transform_always_block) {\n            ev.preventDefault();\n        }\n\n        switch(ev.eventType) {\n            case Hammer.EVENT_START:\n                this.triggered = false;\n                break;\n\n            case Hammer.EVENT_MOVE:\n                var scale_threshold = Math.abs(1-ev.scale);\n                var rotation_threshold = Math.abs(ev.rotation);\n\n                // when the distance we moved is too small we skip this gesture\n                // or we can be already in dragging\n                if(scale_threshold < inst.options.transform_min_scale &&\n                    rotation_threshold < inst.options.transform_min_rotation) {\n                    return;\n                }\n\n                // we are transforming!\n                Hammer.detection.current.name = this.name;\n\n                // first time, trigger dragstart event\n                if(!this.triggered) {\n                    inst.trigger(this.name +'start', ev);\n                    this.triggered = true;\n                }\n\n                inst.trigger(this.name, ev); // basic transform event\n\n                // trigger rotate event\n                if(rotation_threshold > inst.options.transform_min_rotation) {\n                    inst.trigger('rotate', ev);\n                }\n\n                // trigger pinch event\n                if(scale_threshold > inst.options.transform_min_scale) {\n                    inst.trigger('pinch', ev);\n                    inst.trigger('pinch'+ ((ev.scale < 1) ? 'in' : 'out'), ev);\n                }\n                break;\n\n            case Hammer.EVENT_END:\n                // trigger dragend\n                if(this.triggered) {\n                    inst.trigger(this.name +'end', ev);\n                }\n\n                this.triggered = false;\n                break;\n        }\n    }\n};\n\n\n/**\n * Touch\n * Called as first, tells the user has touched the screen\n * @events  touch\n */\nHammer.gestures.Touch = {\n    name: 'touch',\n    index: -Infinity,\n    defaults: {\n        // call preventDefault at touchstart, and makes the element blocking by\n        // disabling the scrolling of the page, but it improves gestures like\n        // transforming and dragging.\n        // be careful with using this, it can be very annoying for users to be stuck\n        // on the page\n        prevent_default: false,\n\n        // disable mouse events, so only touch (or pen!) input triggers events\n        prevent_mouseevents: false\n    },\n    handler: function touchGesture(ev, inst) {\n        if(inst.options.prevent_mouseevents && ev.pointerType == Hammer.POINTER_MOUSE) {\n            ev.stopDetect();\n            return;\n        }\n\n        if(inst.options.prevent_default) {\n            ev.preventDefault();\n        }\n\n        if(ev.eventType ==  Hammer.EVENT_START) {\n            inst.trigger(this.name, ev);\n        }\n    }\n};\n\n\n/**\n * Release\n * Called as last, tells the user has released the screen\n * @events  release\n */\nHammer.gestures.Release = {\n    name: 'release',\n    index: Infinity,\n    handler: function releaseGesture(ev, inst) {\n        if(ev.eventType ==  Hammer.EVENT_END) {\n            inst.trigger(this.name, ev);\n        }\n    }\n};\n\n// node export\nif(typeof module === 'object' && typeof module.exports === 'object'){\n    module.exports = Hammer;\n}\n// just window export\nelse {\n    window.Hammer = Hammer;\n\n    // requireJS module definition\n    if(typeof window.define === 'function' && window.define.amd) {\n        window.define('hammer', [], function() {\n            return Hammer;\n        });\n    }\n}\n})(this);","/*!\n * jQuery Plugin: Are-You-Sure (Dirty Form Detection)\n * https://github.com/codedance/jquery.AreYouSure/\n *\n * Copyright (c) 2012-2014, Chris Dance and PaperCut Software http://www.papercut.com/\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * Author:  chris.dance@papercut.com\n * Version: 1.9.0\n * Date:    13th August 2014\n */\n(function($) {\n  \n  $.fn.areYouSure = function(options) {\n      \n    var settings = $.extend(\n      {\n        'message' : 'You have unsaved changes!',\n        'dirtyClass' : 'dirty',\n        'change' : null,\n        'silent' : false,\n        'addRemoveFieldsMarksDirty' : false,\n        'fieldEvents' : 'change keyup propertychange input',\n        'fieldSelector': \":input:not(input[type=submit]):not(input[type=button])\"\n      }, options);\n\n    var getValue = function($field) {\n      if ($field.hasClass('ays-ignore')\n          || $field.hasClass('aysIgnore')\n          || $field.attr('data-ays-ignore')\n          || $field.attr('name') === undefined) {\n        return null;\n      }\n\n      if ($field.is(':disabled')) {\n        return 'ays-disabled';\n      }\n\n      var val;\n      var type = $field.attr('type');\n      if ($field.is('select')) {\n        type = 'select';\n      }\n\n      switch (type) {\n        case 'checkbox':\n        case 'radio':\n          val = $field.is(':checked');\n          break;\n        case 'select':\n          val = '';\n          $field.find('option').each(function(o) {\n            var $option = $(this);\n            if ($option.is(':selected')) {\n              val += $option.val();\n            }\n          });\n          break;\n        default:\n          val = $field.val();\n      }\n\n      return val;\n    };\n\n    var storeOrigValue = function($field) {\n      $field.data('ays-orig', getValue($field));\n    };\n\n    var checkForm = function(evt) {\n\n      var isFieldDirty = function($field) {\n        var origValue = $field.data('ays-orig');\n        if (undefined === origValue) {\n          return false;\n        }\n        return (getValue($field) != origValue);\n      };\n\n      var $form = ($(this).is('form')) \n                    ? $(this)\n                    : $(this).parents('form');\n\n      // Test on the target first as it's the most likely to be dirty\n      if (isFieldDirty($(evt.target))) {\n        setDirtyStatus($form, true);\n        return;\n      }\n\n      $fields = $form.find(settings.fieldSelector);\n\n      if (settings.addRemoveFieldsMarksDirty) {              \n        // Check if field count has changed\n        var origCount = $form.data(\"ays-orig-field-count\");\n        if (origCount != $fields.length) {\n          setDirtyStatus($form, true);\n          return;\n        }\n      }\n\n      // Brute force - check each field\n      var isDirty = false;\n      $fields.each(function() {\n        $field = $(this);\n        if (isFieldDirty($field)) {\n          isDirty = true;\n          return false; // break\n        }\n      });\n      \n      setDirtyStatus($form, isDirty);\n    };\n\n    var initForm = function($form) {\n      var fields = $form.find(settings.fieldSelector);\n      $(fields).each(function() { storeOrigValue($(this)); });\n      $(fields).unbind(settings.fieldEvents, checkForm);\n      $(fields).bind(settings.fieldEvents, checkForm);\n      $form.data(\"ays-orig-field-count\", $(fields).length);\n      setDirtyStatus($form, false);\n    };\n\n    var setDirtyStatus = function($form, isDirty) {\n      var changed = isDirty != $form.hasClass(settings.dirtyClass);\n      $form.toggleClass(settings.dirtyClass, isDirty);\n        \n      // Fire change event if required\n      if (changed) {\n        if (settings.change) settings.change.call($form, $form);\n\n        if (isDirty) $form.trigger('dirty.areYouSure', [$form]);\n        if (!isDirty) $form.trigger('clean.areYouSure', [$form]);\n        $form.trigger('change.areYouSure', [$form]);\n      }\n    };\n\n    var rescan = function() {\n      var $form = $(this);\n      var fields = $form.find(settings.fieldSelector);\n      $(fields).each(function() {\n        var $field = $(this);\n        if (!$field.data('ays-orig')) {\n          storeOrigValue($field);\n          $field.bind(settings.fieldEvents, checkForm);\n        }\n      });\n      // Check for changes while we're here\n      $form.trigger('checkform.areYouSure');\n    };\n\n    var reinitialize = function() {\n      initForm($(this));\n    }\n\n    if (!settings.silent && !window.aysUnloadSet) {\n      window.aysUnloadSet = true;\n      $(window).bind('beforeunload', function() {\n        $dirtyForms = $(\"form\").filter('.' + settings.dirtyClass);\n        if ($dirtyForms.length == 0) {\n          return;\n        }\n        // Prevent multiple prompts - seen on Chrome and IE\n        if (navigator.userAgent.toLowerCase().match(/msie|chrome/)) {\n          if (window.aysHasPrompted) {\n            return;\n          }\n          window.aysHasPrompted = true;\n          window.setTimeout(function() {window.aysHasPrompted = false;}, 900);\n        }\n        return settings.message;\n      });\n    }\n\n    return this.each(function(elem) {\n      if (!$(this).is('form')) {\n        return;\n      }\n      var $form = $(this);\n        \n      $form.submit(function() {\n        $form.removeClass(settings.dirtyClass);\n      });\n      $form.bind('reset', function() { setDirtyStatus($form, false); });\n      // Add a custom events\n      $form.bind('rescan.areYouSure', rescan);\n      $form.bind('reinitialize.areYouSure', reinitialize);\n      $form.bind('checkform.areYouSure', checkForm);\n      initForm($form);\n    });\n  };\n})(jQuery);\n","/*! tinyColorPicker - v1.0.0 2015-03-31 */\n!function(a,b){\"use strict\";function c(a,c,d,f,g){if(\"string\"==typeof c){var c=t.txt2color(c);d=c.type,n[d]=c[d],g=g!==b?g:c.alpha}else if(c)for(var h in c)a[d][h]=k(c[h]/l[d][h][1],0,1);return g!==b&&(a.alpha=+g),e(d,f?a:b)}function d(a,b,c){var d=m.options.grey,e={};return e.RGB={r:a.r,g:a.g,b:a.b},e.rgb={r:b.r,g:b.g,b:b.b},e.alpha=c,e.equivalentGrey=Math.round(d.r*a.r+d.g*a.g+d.b*a.b),e.rgbaMixBlack=i(b,{r:0,g:0,b:0},c,1),e.rgbaMixWhite=i(b,{r:1,g:1,b:1},c,1),e.rgbaMixBlack.luminance=h(e.rgbaMixBlack,!0),e.rgbaMixWhite.luminance=h(e.rgbaMixWhite,!0),m.options.customBG&&(e.rgbaMixCustom=i(b,m.options.customBG,c,1),e.rgbaMixCustom.luminance=h(e.rgbaMixCustom,!0),m.options.customBG.luminance=h(m.options.customBG,!0)),e}function e(a,b){var c,e,k,o=b||n,p=t,q=m.options,r=l,s=o.RND,u=\"\",v=\"\",w={hsl:\"hsv\",rgb:a},x=s.rgb;if(\"alpha\"!==a){for(var y in r)if(!r[y][y]){a!==y&&(v=w[y]||\"rgb\",o[y]=p[v+\"2\"+y](o[v])),s[y]||(s[y]={}),c=o[y];for(u in c)s[y][u]=Math.round(c[u]*r[y][u][1])}x=s.rgb,o.HEX=p.RGB2HEX(x),o.equivalentGrey=q.grey.r*o.rgb.r+q.grey.g*o.rgb.g+q.grey.b*o.rgb.b,o.webSave=e=f(x,51),o.webSmart=k=f(x,17),o.saveColor=x.r===e.r&&x.g===e.g&&x.b===e.b?\"web save\":x.r===k.r&&x.g===k.g&&x.b===k.b?\"web smart\":\"\",o.hueRGB=t.hue2RGB(o.hsv.h),b&&(o.background=d(x,o.rgb,o.alpha))}var z,A,B,C=o.rgb,D=o.alpha,E=\"luminance\",F=o.background;return z=i(C,{r:0,g:0,b:0},D,1),z[E]=h(z,!0),o.rgbaMixBlack=z,A=i(C,{r:1,g:1,b:1},D,1),A[E]=h(A,!0),o.rgbaMixWhite=A,q.customBG&&(B=i(C,F.rgbaMixCustom,D,1),B[E]=h(B,!0),B.WCAG2Ratio=j(B[E],F.rgbaMixCustom[E]),o.rgbaMixBGMixCustom=B,B.luminanceDelta=Math.abs(B[E]-F.rgbaMixCustom[E]),B.hueDelta=g(F.rgbaMixCustom,B,!0)),o.RGBLuminance=h(x),o.HUELuminance=h(o.hueRGB),q.convertCallback&&q.convertCallback(o,a),o}function f(a,b){var c={},d=0,e=b/2;for(var f in a)d=a[f]%b,c[f]=a[f]+(d>e?b-d:-d);return c}function g(a,b,c){return(Math.max(a.r-b.r,b.r-a.r)+Math.max(a.g-b.g,b.g-a.g)+Math.max(a.b-b.b,b.b-a.b))*(c?255:1)/765}function h(a,b){for(var c=b?1:255,d=[a.r/c,a.g/c,a.b/c],e=m.options.luminance,f=d.length;f--;)d[f]=d[f]<=.03928?d[f]/12.92:Math.pow((d[f]+.055)/1.055,2.4);return e.r*d[0]+e.g*d[1]+e.b*d[2]}function i(a,c,d,e){var f={},g=d!==b?d:1,h=e!==b?e:1,i=g+h*(1-g);for(var j in a)f[j]=(a[j]*g+c[j]*h*(1-g))/i;return f.a=i,f}function j(a,b){var c=1;return c=a>=b?(a+.05)/(b+.05):(b+.05)/(a+.05),Math.round(100*c)/100}function k(a,b,c){return a>c?c:b>a?b:a}var l={rgb:{r:[0,255],g:[0,255],b:[0,255]},hsv:{h:[0,360],s:[0,100],v:[0,100]},hsl:{h:[0,360],s:[0,100],l:[0,100]},alpha:{alpha:[0,1]},HEX:{HEX:[0,16777215]}},m={},n={},o={r:.298954,g:.586434,b:.114612},p={r:.2126,g:.7152,b:.0722},q=a.Colors=function(a){this.colors={RND:{}},this.options={color:\"rgba(204, 82, 37, 0.8)\",grey:o,luminance:p,valueRanges:l},r(this,a||{})},r=function(a,d){var e,f=a.options;s(a);for(var g in d)d[g]!==b&&(f[g]=d[g]);e=f.customBG,f.customBG=\"string\"==typeof e?t.txt2color(e).rgb:e,n=c(a.colors,f.color,b,!0)},s=function(a){m!==a&&(m=a,n=a.colors)};q.prototype.setColor=function(a,d,f){return s(this),a?c(this.colors,a,d,b,f):(f!==b&&(this.colors.alpha=f),e(d))},q.prototype.setCustomBackground=function(a){return s(this),this.options.customBG=\"string\"==typeof a?t.txt2color(a).rgb:a,c(this.colors,b,\"rgb\")},q.prototype.saveAsBackground=function(){return s(this),c(this.colors,b,\"rgb\",!0)};var t={txt2color:function(a){var b={},c=a.replace(/(?:#|\\)|%)/g,\"\").split(\"(\"),d=(c[1]||\"\").split(/,\\s*/),e=c[1]?c[0].substr(0,3):\"rgb\",f=\"\";if(b.type=e,b[e]={},c[1])for(var g=3;g--;)f=e[g]||e.charAt(g),b[e][f]=+d[g]/l[e][f][1];else b.rgb=t.HEX2rgb(c[0]);return b.alpha=d[3]?+d[3]:1,b},RGB2HEX:function(a){return((a.r<16?\"0\":\"\")+a.r.toString(16)+(a.g<16?\"0\":\"\")+a.g.toString(16)+(a.b<16?\"0\":\"\")+a.b.toString(16)).toUpperCase()},HEX2rgb:function(a){return a=a.split(\"\"),{r:parseInt(a[0]+a[a[3]?1:0],16)/255,g:parseInt(a[a[3]?2:1]+(a[3]||a[1]),16)/255,b:parseInt((a[4]||a[2])+(a[5]||a[2]),16)/255}},hue2RGB:function(a){var b=6*a,c=~~b%6,d=6===b?0:b-c;return{r:Math.round(255*[1,1-d,0,0,d,1][c]),g:Math.round(255*[d,1,1,1-d,0,0][c]),b:Math.round(255*[0,0,d,1,1,1-d][c])}},rgb2hsv:function(a){var b,c,d,e=a.r,f=a.g,g=a.b,h=0;return g>f&&(f=g+(g=f,0),h=-1),c=g,f>e&&(e=f+(f=e,0),h=-2/6-h,c=Math.min(f,g)),b=e-c,d=e?b/e:0,{h:1e-15>d?n&&n.hsl&&n.hsl.h||0:b?Math.abs(h+(f-g)/(6*b)):0,s:e?b/e:n&&n.hsv&&n.hsv.s||0,v:e}},hsv2rgb:function(a){var b=6*a.h,c=a.s,d=a.v,e=~~b,f=b-e,g=d*(1-c),h=d*(1-f*c),i=d*(1-(1-f)*c),j=e%6;return{r:[d,h,g,g,i,d][j],g:[i,d,d,h,g,g][j],b:[g,g,i,d,d,h][j]}},hsv2hsl:function(a){var b=(2-a.s)*a.v,c=a.s*a.v;return c=a.s?1>b?b?c/b:0:c/(2-b):0,{h:a.h,s:a.v||c?c:n&&n.hsl&&n.hsl.s||0,l:b/2}},rgb2hsl:function(a,b){var c=t.rgb2hsv(a);return t.hsv2hsl(b?c:n.hsv=c)},hsl2rgb:function(a){var b=6*a.h,c=a.s,d=a.l,e=.5>d?d*(1+c):d+c-c*d,f=d+d-e,g=e?(e-f)/e:0,h=~~b,i=b-h,j=e*g*i,k=f+j,l=e-j,m=h%6;return{r:[e,l,f,f,k,e][m],g:[k,e,e,l,f,f][m],b:[f,f,k,e,e,l][m]}}}}(window);\n!function(a,b,c){\"use strict\";function d(b){return b.value||b.getAttribute(\"value\")||a(b).css(\"background-color\")||\"#fff\"}function e(a){return a.originalEvent.touches?a.originalEvent.touches[0]:a}function f(b){return a(b.find(s.doRender)[0]||b[0])}function g(b){var c=a(this),e=c.offset(),g=a(window),i=s.gap;b?(t=f(c),q.$trigger=c,(u||h()).css({left:(u[0]._left=e.left)-((u[0]._left=u[0]._left+u[0]._width-(g.scrollLeft()+g.width()))+i>0?u[0]._left+i:0),top:(u[0]._top=e.top+c.outerHeight())-((u[0]._top=u[0]._top+u[0]._height-(g.scrollTop()+g.height()))+i>0?u[0]._top+i:0)}).show(s.animationSpeed,function(){b!==!0&&(y._width=y.width(),v._width=v.width(),v._height=v.height(),r.setColor(d(t[0])),n(!0))})):a(u).hide(s.animationSpeed,function(){t.blur(),q.$trigger=null,n(!1)})}function h(){return a(\"head\").append('<style type=\"text/css\">'+(s.css||H)+(s.cssAddon||\"\")+\"</style>\"),q.$UI=u=a(G).css({margin:s.margin}).appendTo(\"body\").show(0,function(){var b=a(this);E=s.GPU&&b.css(\"perspective\")!==c,v=a(\".cp-xy-slider\",this),w=a(\".cp-xy-cursor\",this),x=a(\".cp-z-cursor\",this),y=a(\".cp-alpha\",this).toggle(!!s.opacity),z=a(\".cp-alpha-cursor\",this),s.buildCallback.call(q,b),b.prepend(\"<div>\").children().eq(0).css(\"width\",b.children().eq(0).width()),this._width=this.offsetWidth,this._height=this.offsetHeight}).hide().on(\"touchstart mousedown pointerdown\",\".cp-xy-slider,.cp-z-slider,.cp-alpha\",i)}function i(b){var c=this.className.replace(/cp-(.*?)(?:\\s*|$)/,\"$1\").replace(\"-\",\"_\");b.preventDefault&&b.preventDefault(),b.returnValue=!1,t._offset=a(this).offset(),(c=\"xy_slider\"===c?k:\"z_slider\"===c?l:m)(b),A.on(D,j).on(C,c)}function j(){A.off(C).off(D)}function k(a){var b=e(a),c=b.pageX-t._offset.left,d=b.pageY-t._offset.top;r.setColor({s:c/v._width*100,v:100-d/v._height*100},\"hsv\"),n()}function l(a){{var b=e(a).pageY-t._offset.top;r.colors.hsv}r.setColor({h:360-b/v._height*360},\"hsv\"),n()}function m(a){var b=e(a).pageX-t._offset.left,c=b/y._width;r.setColor({},\"rgb\",c>1?1:0>c?0:c),n()}function n(a){var b=r.colors,d=b.hueRGB,e=b.RND.rgb,f=b.RND.hsl,g=\"#222\",h=\"#ddd\",i=t.data(\"colorMode\"),j=1!==b.alpha,k=Math.round(100*b.alpha)/100,l=e.r+\", \"+e.g+\", \"+e.b,m=\"HEX\"!==i||j?\"rgb\"===i||\"HEX\"===i&&j?j?\"rgba(\"+l+\", \"+k+\")\":\"rgb(\"+l+\")\":\"hsl\"+(j?\"a(\":\"(\")+f.h+\", \"+f.s+\"%, \"+f.l+\"%\"+(j?\", \"+k:\"\")+\")\":\"#\"+b.HEX,n=b.HUELuminance>.22?g:h,p=b.rgbaMixBlack.luminance>.22?g:h,q=(1-b.hsv.h)*v._height,s=b.hsv.s*v._width,u=(1-b.hsv.v)*v._height,A=k*y._width,B=E?\"translate3d\":\"\",C=t.val(),D=t[0].hasAttribute(\"value\")&&\"\"===C&&a!==c;v._css={backgroundColor:\"rgb(\"+d.r+\",\"+d.g+\",\"+d.b+\")\"},w._css={transform:B+\"(\"+s+\"px, \"+u+\"px, 0)\",left:E?\"\":s,top:E?\"\":u,borderColor:b.RGBLuminance>.22?g:h},x._css={transform:B+\"(0, \"+q+\"px, 0)\",top:E?\"\":q,borderColor:\"transparent \"+n},y._css={backgroundColor:\"rgb(\"+l+\")\"},z._css={transform:B+\"(\"+A+\"px, 0, 0)\",left:E?\"\":A,borderColor:p+\" transparent\"},t._css={backgroundColor:D?\"\":m,color:D?\"\":b.rgbaMixBGMixCustom.luminance>.22?g:h},t.text=D?\"\":C!==m?m:\"\",a!==c?o(a):F(o)}function o(a){v.css(v._css),w.css(w._css),x.css(x._css),y.css(y._css),z.css(z._css),s.doRender&&t.css(t._css),t.text&&t.val(t.text),s.renderCallback.call(q,t,\"boolean\"==typeof a?a:c)}var p,q,r,s,t,u,v,w,x,y,z,A=a(document),B=\"\",C=\"touchmove mousemove pointermove\",D=\"touchend mouseup pointerup\",E=!1,F=window.requestAnimationFrame||window.webkitRequestAnimationFrame||function(a){a()},G='<div class=\"cp-color-picker\"><div class=\"cp-z-slider\"><div class=\"cp-z-cursor\"></div></div><div class=\"cp-xy-slider\"><div class=\"cp-white\"></div><div class=\"cp-xy-cursor\"></div></div><div class=\"cp-alpha\"><div class=\"cp-alpha-cursor\"></div></div></div>',H=\".cp-color-picker{position:absolute;overflow:hidden;padding:6px 6px 0;background-color:#444;color:#bbb;font-family:Arial,Helvetica,sans-serif;font-size:12px;font-weight:400;cursor:default;border-radius:5px}.cp-color-picker>div{position:relative;overflow:hidden}.cp-xy-slider{float:left;height:128px;width:128px;margin-bottom:6px;background:linear-gradient(to right,#FFF,rgba(255,255,255,0))}.cp-white{height:100%;width:100%;background:linear-gradient(rgba(0,0,0,0),#000)}.cp-xy-cursor{position:absolute;top:0;width:10px;height:10px;margin:-5px;border:1px solid #fff;border-radius:100%;box-sizing:border-box}.cp-z-slider{float:right;margin-left:6px;height:128px;width:20px;background:linear-gradient(red 0,#f0f 17%,#00f 33%,#0ff 50%,#0f0 67%,#ff0 83%,red 100%)}.cp-z-cursor{position:absolute;margin-top:-4px;width:100%;border:4px solid #fff;border-color:transparent #fff;box-sizing:border-box}.cp-alpha{clear:both;width:100%;height:16px;margin:6px 0;background:linear-gradient(to right,#444,rgba(0,0,0,0))}.cp-alpha-cursor{position:absolute;margin-left:-4px;height:100%;border:4px solid #fff;border-color:#fff transparent;box-sizing:border-box}\",I=function(a){r=this.color=new b(a),s=r.options};I.prototype={render:n,toggle:g},a.fn.colorPicker=function(b){var c=function(){};return b=a.extend({animationSpeed:150,GPU:!0,doRender:!0,customBG:\"#FFF\",opacity:!0,renderCallback:c,buildCallback:c,body:document.body,scrollResize:!0,gap:4},b),!q&&b.scrollResize&&a(window).on(\"resize scroll\",function(){q.$trigger&&q.toggle.call(q.$trigger[0],!0)}),p=p?p.add(this):this,p.colorPicker=q||(q=new I(b)),B+=(B?\", \":\"\")+this.selector,a(b.body).off(\".a\").on(\"touchstart.a mousedown.a pointerdown.a\",function(b){var c=a(b.target);-1!==a.inArray(c.closest(B)[0],p)||c.closest(u).length||g()}).on(\"focus.a click.a\",B,g).on(\"change.a\",B,function(){r.setColor(this.value||\"#FFF\"),p.colorPicker.render(!0)}),this.each(function(){var c=d(this),e=c.split(\"(\"),g=f(a(this));g.data(\"colorMode\",e[1]?e[0].substr(0,3):\"HEX\").attr(\"readonly\",s.preventFocus),b.doRender&&g.css({\"background-color\":c,color:function(){return r.setColor(c).rgbaMixBGMixCustom.luminance>.22?\"#222\":\"#ddd\"}})})}}(jQuery,Colors);\n//# sourceMappingURL=jqColorPicker.js.map","(function() {\n  // helper functions\n  function is_touch_device() {\n    return 'ontouchstart' in window || // works on most browsers\n           'onmsgesturechange' in window; // works on ie10\n  }\n\n  function fill(value, target, container) {\n    if (value + target < container)\n      value = container - target;\n    return value > 0 ? 0 : value;\n  }\n\n  function uri2blob(dataURI) {\n      var uriComponents = dataURI.split(',');\n      var byteString = atob(uriComponents[1]);\n      var mimeString = uriComponents[0].split(':')[1].split(';')[0];\n      var ab = new ArrayBuffer(byteString.length);\n      var ia = new Uint8Array(ab);\n      for (var i = 0; i < byteString.length; i++)\n          ia[i] = byteString.charCodeAt(i);\n      return new Blob([ab], { type: mimeString });\n  }\n\n  var pluginName = 'cropbox';\n\n  function factory($) {\n    function Crop($image, options) {\n      this.width = null;\n      this.height = null;\n      this.img_width = null;\n      this.img_height = null;\n      this.img_left = 0;\n      this.img_top = 0;\n      this.minPercent = null;\n      this.options = options;\n      this.$image = $image;\n      this.$image.hide().prop('draggable', false).addClass('cropImage').wrap('<div class=\"cropFrame\" />'); // wrap image in frame;\n      this.$frame = this.$image.parent();\n      this.init();\n    }\n\n    Crop.prototype = {\n      init: function () {\n        var self = this;\n\n        var defaultControls = $('<div/>', { 'class' : 'cropControls' })\n              .append($('<span>Drag to crop</span>'))\n              .append($('<a/>', { 'class' : 'cropZoomIn' }).on('click', $.proxy(this.zoomIn, this)))\n              .append($('<a/>', { 'class' : 'cropZoomOut' }).on('click', $.proxy(this.zoomOut, this)));\n\n        this.$frame.append(this.options.controls || defaultControls);\n        this.updateOptions();\n\n        if (typeof $.fn.hammer === 'function' || typeof Hammer !== 'undefined') {\n          var hammerit, dragData;\n          if (typeof $.fn.hammer === 'function')\n            hammerit = this.$image.hammer();\n          else\n            hammerit = Hammer(this.$image.get(0));\n\n          hammerit.on('touch', function(e) {\n            e.gesture.preventDefault();\n          }).on(\"dragleft dragright dragup dragdown\", function(e) {\n            if (!dragData)\n              dragData = {\n                startX: self.img_left,\n                startY: self.img_top,\n              };\n            dragData.dx = e.gesture.deltaX;\n            dragData.dy = e.gesture.deltaY;\n            e.gesture.preventDefault();\n            e.gesture.stopPropagation();\n            self.drag.call(self, dragData, true);\n          }).on('release', function(e) {\n            e.gesture.preventDefault();\n            dragData = null;\n            self.update.call(self);\n          }).on('doubletap', function(e) {\n            e.gesture.preventDefault();\n            self.zoomIn.call(self);\n          }).on('pinchin', function (e) {\n            e.gesture.preventDefault();\n            self.zoomOut.call(self);\n          }).on('pinchout', function (e) {\n            e.gesture.preventDefault();\n            self.zoomIn.call(self);\n          });\n        } else {\n          this.$image.on('mousedown.' + pluginName, function(e1) {\n            var dragData = {\n              startX: self.img_left,\n              startY: self.img_top,\n            };\n            e1.preventDefault();\n            $(document).on('mousemove.' + pluginName, function (e2) {\n              dragData.dx = e2.pageX - e1.pageX;\n              dragData.dy = e2.pageY - e1.pageY;\n              self.drag.call(self, dragData, true);\n            }).on('mouseup.' + pluginName, function() {\n              self.update.call(self);\n              $(document).off('mouseup.' + pluginName);\n              $(document).off('mousemove.' + pluginName);\n            });\n          });\n        }\n        if ($.fn.mousewheel) {\n          this.$image.on('mousewheel.' + pluginName, function (e) {\n            e.preventDefault();\n            if (e.deltaY < 0)\n              self.zoomIn.call(self);\n            else\n              self.zoomOut.call(self);\n          });\n        }\n      },\n\n      updateOptions: function () {\n        var self = this;\n        self.img_top = 0;\n        self.img_left = 0;\n        self.$image.css({width: '', left: self.img_left, top: self.img_top});\n        self.$frame.width(self.options.width).height(self.options.height);\n        self.$frame.off('.' + pluginName);\n        self.$frame.removeClass('hover');\n        if (self.options.showControls === 'always' || self.options.showControls === 'auto' && is_touch_device())\n          self.$frame.addClass('hover');\n        else if (self.options.showControls !== 'never') {\n          self.$frame.on('mouseenter.' + pluginName, function () { self.$frame.addClass('hover'); });\n          self.$frame.on('mouseleave.' + pluginName, function () { self.$frame.removeClass('hover'); });\n        }\n\n        // Image hack to get width and height on IE\n        var img = new Image();\n        img.src = self.$image.attr('src');\n        img.onload = function () {\n          self.width = img.width;\n          self.height = img.height;\n          img.src = '';\n          img.onload = null;\n          self.percent = undefined;\n          self.fit.call(self);\n          if (self.options.result)\n            self.setCrop.call(self, self.options.result);\n          else\n            self.zoom.call(self, self.minPercent);\n          self.$image.fadeIn('fast');\n        };\n      },\n\n      remove: function () {\n        var hammerit;\n        if (typeof $.fn.hammer === 'function')\n          hammerit = this.$image.hammer();\n        else if (typeof Hammer !== 'undefined')\n          hammerit = Hammer(this.$image.get(0));\n        if (hammerit)\n          hammerit.off('mousedown dragleft dragright dragup dragdown release doubletap pinchin pinchout');\n        this.$frame.off('.' + pluginName);\n        this.$image.off('.' + pluginName);\n        this.$image.css({width: '', left: '', top: ''});\n        this.$image.removeClass('cropImage');\n        this.$image.removeData('cropbox');\n        this.$image.insertAfter(this.$frame);\n        this.$frame.removeClass('cropFrame');\n        this.$frame.removeAttr('style');\n        this.$frame.empty();\n        this.$frame.hide();\n      },\n\n      fit: function () {\n        var widthRatio = this.options.width / this.width,\n          heightRatio = this.options.height / this.height;\n        this.minPercent = (widthRatio >= heightRatio) ? widthRatio : heightRatio;\n      },\n\n      setCrop: function (result) {\n        this.percent = Math.max(this.options.width/result.cropW, this.options.height/result.cropH);\n        this.img_width = Math.ceil(this.width*this.percent);\n        this.img_height = Math.ceil(this.height*this.percent);\n        this.img_left = -Math.floor(result.cropX*this.percent);\n        this.img_top = -Math.floor(result.cropY*this.percent);\n        this.$image.css({ width: this.img_width, left: this.img_left, top: this.img_top });\n        this.update();\n      },\n\n      zoom: function(percent) {\n        var old_percent = this.percent;\n\n        this.percent = Math.max(this.minPercent, Math.min(this.options.maxZoom, percent));\n        this.img_width = Math.ceil(this.width * this.percent);\n        this.img_height = Math.ceil(this.height * this.percent);\n\n        if (old_percent) {\n          var zoomFactor = this.percent / old_percent;\n          this.img_left = fill((1 - zoomFactor) * this.options.width / 2 + zoomFactor * this.img_left, this.img_width, this.options.width);\n          this.img_top = fill((1 - zoomFactor) * this.options.height / 2 + zoomFactor * this.img_top, this.img_height, this.options.height);\n        } else {\n          this.img_left = fill((this.options.width - this.img_width) / 2, this.img_width,  this.options.width);\n          this.img_top = fill((this.options.height - this.img_height) / 2, this.img_height, this.options.height);\n        }\n\n        this.$image.css({ width: this.img_width, left: this.img_left, top: this.img_top });\n        this.update();\n      },\n      zoomIn: function() {\n        this.zoom(this.percent + (1 - this.minPercent) / (this.options.zoom - 1 || 1));\n      },\n      zoomOut: function() {\n        this.zoom(this.percent - (1 - this.minPercent) / (this.options.zoom - 1 || 1));\n      },\n      drag: function(data, skipupdate) {\n        this.img_left = fill(data.startX + data.dx, this.img_width, this.options.width);\n        this.img_top = fill(data.startY + data.dy, this.img_height, this.options.height);\n        this.$image.css({ left: this.img_left, top: this.img_top });\n        if (skipupdate)\n          this.update();\n      },\n      update: function() {\n        this.result = {\n          cropX: -Math.ceil(this.img_left / this.percent),\n          cropY: -Math.ceil(this.img_top / this.percent),\n          cropW: Math.floor(this.options.width / this.percent),\n          cropH: Math.floor(this.options.height / this.percent),\n          stretch: this.minPercent > 1\n        };\n\n        this.$image.trigger(pluginName, [this.result, this]);\n      },\n      getDataURL: function () {\n        var canvas = document.createElement('canvas'), ctx = canvas.getContext('2d');\n        canvas.width = this.options.width;\n        canvas.height = this.options.height;\n        ctx.drawImage(this.$image.get(0), this.result.cropX, this.result.cropY, this.result.cropW, this.result.cropH, 0, 0, this.options.width, this.options.height);\n        return canvas.toDataURL();\n      },\n      getBlob: function () {\n        return uri2blob(this.getDataURL());\n      },\n    };\n\n    $.fn[pluginName] = function(options) {\n      return this.each(function() {\n        var inst = $.data(this, pluginName);\n        if (!inst) {\n          var opts = $.extend({}, $.fn[pluginName].defaultOptions, options);\n          $.data(this, pluginName, new Crop($(this), opts));\n        } else if (options) {\n          $.extend(inst.options, options);\n          inst.updateOptions();\n        }\n      });\n    };\n\n    $.fn[pluginName].defaultOptions = {\n      width: 200,\n      height: 200,\n      zoom: 10,\n      maxZoom: 1,\n      controls: null,\n      showControls: 'auto'\n    };\n  }\n\n  if (typeof require === \"function\" && typeof exports === \"object\" && typeof module === \"object\")\n      factory(require(\"jquery\"));\n  else if (typeof define === \"function\" && define.amd)\n      define([\"jquery\"], factory);\n  else\n      factory(window.jQuery || window.Zepto);\n\n})();\n","/* @license ! jQuery-mutate - v0.0.2 - \n* Licensed under the MIT license\n* http://www.opensource.org/licenses/mit-license.php\n* Date: 2015-04-19 */\n\n!function(t){mutate_event_stack=[{name:\"width\",handler:function(a){var e=t(a);return e.data(\"mutate-width\")||e.data(\"mutate-width\",e.width()),e.data(\"mutate-width\")&&e.width()!=e.data(\"mutate-width\")?(e.data(\"mutate-width\",e.width()),!0):!1}},{name:\"height\",handler:function(a){var e=t(a);return e.data(\"mutate-height\")||e.data(\"mutate-height\",e.height()),e.data(\"mutate-height\")&&e.height()!=e.data(\"mutate-height\")?(e.data(\"mutate-height\",e.height()),!0):void 0}},{name:\"top\",handler:function(a){var e=t(a);return e.data(\"mutate-top\")||e.data(\"mutate-top\",e.css(\"top\")),e.data(\"mutate-top\")&&e.css(\"top\")!=e.data(\"mutate-top\")?(e.data(\"mutate-top\",e.css(\"top\")),!0):void 0}},{name:\"bottom\",handler:function(a){var e=t(a);return e.data(\"mutate-bottom\")||e.data(\"mutate-bottom\",e.css(\"bottom\")),e.data(\"mutate-bottom\")&&e.css(\"bottom\")!=e.data(\"mutate-bottom\")?(e.data(\"mutate-bottom\",e.css(\"bottom\")),!0):void 0}},{name:\"right\",handler:function(a){var e=t(a);return e.data(\"mutate-right\")||e.data(\"mutate-right\",e.css(\"right\")),e.data(\"mutate-right\")&&e.css(\"right\")!=e.data(\"mutate-right\")?(e.data(\"mutate-right\",e.css(\"right\")),!0):void 0}},{name:\"left\",handler:function(a){var e=t(a);return e.data(\"mutate-left\")||e.data(\"mutate-left\",e.css(\"left\")),e.data(\"mutate-left\")&&e.css(\"left\")!=e.data(\"mutate-left\")?(e.data(\"mutate-left\",e.css(\"left\")),!0):void 0}},{name:\"hide\",handler:function(a){var e=t(a),r=e.is(\":hidden\"),d=void 0==e.data(\"prev-hidden\")?r:e.data(\"prev-hidden\");return e.data(\"prev-hidden\",r),r&&r!=d?!0:void 0}},{name:\"show\",handler:function(a){var e=t(a),r=e.is(\":visible\"),d=void 0==e.data(\"prev-visible\")?r:e.data(\"prev-visible\");return e.data(\"prev-visible\",r),r&&r!=d?!0:void 0}},{name:\"scrollHeight\",handler:function(a){var e=t(a);return e.data(\"prev-scrollHeight\")||e.data(\"prev-scrollHeight\",e[0].scrollHeight),e.data(\"prev-scrollHeight\")&&e[0].scrollHeight!=e.data(\"prev-scrollHeight\")?(e.data(\"prev-scrollHeight\",e[0].scrollHeight),!0):void 0}},{name:\"scrollWidth\",handler:function(a){var e=t(a);return e.data(\"prev-scrollWidth\")||e.data(\"prev-scrollWidth\",e[0].scrollWidth),e.data(\"prev-scrollWidth\")&&e[0].scrollWidth!=e.data(\"prev-scrollWidth\")?(e.data(\"prev-scrollWidth\",e[0].scrollWidth),!0):void 0}},{name:\"scrollTop\",handler:function(a){var e=t(a);return e.data(\"prev-scrollTop\")||e.data(\"prev-scrollTop\",e[0].scrollTop()),e.data(\"prev-scrollTop\")&&e[0].scrollTop()!=e.data(\"prev-scrollTop\")?(e.data(\"prev-scrollTop\",e[0].scrollTop()),!0):void 0}},{name:\"scrollLeft\",handler:function(a){var e=t(a);return e.data(\"prev-scrollLeft\")||e.data(\"prev-scrollLeft\",e[0].scrollLeft()),e.data(\"prev-scrollLeft\")&&e[0].scrollLeft()!=e.data(\"prev-scrollLeft\")?(e.data(\"prev-scrollLeft\",e[0].scrollLeft()),!0):void 0}}]}(jQuery);","/*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)\n * Licensed under the MIT License (LICENSE.txt).\n *\n * Version: 3.1.6\n *\n * Requires: jQuery 1.2.2+\n */\n\n(function (factory) {\n    if ( typeof define === 'function' && define.amd ) {\n        // AMD. Register as an anonymous module.\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object') {\n        // Node/CommonJS style for Browserify\n        module.exports = factory;\n    } else {\n        // Browser globals\n        factory(jQuery);\n    }\n}(function ($) {\n\n    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],\n        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?\n                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],\n        slice  = Array.prototype.slice,\n        nullLowestDeltaTimeout, lowestDelta;\n\n    if ( $.event.fixHooks ) {\n        for ( var i = toFix.length; i; ) {\n            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;\n        }\n    }\n\n    $.event.special.mousewheel = {\n        version: '3.1.6',\n\n        setup: function() {\n            if ( this.addEventListener ) {\n                for ( var i = toBind.length; i; ) {\n                    this.addEventListener( toBind[--i], handler, false );\n                }\n            } else {\n                this.onmousewheel = handler;\n            }\n        },\n\n        teardown: function() {\n            if ( this.removeEventListener ) {\n                for ( var i = toBind.length; i; ) {\n                    this.removeEventListener( toBind[--i], handler, false );\n                }\n            } else {\n                this.onmousewheel = null;\n            }\n        }\n    };\n\n    $.fn.extend({\n        mousewheel: function(fn) {\n            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');\n        },\n\n        unmousewheel: function(fn) {\n            return this.unbind('mousewheel', fn);\n        }\n    });\n\n\n    function handler(event) {\n        var orgEvent   = event || window.event,\n            args       = slice.call(arguments, 1),\n            delta      = 0,\n            deltaX     = 0,\n            deltaY     = 0,\n            absDelta   = 0;\n        event = $.event.fix(orgEvent);\n        event.type = 'mousewheel';\n\n        // Old school scrollwheel delta\n        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }\n        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }\n        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }\n        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }\n\n        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\n        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {\n            deltaX = deltaY * -1;\n            deltaY = 0;\n        }\n\n        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy\n        delta = deltaY === 0 ? deltaX : deltaY;\n\n        // New school wheel delta (wheel event)\n        if ( 'deltaY' in orgEvent ) {\n          deltaY = orgEvent.deltaY * -1;\n          delta  = deltaY;\n        }\n        if ( 'deltaX' in orgEvent ) {\n          deltaX = orgEvent.deltaX;\n          if ( deltaY === 0 ) { delta  = deltaX * -1; }\n        }\n\n        // No change actually happened, no reason to go any further\n        if ( deltaY === 0 && deltaX === 0 ) { return; }\n\n        // Store lowest absolute delta to normalize the delta values\n        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );\n        if ( !lowestDelta || absDelta < lowestDelta ) {\n          lowestDelta = absDelta;\n        }\n\n        // Get a whole, normalized value for the deltas\n        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);\n        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);\n        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);\n\n        // Add information to the event object\n        event.deltaX = deltaX;\n        event.deltaY = deltaY;\n        event.deltaFactor = lowestDelta;\n\n        // Add event and delta to the front of the arguments\n        args.unshift(event, delta, deltaX, deltaY);\n\n        // Clearout lowestDelta after sometime to better\n        // handle multiple device types that give different\n        // a different lowestDelta\n        // Ex: trackpad = 3 and mouse wheel = 120\n        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }\n        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);\n\n        return ($.event.dispatch || $.event.handle).apply(this, args);\n    }\n\n    function nullLowestDelta() {\n      lowestDelta = null;\n    }\n\n}));\n","/* @license ! jQuery-mutate - v0.0.1 - \n* Licensed under the MIT license\n* http://www.opensource.org/licenses/mit-license.php\n* Date: 2015-04-19 */\n\n!function(a){function b(){var c=mutate;\"undefined\"!=c.event_stack&&c.event_stack.length&&a.each(c.event_stack,function(a,b){mutate.add_event(b)}),c.event_stack=[],a.each(c.stack,function(b,d){a(d.selector).each(function(a,b){c.events[d.event_name](b)===!0?d.callback&&d.callback(b,d):d.false_callback&&d.false_callback(b,d)})}),setTimeout(b,mutate.speed)}mutate={speed:100,event_stack:mutate_event_stack,stack:[],events:{},add_event:function(a){mutate.events[a.name]=a.handler},add:function(a,b,c,d){mutate.stack[mutate.stack.length]={event_name:a,selector:b,callback:c,false_callback:d}}},b(),a.fn.extend({mutate:function(){var b=!1,c=arguments[1],d=this,e=arguments[2]?arguments[2]:function(){};return\"extend\"==arguments[0].toLowerCase()?(mutate.add_event(c),this):(a.each(a.trim(arguments[0]).split(\" \"),function(a,f){b=f,mutate.add(b,d,c,e)}),this)}})}(jQuery);","/*!\n * pickadate.js v3.5.6, 2015/04/20\n * By Amsul, http://amsul.ca\n * Hosted on http://amsul.github.io/pickadate.js\n * Licensed under MIT\n */\n!function(a){\"function\"==typeof define&&define.amd?define(\"picker\",[\"jquery\"],a):\"object\"==typeof exports?module.exports=a(require(\"jquery\")):this.Picker=a(jQuery)}(function(a){function b(f,g,i,m){function n(){return b._.node(\"div\",b._.node(\"div\",b._.node(\"div\",b._.node(\"div\",B.component.nodes(w.open),y.box),y.wrap),y.frame),y.holder,'tabindex=\"-1\"')}function o(){z.data(g,B).addClass(y.input).val(z.data(\"value\")?B.get(\"select\",x.format):f.value),x.editable||z.on(\"focus.\"+w.id+\" click.\"+w.id,function(a){a.preventDefault(),B.open()}).on(\"keydown.\"+w.id,u),e(f,{haspopup:!0,expanded:!1,readonly:!1,owns:f.id+\"_root\"})}function p(){e(B.$root[0],\"hidden\",!0)}function q(){B.$holder.on({keydown:u,\"focus.toOpen\":t,blur:function(){z.removeClass(y.target)},focusin:function(a){B.$root.removeClass(y.focused),a.stopPropagation()},\"mousedown click\":function(b){var c=b.target;c!=B.$holder[0]&&(b.stopPropagation(),\"mousedown\"!=b.type||a(c).is(\"input, select, textarea, button, option\")||(b.preventDefault(),B.$holder[0].focus()))}}).on(\"click\",\"[data-pick], [data-nav], [data-clear], [data-close]\",function(){var b=a(this),c=b.data(),d=b.hasClass(y.navDisabled)||b.hasClass(y.disabled),e=h();e=e&&(e.type||e.href),(d||e&&!a.contains(B.$root[0],e))&&B.$holder[0].focus(),!d&&c.nav?B.set(\"highlight\",B.component.item.highlight,{nav:c.nav}):!d&&\"pick\"in c?(B.set(\"select\",c.pick),x.closeOnSelect&&B.close(!0)):c.clear?(B.clear(),x.closeOnClear&&B.close(!0)):c.close&&B.close(!0)})}function r(){var b;x.hiddenName===!0?(b=f.name,f.name=\"\"):(b=[\"string\"==typeof x.hiddenPrefix?x.hiddenPrefix:\"\",\"string\"==typeof x.hiddenSuffix?x.hiddenSuffix:\"_submit\"],b=b[0]+f.name+b[1]),B._hidden=a('<input type=hidden name=\"'+b+'\"'+(z.data(\"value\")||f.value?' value=\"'+B.get(\"select\",x.formatSubmit)+'\"':\"\")+\">\")[0],z.on(\"change.\"+w.id,function(){B._hidden.value=f.value?B.get(\"select\",x.formatSubmit):\"\"})}function s(){v&&l?B.$holder.find(\".\"+y.frame).one(\"transitionend\",function(){B.$holder[0].focus()}):B.$holder[0].focus()}function t(a){a.stopPropagation(),z.addClass(y.target),B.$root.addClass(y.focused),B.open()}function u(a){var b=a.keyCode,c=/^(8|46)$/.test(b);return 27==b?(B.close(!0),!1):void((32==b||c||!w.open&&B.component.key[b])&&(a.preventDefault(),a.stopPropagation(),c?B.clear().close():B.open()))}if(!f)return b;var v=!1,w={id:f.id||\"P\"+Math.abs(~~(Math.random()*new Date))},x=i?a.extend(!0,{},i.defaults,m):m||{},y=a.extend({},b.klasses(),x.klass),z=a(f),A=function(){return this.start()},B=A.prototype={constructor:A,$node:z,start:function(){return w&&w.start?B:(w.methods={},w.start=!0,w.open=!1,w.type=f.type,f.autofocus=f==h(),f.readOnly=!x.editable,f.id=f.id||w.id,\"text\"!=f.type&&(f.type=\"text\"),B.component=new i(B,x),B.$root=a('<div class=\"'+y.picker+'\" id=\"'+f.id+'_root\" />'),p(),B.$holder=a(n()).appendTo(B.$root),q(),x.formatSubmit&&r(),o(),x.containerHidden?a(x.containerHidden).append(B._hidden):z.after(B._hidden),x.container?a(x.container).append(B.$root):z.after(B.$root),B.on({start:B.component.onStart,render:B.component.onRender,stop:B.component.onStop,open:B.component.onOpen,close:B.component.onClose,set:B.component.onSet}).on({start:x.onStart,render:x.onRender,stop:x.onStop,open:x.onOpen,close:x.onClose,set:x.onSet}),v=c(B.$holder[0]),f.autofocus&&B.open(),B.trigger(\"start\").trigger(\"render\"))},render:function(b){return b?(B.$holder=a(n()),q(),B.$root.html(B.$holder)):B.$root.find(\".\"+y.box).html(B.component.nodes(w.open)),B.trigger(\"render\")},stop:function(){return w.start?(B.close(),B._hidden&&B._hidden.parentNode.removeChild(B._hidden),B.$root.remove(),z.removeClass(y.input).removeData(g),setTimeout(function(){z.off(\".\"+w.id)},0),f.type=w.type,f.readOnly=!1,B.trigger(\"stop\"),w.methods={},w.start=!1,B):B},open:function(c){return w.open?B:(z.addClass(y.active),e(f,\"expanded\",!0),setTimeout(function(){B.$root.addClass(y.opened),e(B.$root[0],\"hidden\",!1)},0),c!==!1&&(w.open=!0,v&&k.css(\"overflow\",\"hidden\").css(\"padding-right\",\"+=\"+d()),s(),j.on(\"click.\"+w.id+\" focusin.\"+w.id,function(a){var b=a.target;b!=f&&b!=document&&3!=a.which&&B.close(b===B.$holder[0])}).on(\"keydown.\"+w.id,function(c){var d=c.keyCode,e=B.component.key[d],f=c.target;27==d?B.close(!0):f!=B.$holder[0]||!e&&13!=d?a.contains(B.$root[0],f)&&13==d&&(c.preventDefault(),f.click()):(c.preventDefault(),e?b._.trigger(B.component.key.go,B,[b._.trigger(e)]):B.$root.find(\".\"+y.highlighted).hasClass(y.disabled)||(B.set(\"select\",B.component.item.highlight),x.closeOnSelect&&B.close(!0)))})),B.trigger(\"open\"))},close:function(a){return a&&(x.editable?f.focus():(B.$holder.off(\"focus.toOpen\").focus(),setTimeout(function(){B.$holder.on(\"focus.toOpen\",t)},0))),z.removeClass(y.active),e(f,\"expanded\",!1),setTimeout(function(){B.$root.removeClass(y.opened+\" \"+y.focused),e(B.$root[0],\"hidden\",!0)},0),w.open?(w.open=!1,v&&k.css(\"overflow\",\"\").css(\"padding-right\",\"-=\"+d()),j.off(\".\"+w.id),B.trigger(\"close\")):B},clear:function(a){return B.set(\"clear\",null,a)},set:function(b,c,d){var e,f,g=a.isPlainObject(b),h=g?b:{};if(d=g&&a.isPlainObject(c)?c:d||{},b){g||(h[b]=c);for(e in h)f=h[e],e in B.component.item&&(void 0===f&&(f=null),B.component.set(e,f,d)),(\"select\"==e||\"clear\"==e)&&z.val(\"clear\"==e?\"\":B.get(e,x.format)).trigger(\"change\");B.render()}return d.muted?B:B.trigger(\"set\",h)},get:function(a,c){if(a=a||\"value\",null!=w[a])return w[a];if(\"valueSubmit\"==a){if(B._hidden)return B._hidden.value;a=\"value\"}if(\"value\"==a)return f.value;if(a in B.component.item){if(\"string\"==typeof c){var d=B.component.get(a);return d?b._.trigger(B.component.formats.toString,B.component,[c,d]):\"\"}return B.component.get(a)}},on:function(b,c,d){var e,f,g=a.isPlainObject(b),h=g?b:{};if(b){g||(h[b]=c);for(e in h)f=h[e],d&&(e=\"_\"+e),w.methods[e]=w.methods[e]||[],w.methods[e].push(f)}return B},off:function(){var a,b,c=arguments;for(a=0,namesCount=c.length;a<namesCount;a+=1)b=c[a],b in w.methods&&delete w.methods[b];return B},trigger:function(a,c){var d=function(a){var d=w.methods[a];d&&d.map(function(a){b._.trigger(a,B,[c])})};return d(\"_\"+a),d(a),B}};return new A}function c(a){var b,c=\"position\";return a.currentStyle?b=a.currentStyle[c]:window.getComputedStyle&&(b=getComputedStyle(a)[c]),\"fixed\"==b}function d(){if(k.height()<=i.height())return 0;var b=a('<div style=\"visibility:hidden;width:100px\" />').appendTo(\"body\"),c=b[0].offsetWidth;b.css(\"overflow\",\"scroll\");var d=a('<div style=\"width:100%\" />').appendTo(b),e=d[0].offsetWidth;return b.remove(),c-e}function e(b,c,d){if(a.isPlainObject(c))for(var e in c)f(b,e,c[e]);else f(b,c,d)}function f(a,b,c){a.setAttribute((\"role\"==b?\"\":\"aria-\")+b,c)}function g(b,c){a.isPlainObject(b)||(b={attribute:c}),c=\"\";for(var d in b){var e=(\"role\"==d?\"\":\"aria-\")+d,f=b[d];c+=null==f?\"\":e+'=\"'+b[d]+'\"'}return c}function h(){try{return document.activeElement}catch(a){}}var i=a(window),j=a(document),k=a(document.documentElement),l=null!=document.documentElement.style.transition;return b.klasses=function(a){return a=a||\"picker\",{picker:a,opened:a+\"--opened\",focused:a+\"--focused\",input:a+\"__input\",active:a+\"__input--active\",target:a+\"__input--target\",holder:a+\"__holder\",frame:a+\"__frame\",wrap:a+\"__wrap\",box:a+\"__box\"}},b._={group:function(a){for(var c,d=\"\",e=b._.trigger(a.min,a);e<=b._.trigger(a.max,a,[e]);e+=a.i)c=b._.trigger(a.item,a,[e]),d+=b._.node(a.node,c[0],c[1],c[2]);return d},node:function(b,c,d,e){return c?(c=a.isArray(c)?c.join(\"\"):c,d=d?' class=\"'+d+'\"':\"\",e=e?\" \"+e:\"\",\"<\"+b+d+e+\">\"+c+\"</\"+b+\">\"):\"\"},lead:function(a){return(10>a?\"0\":\"\")+a},trigger:function(a,b,c){return\"function\"==typeof a?a.apply(b,c||[]):a},digits:function(a){return/\\d/.test(a[1])?2:1},isDate:function(a){return{}.toString.call(a).indexOf(\"Date\")>-1&&this.isInteger(a.getDate())},isInteger:function(a){return{}.toString.call(a).indexOf(\"Number\")>-1&&a%1===0},ariaAttr:g},b.extend=function(c,d){a.fn[c]=function(e,f){var g=this.data(c);return\"picker\"==e?g:g&&\"string\"==typeof e?b._.trigger(g[e],g,[f]):this.each(function(){var f=a(this);f.data(c)||new b(this,c,d,e)})},a.fn[c].defaults=d.defaults},b});\n/*!\n * Date picker for pickadate.js v3.5.6\n * http://amsul.github.io/pickadate.js/date.htm\n */\n!function(a){\"function\"==typeof define&&define.amd?define([\"picker\",\"jquery\"],a):\"object\"==typeof exports?module.exports=a(require(\"./picker.js\"),require(\"jquery\")):a(Picker,jQuery)}(function(a,b){function c(a,b){var c=this,d=a.$node[0],e=d.value,f=a.$node.data(\"value\"),g=f||e,h=f?b.formatSubmit:b.format,i=function(){return d.currentStyle?\"rtl\"==d.currentStyle.direction:\"rtl\"==getComputedStyle(a.$root[0]).direction};c.settings=b,c.$node=a.$node,c.queue={min:\"measure create\",max:\"measure create\",now:\"now create\",select:\"parse create validate\",highlight:\"parse navigate create validate\",view:\"parse create validate viewset\",disable:\"deactivate\",enable:\"activate\"},c.item={},c.item.clear=null,c.item.disable=(b.disable||[]).slice(0),c.item.enable=-function(a){return a[0]===!0?a.shift():-1}(c.item.disable),c.set(\"min\",b.min).set(\"max\",b.max).set(\"now\"),g?c.set(\"select\",g,{format:h,defaultValue:!0}):c.set(\"select\",null).set(\"highlight\",c.item.now),c.key={40:7,38:-7,39:function(){return i()?-1:1},37:function(){return i()?1:-1},go:function(a){var b=c.item.highlight,d=new Date(b.year,b.month,b.date+a);c.set(\"highlight\",d,{interval:a}),this.render()}},a.on(\"render\",function(){a.$root.find(\".\"+b.klass.selectMonth).on(\"change\",function(){var c=this.value;c&&(a.set(\"highlight\",[a.get(\"view\").year,c,a.get(\"highlight\").date]),a.$root.find(\".\"+b.klass.selectMonth).trigger(\"focus\"))}),a.$root.find(\".\"+b.klass.selectYear).on(\"change\",function(){var c=this.value;c&&(a.set(\"highlight\",[c,a.get(\"view\").month,a.get(\"highlight\").date]),a.$root.find(\".\"+b.klass.selectYear).trigger(\"focus\"))})},1).on(\"open\",function(){var d=\"\";c.disabled(c.get(\"now\"))&&(d=\":not(.\"+b.klass.buttonToday+\")\"),a.$root.find(\"button\"+d+\", select\").attr(\"disabled\",!1)},1).on(\"close\",function(){a.$root.find(\"button, select\").attr(\"disabled\",!0)},1)}var d=7,e=6,f=a._;c.prototype.set=function(a,b,c){var d=this,e=d.item;return null===b?(\"clear\"==a&&(a=\"select\"),e[a]=b,d):(e[\"enable\"==a?\"disable\":\"flip\"==a?\"enable\":a]=d.queue[a].split(\" \").map(function(e){return b=d[e](a,b,c)}).pop(),\"select\"==a?d.set(\"highlight\",e.select,c):\"highlight\"==a?d.set(\"view\",e.highlight,c):a.match(/^(flip|min|max|disable|enable)$/)&&(e.select&&d.disabled(e.select)&&d.set(\"select\",e.select,c),e.highlight&&d.disabled(e.highlight)&&d.set(\"highlight\",e.highlight,c)),d)},c.prototype.get=function(a){return this.item[a]},c.prototype.create=function(a,c,d){var e,g=this;return c=void 0===c?a:c,c==-(1/0)||c==1/0?e=c:b.isPlainObject(c)&&f.isInteger(c.pick)?c=c.obj:b.isArray(c)?(c=new Date(c[0],c[1],c[2]),c=f.isDate(c)?c:g.create().obj):c=f.isInteger(c)||f.isDate(c)?g.normalize(new Date(c),d):g.now(a,c,d),{year:e||c.getFullYear(),month:e||c.getMonth(),date:e||c.getDate(),day:e||c.getDay(),obj:e||c,pick:e||c.getTime()}},c.prototype.createRange=function(a,c){var d=this,e=function(a){return a===!0||b.isArray(a)||f.isDate(a)?d.create(a):a};return f.isInteger(a)||(a=e(a)),f.isInteger(c)||(c=e(c)),f.isInteger(a)&&b.isPlainObject(c)?a=[c.year,c.month,c.date+a]:f.isInteger(c)&&b.isPlainObject(a)&&(c=[a.year,a.month,a.date+c]),{from:e(a),to:e(c)}},c.prototype.withinRange=function(a,b){return a=this.createRange(a.from,a.to),b.pick>=a.from.pick&&b.pick<=a.to.pick},c.prototype.overlapRanges=function(a,b){var c=this;return a=c.createRange(a.from,a.to),b=c.createRange(b.from,b.to),c.withinRange(a,b.from)||c.withinRange(a,b.to)||c.withinRange(b,a.from)||c.withinRange(b,a.to)},c.prototype.now=function(a,b,c){return b=new Date,c&&c.rel&&b.setDate(b.getDate()+c.rel),this.normalize(b,c)},c.prototype.navigate=function(a,c,d){var e,f,g,h,i=b.isArray(c),j=b.isPlainObject(c),k=this.item.view;if(i||j){for(j?(f=c.year,g=c.month,h=c.date):(f=+c[0],g=+c[1],h=+c[2]),d&&d.nav&&k&&k.month!==g&&(f=k.year,g=k.month),e=new Date(f,g+(d&&d.nav?d.nav:0),1),f=e.getFullYear(),g=e.getMonth();new Date(f,g,h).getMonth()!==g;)h-=1;c=[f,g,h]}return c},c.prototype.normalize=function(a){return a.setHours(0,0,0,0),a},c.prototype.measure=function(a,b){var c=this;return b?\"string\"==typeof b?b=c.parse(a,b):f.isInteger(b)&&(b=c.now(a,b,{rel:b})):b=\"min\"==a?-(1/0):1/0,b},c.prototype.viewset=function(a,b){return this.create([b.year,b.month,1])},c.prototype.validate=function(a,c,d){var e,g,h,i,j=this,k=c,l=d&&d.interval?d.interval:1,m=-1===j.item.enable,n=j.item.min,o=j.item.max,p=m&&j.item.disable.filter(function(a){if(b.isArray(a)){var d=j.create(a).pick;d<c.pick?e=!0:d>c.pick&&(g=!0)}return f.isInteger(a)}).length;if((!d||!d.nav&&!d.defaultValue)&&(!m&&j.disabled(c)||m&&j.disabled(c)&&(p||e||g)||!m&&(c.pick<=n.pick||c.pick>=o.pick)))for(m&&!p&&(!g&&l>0||!e&&0>l)&&(l*=-1);j.disabled(c)&&(Math.abs(l)>1&&(c.month<k.month||c.month>k.month)&&(c=k,l=l>0?1:-1),c.pick<=n.pick?(h=!0,l=1,c=j.create([n.year,n.month,n.date+(c.pick===n.pick?0:-1)])):c.pick>=o.pick&&(i=!0,l=-1,c=j.create([o.year,o.month,o.date+(c.pick===o.pick?0:1)])),!h||!i);)c=j.create([c.year,c.month,c.date+l]);return c},c.prototype.disabled=function(a){var c=this,d=c.item.disable.filter(function(d){return f.isInteger(d)?a.day===(c.settings.firstDay?d:d-1)%7:b.isArray(d)||f.isDate(d)?a.pick===c.create(d).pick:b.isPlainObject(d)?c.withinRange(d,a):void 0});return d=d.length&&!d.filter(function(a){return b.isArray(a)&&\"inverted\"==a[3]||b.isPlainObject(a)&&a.inverted}).length,-1===c.item.enable?!d:d||a.pick<c.item.min.pick||a.pick>c.item.max.pick},c.prototype.parse=function(a,b,c){var d=this,e={};return b&&\"string\"==typeof b?(c&&c.format||(c=c||{},c.format=d.settings.format),d.formats.toArray(c.format).map(function(a){var c=d.formats[a],g=c?f.trigger(c,d,[b,e]):a.replace(/^!/,\"\").length;c&&(e[a]=b.substr(0,g)),b=b.substr(g)}),[e.yyyy||e.yy,+(e.mm||e.m)-1,e.dd||e.d]):b},c.prototype.formats=function(){function a(a,b,c){var d=a.match(/[^\\x00-\\x7F]+|\\w+/)[0];return c.mm||c.m||(c.m=b.indexOf(d)+1),d.length}function b(a){return a.match(/\\w+/)[0].length}return{d:function(a,b){return a?f.digits(a):b.date},dd:function(a,b){return a?2:f.lead(b.date)},ddd:function(a,c){return a?b(a):this.settings.weekdaysShort[c.day]},dddd:function(a,c){return a?b(a):this.settings.weekdaysFull[c.day]},m:function(a,b){return a?f.digits(a):b.month+1},mm:function(a,b){return a?2:f.lead(b.month+1)},mmm:function(b,c){var d=this.settings.monthsShort;return b?a(b,d,c):d[c.month]},mmmm:function(b,c){var d=this.settings.monthsFull;return b?a(b,d,c):d[c.month]},yy:function(a,b){return a?2:(\"\"+b.year).slice(2)},yyyy:function(a,b){return a?4:b.year},toArray:function(a){return a.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g)},toString:function(a,b){var c=this;return c.formats.toArray(a).map(function(a){return f.trigger(c.formats[a],c,[0,b])||a.replace(/^!/,\"\")}).join(\"\")}}}(),c.prototype.isDateExact=function(a,c){var d=this;return f.isInteger(a)&&f.isInteger(c)||\"boolean\"==typeof a&&\"boolean\"==typeof c?a===c:(f.isDate(a)||b.isArray(a))&&(f.isDate(c)||b.isArray(c))?d.create(a).pick===d.create(c).pick:b.isPlainObject(a)&&b.isPlainObject(c)?d.isDateExact(a.from,c.from)&&d.isDateExact(a.to,c.to):!1},c.prototype.isDateOverlap=function(a,c){var d=this,e=d.settings.firstDay?1:0;return f.isInteger(a)&&(f.isDate(c)||b.isArray(c))?(a=a%7+e,a===d.create(c).day+1):f.isInteger(c)&&(f.isDate(a)||b.isArray(a))?(c=c%7+e,c===d.create(a).day+1):b.isPlainObject(a)&&b.isPlainObject(c)?d.overlapRanges(a,c):!1},c.prototype.flipEnable=function(a){var b=this.item;b.enable=a||(-1==b.enable?1:-1)},c.prototype.deactivate=function(a,c){var d=this,e=d.item.disable.slice(0);return\"flip\"==c?d.flipEnable():c===!1?(d.flipEnable(1),e=[]):c===!0?(d.flipEnable(-1),e=[]):c.map(function(a){for(var c,g=0;g<e.length;g+=1)if(d.isDateExact(a,e[g])){c=!0;break}c||(f.isInteger(a)||f.isDate(a)||b.isArray(a)||b.isPlainObject(a)&&a.from&&a.to)&&e.push(a)}),e},c.prototype.activate=function(a,c){var d=this,e=d.item.disable,g=e.length;return\"flip\"==c?d.flipEnable():c===!0?(d.flipEnable(1),e=[]):c===!1?(d.flipEnable(-1),e=[]):c.map(function(a){var c,h,i,j;for(i=0;g>i;i+=1){if(h=e[i],d.isDateExact(h,a)){c=e[i]=null,j=!0;break}if(d.isDateOverlap(h,a)){b.isPlainObject(a)?(a.inverted=!0,c=a):b.isArray(a)?(c=a,c[3]||c.push(\"inverted\")):f.isDate(a)&&(c=[a.getFullYear(),a.getMonth(),a.getDate(),\"inverted\"]);break}}if(c)for(i=0;g>i;i+=1)if(d.isDateExact(e[i],a)){e[i]=null;break}if(j)for(i=0;g>i;i+=1)if(d.isDateOverlap(e[i],a)){e[i]=null;break}c&&e.push(c)}),e.filter(function(a){return null!=a})},c.prototype.nodes=function(a){var b=this,c=b.settings,g=b.item,h=g.now,i=g.select,j=g.highlight,k=g.view,l=g.disable,m=g.min,n=g.max,o=function(a,b){return c.firstDay&&(a.push(a.shift()),b.push(b.shift())),f.node(\"thead\",f.node(\"tr\",f.group({min:0,max:d-1,i:1,node:\"th\",item:function(d){return[a[d],c.klass.weekdays,'scope=col title=\"'+b[d]+'\"']}})))}((c.showWeekdaysFull?c.weekdaysFull:c.weekdaysShort).slice(0),c.weekdaysFull.slice(0)),p=function(a){return f.node(\"div\",\" \",c.klass[\"nav\"+(a?\"Next\":\"Prev\")]+(a&&k.year>=n.year&&k.month>=n.month||!a&&k.year<=m.year&&k.month<=m.month?\" \"+c.klass.navDisabled:\"\"),\"data-nav=\"+(a||-1)+\" \"+f.ariaAttr({role:\"button\",controls:b.$node[0].id+\"_table\"})+' title=\"'+(a?c.labelMonthNext:c.labelMonthPrev)+'\"')},q=function(){var d=c.showMonthsShort?c.monthsShort:c.monthsFull;return c.selectMonths?f.node(\"select\",f.group({min:0,max:11,i:1,node:\"option\",item:function(a){return[d[a],0,\"value=\"+a+(k.month==a?\" selected\":\"\")+(k.year==m.year&&a<m.month||k.year==n.year&&a>n.month?\" disabled\":\"\")]}}),c.klass.selectMonth,(a?\"\":\"disabled\")+\" \"+f.ariaAttr({controls:b.$node[0].id+\"_table\"})+' title=\"'+c.labelMonthSelect+'\"'):f.node(\"div\",d[k.month],c.klass.month)},r=function(){var d=k.year,e=c.selectYears===!0?5:~~(c.selectYears/2);if(e){var g=m.year,h=n.year,i=d-e,j=d+e;if(g>i&&(j+=g-i,i=g),j>h){var l=i-g,o=j-h;i-=l>o?o:l,j=h}return f.node(\"select\",f.group({min:i,max:j,i:1,node:\"option\",item:function(a){return[a,0,\"value=\"+a+(d==a?\" selected\":\"\")]}}),c.klass.selectYear,(a?\"\":\"disabled\")+\" \"+f.ariaAttr({controls:b.$node[0].id+\"_table\"})+' title=\"'+c.labelYearSelect+'\"')}return f.node(\"div\",d,c.klass.year)};return f.node(\"div\",(c.selectYears?r()+q():q()+r())+p()+p(1),c.klass.header)+f.node(\"table\",o+f.node(\"tbody\",f.group({min:0,max:e-1,i:1,node:\"tr\",item:function(a){var e=c.firstDay&&0===b.create([k.year,k.month,1]).day?-7:0;return[f.group({min:d*a-k.day+e+1,max:function(){return this.min+d-1},i:1,node:\"td\",item:function(a){a=b.create([k.year,k.month,a+(c.firstDay?1:0)]);var d=i&&i.pick==a.pick,e=j&&j.pick==a.pick,g=l&&b.disabled(a)||a.pick<m.pick||a.pick>n.pick,o=f.trigger(b.formats.toString,b,[c.format,a]);return[f.node(\"div\",a.date,function(b){return b.push(k.month==a.month?c.klass.infocus:c.klass.outfocus),h.pick==a.pick&&b.push(c.klass.now),d&&b.push(c.klass.selected),e&&b.push(c.klass.highlighted),g&&b.push(c.klass.disabled),b.join(\" \")}([c.klass.day]),\"data-pick=\"+a.pick+\" \"+f.ariaAttr({role:\"gridcell\",label:o,selected:d&&b.$node.val()===o?!0:null,activedescendant:e?!0:null,disabled:g?!0:null})),\"\",f.ariaAttr({role:\"presentation\"})]}})]}})),c.klass.table,'id=\"'+b.$node[0].id+'_table\" '+f.ariaAttr({role:\"grid\",controls:b.$node[0].id,readonly:!0}))+f.node(\"div\",f.node(\"button\",c.today,c.klass.buttonToday,\"type=button data-pick=\"+h.pick+(a&&!b.disabled(h)?\"\":\" disabled\")+\" \"+f.ariaAttr({controls:b.$node[0].id}))+f.node(\"button\",c.clear,c.klass.buttonClear,\"type=button data-clear=1\"+(a?\"\":\" disabled\")+\" \"+f.ariaAttr({controls:b.$node[0].id}))+f.node(\"button\",c.close,c.klass.buttonClose,\"type=button data-close=true \"+(a?\"\":\" disabled\")+\" \"+f.ariaAttr({controls:b.$node[0].id})),c.klass.footer)},c.defaults=function(a){return{labelMonthNext:\"Next month\",labelMonthPrev:\"Previous month\",labelMonthSelect:\"Select a month\",labelYearSelect:\"Select a year\",monthsFull:[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],monthsShort:[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],weekdaysFull:[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"],weekdaysShort:[\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"],today:\"Today\",clear:\"Clear\",close:\"Close\",closeOnSelect:!0,closeOnClear:!0,format:\"d mmmm, yyyy\",klass:{table:a+\"table\",header:a+\"header\",navPrev:a+\"nav--prev\",navNext:a+\"nav--next\",navDisabled:a+\"nav--disabled\",month:a+\"month\",year:a+\"year\",selectMonth:a+\"select--month\",selectYear:a+\"select--year\",weekdays:a+\"weekday\",day:a+\"day\",disabled:a+\"day--disabled\",selected:a+\"day--selected\",highlighted:a+\"day--highlighted\",now:a+\"day--today\",infocus:a+\"day--infocus\",outfocus:a+\"day--outfocus\",footer:a+\"footer\",buttonClear:a+\"button--clear\",buttonToday:a+\"button--today\",buttonClose:a+\"button--close\"}}}(a.klasses().picker+\"__\"),a.extend(\"pickadate\",c)});\n/*!\n * Time picker for pickadate.js v3.5.6\n * http://amsul.github.io/pickadate.js/time.htm\n */\n!function(a){\"function\"==typeof define&&define.amd?define([\"picker\",\"jquery\"],a):\"object\"==typeof exports?module.exports=a(require(\"./picker.js\"),require(\"jquery\")):a(Picker,jQuery)}(function(a,b){function c(a,b){var c=this,d=a.$node[0].value,e=a.$node.data(\"value\"),f=e||d,g=e?b.formatSubmit:b.format;c.settings=b,c.$node=a.$node,c.queue={interval:\"i\",min:\"measure create\",max:\"measure create\",now:\"now create\",select:\"parse create validate\",highlight:\"parse create validate\",view:\"parse create validate\",disable:\"deactivate\",enable:\"activate\"},c.item={},c.item.clear=null,c.item.interval=b.interval||30,c.item.disable=(b.disable||[]).slice(0),c.item.enable=-function(a){return a[0]===!0?a.shift():-1}(c.item.disable),c.set(\"min\",b.min).set(\"max\",b.max).set(\"now\"),f?c.set(\"select\",f,{format:g}):c.set(\"select\",null).set(\"highlight\",c.item.now),c.key={40:1,38:-1,39:1,37:-1,go:function(a){c.set(\"highlight\",c.item.highlight.pick+a*c.item.interval,{interval:a*c.item.interval}),this.render()}},a.on(\"render\",function(){var c=a.$root.children(),d=c.find(\".\"+b.klass.viewset),e=function(a){return[\"webkit\",\"moz\",\"ms\",\"o\",\"\"].map(function(b){return(b?\"-\"+b+\"-\":\"\")+a})},f=function(a,b){e(\"transform\").map(function(c){a.css(c,b)}),e(\"transition\").map(function(c){a.css(c,b)})};d.length&&(f(c,\"none\"),c[0].scrollTop=~~d.position().top-2*d[0].clientHeight,f(c,\"\"))},1).on(\"open\",function(){a.$root.find(\"button\").attr(\"disabled\",!1)},1).on(\"close\",function(){a.$root.find(\"button\").attr(\"disabled\",!0)},1)}var d=24,e=60,f=12,g=d*e,h=a._;c.prototype.set=function(a,b,c){var d=this,e=d.item;return null===b?(\"clear\"==a&&(a=\"select\"),e[a]=b,d):(e[\"enable\"==a?\"disable\":\"flip\"==a?\"enable\":a]=d.queue[a].split(\" \").map(function(e){return b=d[e](a,b,c)}).pop(),\"select\"==a?d.set(\"highlight\",e.select,c):\"highlight\"==a?d.set(\"view\",e.highlight,c):\"interval\"==a?d.set(\"min\",e.min,c).set(\"max\",e.max,c):a.match(/^(flip|min|max|disable|enable)$/)&&(e.select&&d.disabled(e.select)&&d.set(\"select\",b,c),e.highlight&&d.disabled(e.highlight)&&d.set(\"highlight\",b,c),\"min\"==a&&d.set(\"max\",e.max,c)),d)},c.prototype.get=function(a){return this.item[a]},c.prototype.create=function(a,c,f){var i=this;return c=void 0===c?a:c,h.isDate(c)&&(c=[c.getHours(),c.getMinutes()]),b.isPlainObject(c)&&h.isInteger(c.pick)?c=c.pick:b.isArray(c)?c=+c[0]*e+ +c[1]:h.isInteger(c)||(c=i.now(a,c,f)),\"max\"==a&&c<i.item.min.pick&&(c+=g),\"min\"!=a&&\"max\"!=a&&(c-i.item.min.pick)%i.item.interval!==0&&(c+=i.item.interval),c=i.normalize(a,c,f),{hour:~~(d+c/e)%d,mins:(e+c%e)%e,time:(g+c)%g,pick:c%g}},c.prototype.createRange=function(a,c){var d=this,e=function(a){return a===!0||b.isArray(a)||h.isDate(a)?d.create(a):a};return h.isInteger(a)||(a=e(a)),h.isInteger(c)||(c=e(c)),h.isInteger(a)&&b.isPlainObject(c)?a=[c.hour,c.mins+a*d.settings.interval]:h.isInteger(c)&&b.isPlainObject(a)&&(c=[a.hour,a.mins+c*d.settings.interval]),{from:e(a),to:e(c)}},c.prototype.withinRange=function(a,b){return a=this.createRange(a.from,a.to),b.pick>=a.from.pick&&b.pick<=a.to.pick},c.prototype.overlapRanges=function(a,b){var c=this;return a=c.createRange(a.from,a.to),b=c.createRange(b.from,b.to),c.withinRange(a,b.from)||c.withinRange(a,b.to)||c.withinRange(b,a.from)||c.withinRange(b,a.to)},c.prototype.now=function(a,b){var c,d=this.item.interval,f=new Date,g=f.getHours()*e+f.getMinutes(),i=h.isInteger(b);return g-=g%d,c=0>b&&-d>=d*b+g,g+=\"min\"==a&&c?0:d,i&&(g+=d*(c&&\"max\"!=a?b+1:b)),g},c.prototype.normalize=function(a,b){var c=this.item.interval,d=this.item.min&&this.item.min.pick||0;return b-=\"min\"==a?0:(b-d)%c},c.prototype.measure=function(a,c,f){var g=this;return c||(c=\"min\"==a?[0,0]:[d-1,e-1]),\"string\"==typeof c?c=g.parse(a,c):c===!0||h.isInteger(c)?c=g.now(a,c,f):b.isPlainObject(c)&&h.isInteger(c.pick)&&(c=g.normalize(a,c.pick,f)),c},c.prototype.validate=function(a,b,c){var d=this,e=c&&c.interval?c.interval:d.item.interval;return d.disabled(b)&&(b=d.shift(b,e)),b=d.scope(b),d.disabled(b)&&(b=d.shift(b,-1*e)),b},c.prototype.disabled=function(a){var c=this,d=c.item.disable.filter(function(d){return h.isInteger(d)?a.hour==d:b.isArray(d)||h.isDate(d)?a.pick==c.create(d).pick:b.isPlainObject(d)?c.withinRange(d,a):void 0});return d=d.length&&!d.filter(function(a){return b.isArray(a)&&\"inverted\"==a[2]||b.isPlainObject(a)&&a.inverted}).length,-1===c.item.enable?!d:d||a.pick<c.item.min.pick||a.pick>c.item.max.pick},c.prototype.shift=function(a,b){var c=this,d=c.item.min.pick,e=c.item.max.pick;for(b=b||c.item.interval;c.disabled(a)&&(a=c.create(a.pick+=b),!(a.pick<=d||a.pick>=e)););return a},c.prototype.scope=function(a){var b=this.item.min.pick,c=this.item.max.pick;return this.create(a.pick>c?c:a.pick<b?b:a)},c.prototype.parse=function(a,b,c){var d,f,g,i,j,k=this,l={};if(!b||\"string\"!=typeof b)return b;c&&c.format||(c=c||{},c.format=k.settings.format),k.formats.toArray(c.format).map(function(a){var c,d=k.formats[a],e=d?h.trigger(d,k,[b,l]):a.replace(/^!/,\"\").length;d&&(c=b.substr(0,e),l[a]=c.match(/^\\d+$/)?+c:c),b=b.substr(e)});for(i in l)j=l[i],h.isInteger(j)?i.match(/^(h|hh)$/i)?(d=j,(\"h\"==i||\"hh\"==i)&&(d%=12)):\"i\"==i&&(f=j):i.match(/^a$/i)&&j.match(/^p/i)&&(\"h\"in l||\"hh\"in l)&&(g=!0);return(g?d+12:d)*e+f},c.prototype.formats={h:function(a,b){return a?h.digits(a):b.hour%f||f},hh:function(a,b){return a?2:h.lead(b.hour%f||f)},H:function(a,b){return a?h.digits(a):\"\"+b.hour%24},HH:function(a,b){return a?h.digits(a):h.lead(b.hour%24)},i:function(a,b){return a?2:h.lead(b.mins)},a:function(a,b){return a?4:g/2>b.time%g?\"a.m.\":\"p.m.\"},A:function(a,b){return a?2:g/2>b.time%g?\"AM\":\"PM\"},toArray:function(a){return a.split(/(h{1,2}|H{1,2}|i|a|A|!.)/g)},toString:function(a,b){var c=this;return c.formats.toArray(a).map(function(a){return h.trigger(c.formats[a],c,[0,b])||a.replace(/^!/,\"\")}).join(\"\")}},c.prototype.isTimeExact=function(a,c){var d=this;return h.isInteger(a)&&h.isInteger(c)||\"boolean\"==typeof a&&\"boolean\"==typeof c?a===c:(h.isDate(a)||b.isArray(a))&&(h.isDate(c)||b.isArray(c))?d.create(a).pick===d.create(c).pick:b.isPlainObject(a)&&b.isPlainObject(c)?d.isTimeExact(a.from,c.from)&&d.isTimeExact(a.to,c.to):!1},c.prototype.isTimeOverlap=function(a,c){var d=this;return h.isInteger(a)&&(h.isDate(c)||b.isArray(c))?a===d.create(c).hour:h.isInteger(c)&&(h.isDate(a)||b.isArray(a))?c===d.create(a).hour:b.isPlainObject(a)&&b.isPlainObject(c)?d.overlapRanges(a,c):!1},c.prototype.flipEnable=function(a){var b=this.item;b.enable=a||(-1==b.enable?1:-1)},c.prototype.deactivate=function(a,c){var d=this,e=d.item.disable.slice(0);return\"flip\"==c?d.flipEnable():c===!1?(d.flipEnable(1),e=[]):c===!0?(d.flipEnable(-1),e=[]):c.map(function(a){for(var c,f=0;f<e.length;f+=1)if(d.isTimeExact(a,e[f])){c=!0;break}c||(h.isInteger(a)||h.isDate(a)||b.isArray(a)||b.isPlainObject(a)&&a.from&&a.to)&&e.push(a)}),e},c.prototype.activate=function(a,c){var d=this,e=d.item.disable,f=e.length;return\"flip\"==c?d.flipEnable():c===!0?(d.flipEnable(1),e=[]):c===!1?(d.flipEnable(-1),e=[]):c.map(function(a){var c,g,i,j;for(i=0;f>i;i+=1){if(g=e[i],d.isTimeExact(g,a)){c=e[i]=null,j=!0;break}if(d.isTimeOverlap(g,a)){b.isPlainObject(a)?(a.inverted=!0,c=a):b.isArray(a)?(c=a,c[2]||c.push(\"inverted\")):h.isDate(a)&&(c=[a.getFullYear(),a.getMonth(),a.getDate(),\"inverted\"]);break}}if(c)for(i=0;f>i;i+=1)if(d.isTimeExact(e[i],a)){e[i]=null;break}if(j)for(i=0;f>i;i+=1)if(d.isTimeOverlap(e[i],a)){e[i]=null;break}c&&e.push(c)}),e.filter(function(a){return null!=a})},c.prototype.i=function(a,b){return h.isInteger(b)&&b>0?b:this.item.interval},c.prototype.nodes=function(a){var b=this,c=b.settings,d=b.item.select,e=b.item.highlight,f=b.item.view,g=b.item.disable;return h.node(\"ul\",h.group({min:b.item.min.pick,max:b.item.max.pick,i:b.item.interval,node:\"li\",item:function(a){a=b.create(a);var i=a.pick,j=d&&d.pick==i,k=e&&e.pick==i,l=g&&b.disabled(a),m=h.trigger(b.formats.toString,b,[c.format,a]);return[h.trigger(b.formats.toString,b,[h.trigger(c.formatLabel,b,[a])||c.format,a]),function(a){return j&&a.push(c.klass.selected),k&&a.push(c.klass.highlighted),f&&f.pick==i&&a.push(c.klass.viewset),l&&a.push(c.klass.disabled),a.join(\" \")}([c.klass.listItem]),\"data-pick=\"+a.pick+\" \"+h.ariaAttr({role:\"option\",label:m,selected:j&&b.$node.val()===m?!0:null,activedescendant:k?!0:null,disabled:l?!0:null})]}})+h.node(\"li\",h.node(\"button\",c.clear,c.klass.buttonClear,\"type=button data-clear=1\"+(a?\"\":\" disabled\")+\" \"+h.ariaAttr({controls:b.$node[0].id})),\"\",h.ariaAttr({role:\"presentation\"})),c.klass.list,h.ariaAttr({role:\"listbox\",controls:b.$node[0].id}))},c.defaults=function(a){return{clear:\"Clear\",format:\"h:i A\",interval:30,closeOnSelect:!0,closeOnClear:!0,klass:{picker:a+\" \"+a+\"--time\",holder:a+\"__holder\",list:a+\"__list\",listItem:a+\"__list-item\",disabled:a+\"__list-item--disabled\",selected:a+\"__list-item--selected\",highlighted:a+\"__list-item--highlighted\",viewset:a+\"__list-item--viewset\",now:a+\"__list-item--now\",buttonClear:a+\"__button--clear\"}}}(a.klasses().picker),a.extend(\"pickatime\",c)});\n/*!\n * Legacy browser support\n */\n[].map||(Array.prototype.map=function(a,b){for(var c=this,d=c.length,e=new Array(d),f=0;d>f;f++)f in c&&(e[f]=a.call(b,c[f],f,c));return e}),[].filter||(Array.prototype.filter=function(a){if(null==this)throw new TypeError;var b=Object(this),c=b.length>>>0;if(\"function\"!=typeof a)throw new TypeError;for(var d=[],e=arguments[1],f=0;c>f;f++)if(f in b){var g=b[f];a.call(e,g,f,b)&&d.push(g)}return d}),[].indexOf||(Array.prototype.indexOf=function(a){if(null==this)throw new TypeError;var b=Object(this),c=b.length>>>0;if(0===c)return-1;var d=0;if(arguments.length>1&&(d=Number(arguments[1]),d!=d?d=0:0!==d&&d!=1/0&&d!=-(1/0)&&(d=(d>0||-1)*Math.floor(Math.abs(d)))),d>=c)return-1;for(var e=d>=0?d:Math.max(c-Math.abs(d),0);c>e;e++)if(e in b&&b[e]===a)return e;return-1});/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * http://blog.stevenlevithan.com/archives/cross-browser-split\n */\nvar nativeSplit=String.prototype.split,compliantExecNpcg=void 0===/()??/.exec(\"\")[1];String.prototype.split=function(a,b){var c=this;if(\"[object RegExp]\"!==Object.prototype.toString.call(a))return nativeSplit.call(c,a,b);var d,e,f,g,h=[],i=(a.ignoreCase?\"i\":\"\")+(a.multiline?\"m\":\"\")+(a.extended?\"x\":\"\")+(a.sticky?\"y\":\"\"),j=0;for(a=new RegExp(a.source,i+\"g\"),c+=\"\",compliantExecNpcg||(d=new RegExp(\"^\"+a.source+\"$(?!\\\\s)\",i)),b=void 0===b?-1>>>0:b>>>0;(e=a.exec(c))&&(f=e.index+e[0].length,!(f>j&&(h.push(c.slice(j,e.index)),!compliantExecNpcg&&e.length>1&&e[0].replace(d,function(){for(var a=1;a<arguments.length-2;a++)void 0===arguments[a]&&(e[a]=void 0)}),e.length>1&&e.index<c.length&&Array.prototype.push.apply(h,e.slice(1)),g=e[0].length,j=f,h.length>=b)));)a.lastIndex===e.index&&a.lastIndex++;return j===c.length?(g||!a.test(\"\"))&&h.push(\"\"):h.push(c.slice(j)),h.length>b?h.slice(0,b):h};\n//# sourceMappingURL=pickadate.js.map\n","jQuery.fn.rotate = function(angle,whence) {\n\tvar p = this.get(0);\n\n\t// we store the angle inside the image tag for persistence\n\tif (!whence) {\n\t\tp.angle = ((p.angle==undefined?0:p.angle) + angle) % 360;\n\t} else {\n\t\tp.angle = angle;\n\t}\n\n\tif (p.angle >= 0) {\n\t\tvar rotation = Math.PI * p.angle / 180;\n\t} else {\n\t\tvar rotation = Math.PI * (360+p.angle) / 180;\n\t}\n\tvar costheta = Math.cos(rotation);\n\tvar sintheta = Math.sin(rotation);\n\n\tif (document.all && !window.opera) {\n\t\tvar canvas = document.createElement('img');\n\n\t\tcanvas.src = p.src;\n\t\tcanvas.height = p.height;\n\t\tcanvas.width = p.width;\n\n\t\tcanvas.style.filter = \"progid:DXImageTransform.Microsoft.Matrix(M11=\"+costheta+\",M12=\"+(-sintheta)+\",M21=\"+sintheta+\",M22=\"+costheta+\",SizingMethod='auto expand')\";\n\t} else {\n\t\tvar canvas = document.createElement('canvas');\n\t\tif (!p.oImage) {\n\t\t\tcanvas.oImage = new Image();\n\t\t\tcanvas.oImage.src = p.src;\n\t\t} else {\n\t\t\tcanvas.oImage = p.oImage;\n\t\t}\n\n\t\tcanvas.style.width = canvas.width = Math.abs(costheta*canvas.oImage.width) + Math.abs(sintheta*canvas.oImage.height);\n\t\tcanvas.style.height = canvas.height = Math.abs(costheta*canvas.oImage.height) + Math.abs(sintheta*canvas.oImage.width);\n\n\t\tvar context = canvas.getContext('2d');\n\t\tcontext.save();\n\t\tif (rotation <= Math.PI/2) {\n\t\t\tcontext.translate(sintheta*canvas.oImage.height,0);\n\t\t} else if (rotation <= Math.PI) {\n\t\t\tcontext.translate(canvas.width,-costheta*canvas.oImage.height);\n\t\t} else if (rotation <= 1.5*Math.PI) {\n\t\t\tcontext.translate(-costheta*canvas.oImage.width,canvas.height);\n\t\t} else {\n\t\t\tcontext.translate(0,-sintheta*canvas.oImage.width);\n\t\t}\n\t\tcontext.rotate(rotation);\n\t\tcontext.drawImage(canvas.oImage, 0, 0, canvas.oImage.width, canvas.oImage.height);\n\t\tcontext.restore();\n\t}\n\tcanvas.id = p.id;\n\tcanvas.angle = p.angle;\n\tp.parentNode.replaceChild(canvas, p);\n}\n\njQuery.fn.rotateRight = function(angle) {\n\tthis.rotate(angle==undefined?90:angle);\n}\n\njQuery.fn.rotateLeft = function(angle) {\n\tthis.rotate(angle==undefined?-90:-angle);\n}\n","/**\n * Rangy, a cross-browser JavaScript range and selection library\n * https://github.com/timdown/rangy\n *\n * Copyright 2015, Tim Down\n * Licensed under the MIT license.\n * Version: 1.3.1-dev\n * Build date: 20 May 2015\n */\n\n;(function(factory, root) {\n    if (typeof define == \"function\" && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(factory);\n    } else if (typeof module != \"undefined\" && typeof exports == \"object\") {\n        // Node/CommonJS style\n        module.exports = factory();\n    } else {\n        // No AMD or CommonJS support so we place Rangy in (probably) the global variable\n        root.rangy = factory();\n    }\n})(function() {\n\n    var OBJECT = \"object\", FUNCTION = \"function\", UNDEFINED = \"undefined\";\n\n    // Minimal set of properties required for DOM Level 2 Range compliance. Comparison constants such as START_TO_START\n    // are omitted because ranges in KHTML do not have them but otherwise work perfectly well. See issue 113.\n    var domRangeProperties = [\"startContainer\", \"startOffset\", \"endContainer\", \"endOffset\", \"collapsed\",\n        \"commonAncestorContainer\"];\n\n    // Minimal set of methods required for DOM Level 2 Range compliance\n    var domRangeMethods = [\"setStart\", \"setStartBefore\", \"setStartAfter\", \"setEnd\", \"setEndBefore\",\n        \"setEndAfter\", \"collapse\", \"selectNode\", \"selectNodeContents\", \"compareBoundaryPoints\", \"deleteContents\",\n        \"extractContents\", \"cloneContents\", \"insertNode\", \"surroundContents\", \"cloneRange\", \"toString\", \"detach\"];\n\n    var textRangeProperties = [\"boundingHeight\", \"boundingLeft\", \"boundingTop\", \"boundingWidth\", \"htmlText\", \"text\"];\n\n    // Subset of TextRange's full set of methods that we're interested in\n    var textRangeMethods = [\"collapse\", \"compareEndPoints\", \"duplicate\", \"moveToElementText\", \"parentElement\", \"select\",\n        \"setEndPoint\", \"getBoundingClientRect\"];\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Trio of functions taken from Peter Michaux's article:\n    // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting\n    function isHostMethod(o, p) {\n        var t = typeof o[p];\n        return t == FUNCTION || (!!(t == OBJECT && o[p])) || t == \"unknown\";\n    }\n\n    function isHostObject(o, p) {\n        return !!(typeof o[p] == OBJECT && o[p]);\n    }\n\n    function isHostProperty(o, p) {\n        return typeof o[p] != UNDEFINED;\n    }\n\n    // Creates a convenience function to save verbose repeated calls to tests functions\n    function createMultiplePropertyTest(testFunc) {\n        return function(o, props) {\n            var i = props.length;\n            while (i--) {\n                if (!testFunc(o, props[i])) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    }\n\n    // Next trio of functions are a convenience to save verbose repeated calls to previous two functions\n    var areHostMethods = createMultiplePropertyTest(isHostMethod);\n    var areHostObjects = createMultiplePropertyTest(isHostObject);\n    var areHostProperties = createMultiplePropertyTest(isHostProperty);\n\n    function isTextRange(range) {\n        return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);\n    }\n\n    function getBody(doc) {\n        return isHostObject(doc, \"body\") ? doc.body : doc.getElementsByTagName(\"body\")[0];\n    }\n\n    var forEach = [].forEach ?\n        function(arr, func) {\n            arr.forEach(func);\n        } :\n        function(arr, func) {\n            for (var i = 0, len = arr.length; i < len; ++i) {\n                func(arr[i], i);\n            }\n        };\n\n    var modules = {};\n\n    var isBrowser = (typeof window != UNDEFINED && typeof document != UNDEFINED);\n\n    var util = {\n        isHostMethod: isHostMethod,\n        isHostObject: isHostObject,\n        isHostProperty: isHostProperty,\n        areHostMethods: areHostMethods,\n        areHostObjects: areHostObjects,\n        areHostProperties: areHostProperties,\n        isTextRange: isTextRange,\n        getBody: getBody,\n        forEach: forEach\n    };\n\n    var api = {\n        version: \"1.3.1-dev\",\n        initialized: false,\n        isBrowser: isBrowser,\n        supported: true,\n        util: util,\n        features: {},\n        modules: modules,\n        config: {\n            alertOnFail: false,\n            alertOnWarn: false,\n            preferTextRange: false,\n            autoInitialize: (typeof rangyAutoInitialize == UNDEFINED) ? true : rangyAutoInitialize\n        }\n    };\n\n    function consoleLog(msg) {\n        if (typeof console != UNDEFINED && isHostMethod(console, \"log\")) {\n            console.log(msg);\n        }\n    }\n\n    function alertOrLog(msg, shouldAlert) {\n        if (isBrowser && shouldAlert) {\n            alert(msg);\n        } else  {\n            consoleLog(msg);\n        }\n    }\n\n    function fail(reason) {\n        api.initialized = true;\n        api.supported = false;\n        alertOrLog(\"Rangy is not supported in this environment. Reason: \" + reason, api.config.alertOnFail);\n    }\n\n    api.fail = fail;\n\n    function warn(msg) {\n        alertOrLog(\"Rangy warning: \" + msg, api.config.alertOnWarn);\n    }\n\n    api.warn = warn;\n\n    // Add utility extend() method\n    var extend;\n    if ({}.hasOwnProperty) {\n        util.extend = extend = function(obj, props, deep) {\n            var o, p;\n            for (var i in props) {\n                if (props.hasOwnProperty(i)) {\n                    o = obj[i];\n                    p = props[i];\n                    if (deep && o !== null && typeof o == \"object\" && p !== null && typeof p == \"object\") {\n                        extend(o, p, true);\n                    }\n                    obj[i] = p;\n                }\n            }\n            // Special case for toString, which does not show up in for...in loops in IE <= 8\n            if (props.hasOwnProperty(\"toString\")) {\n                obj.toString = props.toString;\n            }\n            return obj;\n        };\n\n        util.createOptions = function(optionsParam, defaults) {\n            var options = {};\n            extend(options, defaults);\n            if (optionsParam) {\n                extend(options, optionsParam);\n            }\n            return options;\n        };\n    } else {\n        fail(\"hasOwnProperty not supported\");\n    }\n\n    // Test whether we're in a browser and bail out if not\n    if (!isBrowser) {\n        fail(\"Rangy can only run in a browser\");\n    }\n\n    // Test whether Array.prototype.slice can be relied on for NodeLists and use an alternative toArray() if not\n    (function() {\n        var toArray;\n\n        if (isBrowser) {\n            var el = document.createElement(\"div\");\n            el.appendChild(document.createElement(\"span\"));\n            var slice = [].slice;\n            try {\n                if (slice.call(el.childNodes, 0)[0].nodeType == 1) {\n                    toArray = function(arrayLike) {\n                        return slice.call(arrayLike, 0);\n                    };\n                }\n            } catch (e) {}\n        }\n\n        if (!toArray) {\n            toArray = function(arrayLike) {\n                var arr = [];\n                for (var i = 0, len = arrayLike.length; i < len; ++i) {\n                    arr[i] = arrayLike[i];\n                }\n                return arr;\n            };\n        }\n\n        util.toArray = toArray;\n    })();\n\n    // Very simple event handler wrapper function that doesn't attempt to solve issues such as \"this\" handling or\n    // normalization of event properties\n    var addListener;\n    if (isBrowser) {\n        if (isHostMethod(document, \"addEventListener\")) {\n            addListener = function(obj, eventType, listener) {\n                obj.addEventListener(eventType, listener, false);\n            };\n        } else if (isHostMethod(document, \"attachEvent\")) {\n            addListener = function(obj, eventType, listener) {\n                obj.attachEvent(\"on\" + eventType, listener);\n            };\n        } else {\n            fail(\"Document does not have required addEventListener or attachEvent method\");\n        }\n\n        util.addListener = addListener;\n    }\n\n    var initListeners = [];\n\n    function getErrorDesc(ex) {\n        return ex.message || ex.description || String(ex);\n    }\n\n    // Initialization\n    function init() {\n        if (!isBrowser || api.initialized) {\n            return;\n        }\n        var testRange;\n        var implementsDomRange = false, implementsTextRange = false;\n\n        // First, perform basic feature tests\n\n        if (isHostMethod(document, \"createRange\")) {\n            testRange = document.createRange();\n            if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {\n                implementsDomRange = true;\n            }\n        }\n\n        var body = getBody(document);\n        if (!body || body.nodeName.toLowerCase() != \"body\") {\n            fail(\"No body element found\");\n            return;\n        }\n\n        if (body && isHostMethod(body, \"createTextRange\")) {\n            testRange = body.createTextRange();\n            if (isTextRange(testRange)) {\n                implementsTextRange = true;\n            }\n        }\n\n        if (!implementsDomRange && !implementsTextRange) {\n            fail(\"Neither Range nor TextRange are available\");\n            return;\n        }\n\n        api.initialized = true;\n        api.features = {\n            implementsDomRange: implementsDomRange,\n            implementsTextRange: implementsTextRange\n        };\n\n        // Initialize modules\n        var module, errorMessage;\n        for (var moduleName in modules) {\n            if ( (module = modules[moduleName]) instanceof Module ) {\n                module.init(module, api);\n            }\n        }\n\n        // Call init listeners\n        for (var i = 0, len = initListeners.length; i < len; ++i) {\n            try {\n                initListeners[i](api);\n            } catch (ex) {\n                errorMessage = \"Rangy init listener threw an exception. Continuing. Detail: \" + getErrorDesc(ex);\n                consoleLog(errorMessage);\n            }\n        }\n    }\n\n    function deprecationNotice(deprecated, replacement, module) {\n        if (module) {\n            deprecated += \" in module \" + module.name;\n        }\n        api.warn(\"DEPRECATED: \" + deprecated + \" is deprecated. Please use \" +\n        replacement + \" instead.\");\n    }\n\n    function createAliasForDeprecatedMethod(owner, deprecated, replacement, module) {\n        owner[deprecated] = function() {\n            deprecationNotice(deprecated, replacement, module);\n            return owner[replacement].apply(owner, util.toArray(arguments));\n        };\n    }\n\n    util.deprecationNotice = deprecationNotice;\n    util.createAliasForDeprecatedMethod = createAliasForDeprecatedMethod;\n\n    // Allow external scripts to initialize this library in case it's loaded after the document has loaded\n    api.init = init;\n\n    // Execute listener immediately if already initialized\n    api.addInitListener = function(listener) {\n        if (api.initialized) {\n            listener(api);\n        } else {\n            initListeners.push(listener);\n        }\n    };\n\n    var shimListeners = [];\n\n    api.addShimListener = function(listener) {\n        shimListeners.push(listener);\n    };\n\n    function shim(win) {\n        win = win || window;\n        init();\n\n        // Notify listeners\n        for (var i = 0, len = shimListeners.length; i < len; ++i) {\n            shimListeners[i](win);\n        }\n    }\n\n    if (isBrowser) {\n        api.shim = api.createMissingNativeApi = shim;\n        createAliasForDeprecatedMethod(api, \"createMissingNativeApi\", \"shim\");\n    }\n\n    function Module(name, dependencies, initializer) {\n        this.name = name;\n        this.dependencies = dependencies;\n        this.initialized = false;\n        this.supported = false;\n        this.initializer = initializer;\n    }\n\n    Module.prototype = {\n        init: function() {\n            var requiredModuleNames = this.dependencies || [];\n            for (var i = 0, len = requiredModuleNames.length, requiredModule, moduleName; i < len; ++i) {\n                moduleName = requiredModuleNames[i];\n\n                requiredModule = modules[moduleName];\n                if (!requiredModule || !(requiredModule instanceof Module)) {\n                    throw new Error(\"required module '\" + moduleName + \"' not found\");\n                }\n\n                requiredModule.init();\n\n                if (!requiredModule.supported) {\n                    throw new Error(\"required module '\" + moduleName + \"' not supported\");\n                }\n            }\n\n            // Now run initializer\n            this.initializer(this);\n        },\n\n        fail: function(reason) {\n            this.initialized = true;\n            this.supported = false;\n            throw new Error(reason);\n        },\n\n        warn: function(msg) {\n            api.warn(\"Module \" + this.name + \": \" + msg);\n        },\n\n        deprecationNotice: function(deprecated, replacement) {\n            api.warn(\"DEPRECATED: \" + deprecated + \" in module \" + this.name + \" is deprecated. Please use \" +\n                replacement + \" instead\");\n        },\n\n        createError: function(msg) {\n            return new Error(\"Error in Rangy \" + this.name + \" module: \" + msg);\n        }\n    };\n\n    function createModule(name, dependencies, initFunc) {\n        var newModule = new Module(name, dependencies, function(module) {\n            if (!module.initialized) {\n                module.initialized = true;\n                try {\n                    initFunc(api, module);\n                    module.supported = true;\n                } catch (ex) {\n                    var errorMessage = \"Module '\" + name + \"' failed to load: \" + getErrorDesc(ex);\n                    consoleLog(errorMessage);\n                    if (ex.stack) {\n                        consoleLog(ex.stack);\n                    }\n                }\n            }\n        });\n        modules[name] = newModule;\n        return newModule;\n    }\n\n    api.createModule = function(name) {\n        // Allow 2 or 3 arguments (second argument is an optional array of dependencies)\n        var initFunc, dependencies;\n        if (arguments.length == 2) {\n            initFunc = arguments[1];\n            dependencies = [];\n        } else {\n            initFunc = arguments[2];\n            dependencies = arguments[1];\n        }\n\n        var module = createModule(name, dependencies, initFunc);\n\n        // Initialize the module immediately if the core is already initialized\n        if (api.initialized && api.supported) {\n            module.init();\n        }\n    };\n\n    api.createCoreModule = function(name, dependencies, initFunc) {\n        createModule(name, dependencies, initFunc);\n    };\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Ensure rangy.rangePrototype and rangy.selectionPrototype are available immediately\n\n    function RangePrototype() {}\n    api.RangePrototype = RangePrototype;\n    api.rangePrototype = new RangePrototype();\n\n    function SelectionPrototype() {}\n    api.selectionPrototype = new SelectionPrototype();\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // DOM utility methods used by Rangy\n    api.createCoreModule(\"DomUtil\", [], function(api, module) {\n        var UNDEF = \"undefined\";\n        var util = api.util;\n        var getBody = util.getBody;\n\n        // Perform feature tests\n        if (!util.areHostMethods(document, [\"createDocumentFragment\", \"createElement\", \"createTextNode\"])) {\n            module.fail(\"document missing a Node creation method\");\n        }\n\n        if (!util.isHostMethod(document, \"getElementsByTagName\")) {\n            module.fail(\"document missing getElementsByTagName method\");\n        }\n\n        var el = document.createElement(\"div\");\n        if (!util.areHostMethods(el, [\"insertBefore\", \"appendChild\", \"cloneNode\"] ||\n                !util.areHostObjects(el, [\"previousSibling\", \"nextSibling\", \"childNodes\", \"parentNode\"]))) {\n            module.fail(\"Incomplete Element implementation\");\n        }\n\n        // innerHTML is required for Range's createContextualFragment method\n        if (!util.isHostProperty(el, \"innerHTML\")) {\n            module.fail(\"Element is missing innerHTML property\");\n        }\n\n        var textNode = document.createTextNode(\"test\");\n        if (!util.areHostMethods(textNode, [\"splitText\", \"deleteData\", \"insertData\", \"appendData\", \"cloneNode\"] ||\n                !util.areHostObjects(el, [\"previousSibling\", \"nextSibling\", \"childNodes\", \"parentNode\"]) ||\n                !util.areHostProperties(textNode, [\"data\"]))) {\n            module.fail(\"Incomplete Text Node implementation\");\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven't been\n        // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that\n        // contains just the document as a single element and the value searched for is the document.\n        var arrayContains = /*Array.prototype.indexOf ?\n            function(arr, val) {\n                return arr.indexOf(val) > -1;\n            }:*/\n\n            function(arr, val) {\n                var i = arr.length;\n                while (i--) {\n                    if (arr[i] === val) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n\n        // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI\n        function isHtmlNamespace(node) {\n            var ns;\n            return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == \"http://www.w3.org/1999/xhtml\");\n        }\n\n        function parentElement(node) {\n            var parent = node.parentNode;\n            return (parent.nodeType == 1) ? parent : null;\n        }\n\n        function getNodeIndex(node) {\n            var i = 0;\n            while( (node = node.previousSibling) ) {\n                ++i;\n            }\n            return i;\n        }\n\n        function getNodeLength(node) {\n            switch (node.nodeType) {\n                case 7:\n                case 10:\n                    return 0;\n                case 3:\n                case 8:\n                    return node.length;\n                default:\n                    return node.childNodes.length;\n            }\n        }\n\n        function getCommonAncestor(node1, node2) {\n            var ancestors = [], n;\n            for (n = node1; n; n = n.parentNode) {\n                ancestors.push(n);\n            }\n\n            for (n = node2; n; n = n.parentNode) {\n                if (arrayContains(ancestors, n)) {\n                    return n;\n                }\n            }\n\n            return null;\n        }\n\n        function isAncestorOf(ancestor, descendant, selfIsAncestor) {\n            var n = selfIsAncestor ? descendant : descendant.parentNode;\n            while (n) {\n                if (n === ancestor) {\n                    return true;\n                } else {\n                    n = n.parentNode;\n                }\n            }\n            return false;\n        }\n\n        function isOrIsAncestorOf(ancestor, descendant) {\n            return isAncestorOf(ancestor, descendant, true);\n        }\n\n        function getClosestAncestorIn(node, ancestor, selfIsAncestor) {\n            var p, n = selfIsAncestor ? node : node.parentNode;\n            while (n) {\n                p = n.parentNode;\n                if (p === ancestor) {\n                    return n;\n                }\n                n = p;\n            }\n            return null;\n        }\n\n        function isCharacterDataNode(node) {\n            var t = node.nodeType;\n            return t == 3 || t == 4 || t == 8 ; // Text, CDataSection or Comment\n        }\n\n        function isTextOrCommentNode(node) {\n            if (!node) {\n                return false;\n            }\n            var t = node.nodeType;\n            return t == 3 || t == 8 ; // Text or Comment\n        }\n\n        function insertAfter(node, precedingNode) {\n            var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;\n            if (nextNode) {\n                parent.insertBefore(node, nextNode);\n            } else {\n                parent.appendChild(node);\n            }\n            return node;\n        }\n\n        // Note that we cannot use splitText() because it is bugridden in IE 9.\n        function splitDataNode(node, index, positionsToPreserve) {\n            var newNode = node.cloneNode(false);\n            newNode.deleteData(0, index);\n            node.deleteData(index, node.length - index);\n            insertAfter(newNode, node);\n\n            // Preserve positions\n            if (positionsToPreserve) {\n                for (var i = 0, position; position = positionsToPreserve[i++]; ) {\n                    // Handle case where position was inside the portion of node after the split point\n                    if (position.node == node && position.offset > index) {\n                        position.node = newNode;\n                        position.offset -= index;\n                    }\n                    // Handle the case where the position is a node offset within node's parent\n                    else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {\n                        ++position.offset;\n                    }\n                }\n            }\n            return newNode;\n        }\n\n        function getDocument(node) {\n            if (node.nodeType == 9) {\n                return node;\n            } else if (typeof node.ownerDocument != UNDEF) {\n                return node.ownerDocument;\n            } else if (typeof node.document != UNDEF) {\n                return node.document;\n            } else if (node.parentNode) {\n                return getDocument(node.parentNode);\n            } else {\n                throw module.createError(\"getDocument: no document found for node\");\n            }\n        }\n\n        function getWindow(node) {\n            var doc = getDocument(node);\n            if (typeof doc.defaultView != UNDEF) {\n                return doc.defaultView;\n            } else if (typeof doc.parentWindow != UNDEF) {\n                return doc.parentWindow;\n            } else {\n                throw module.createError(\"Cannot get a window object for node\");\n            }\n        }\n\n        function getIframeDocument(iframeEl) {\n            if (typeof iframeEl.contentDocument != UNDEF) {\n                return iframeEl.contentDocument;\n            } else if (typeof iframeEl.contentWindow != UNDEF) {\n                return iframeEl.contentWindow.document;\n            } else {\n                throw module.createError(\"getIframeDocument: No Document object found for iframe element\");\n            }\n        }\n\n        function getIframeWindow(iframeEl) {\n            if (typeof iframeEl.contentWindow != UNDEF) {\n                return iframeEl.contentWindow;\n            } else if (typeof iframeEl.contentDocument != UNDEF) {\n                return iframeEl.contentDocument.defaultView;\n            } else {\n                throw module.createError(\"getIframeWindow: No Window object found for iframe element\");\n            }\n        }\n\n        // This looks bad. Is it worth it?\n        function isWindow(obj) {\n            return obj && util.isHostMethod(obj, \"setTimeout\") && util.isHostObject(obj, \"document\");\n        }\n\n        function getContentDocument(obj, module, methodName) {\n            var doc;\n\n            if (!obj) {\n                doc = document;\n            }\n\n            // Test if a DOM node has been passed and obtain a document object for it if so\n            else if (util.isHostProperty(obj, \"nodeType\")) {\n                doc = (obj.nodeType == 1 && obj.tagName.toLowerCase() == \"iframe\") ?\n                    getIframeDocument(obj) : getDocument(obj);\n            }\n\n            // Test if the doc parameter appears to be a Window object\n            else if (isWindow(obj)) {\n                doc = obj.document;\n            }\n\n            if (!doc) {\n                throw module.createError(methodName + \"(): Parameter must be a Window object or DOM node\");\n            }\n\n            return doc;\n        }\n\n        function getRootContainer(node) {\n            var parent;\n            while ( (parent = node.parentNode) ) {\n                node = parent;\n            }\n            return node;\n        }\n\n        function comparePoints(nodeA, offsetA, nodeB, offsetB) {\n            // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing\n            var nodeC, root, childA, childB, n;\n            if (nodeA == nodeB) {\n                // Case 1: nodes are the same\n                return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;\n            } else if ( (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) ) {\n                // Case 2: node C (container B or an ancestor) is a child node of A\n                return offsetA <= getNodeIndex(nodeC) ? -1 : 1;\n            } else if ( (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) ) {\n                // Case 3: node C (container A or an ancestor) is a child node of B\n                return getNodeIndex(nodeC) < offsetB  ? -1 : 1;\n            } else {\n                root = getCommonAncestor(nodeA, nodeB);\n                if (!root) {\n                    throw new Error(\"comparePoints error: nodes have no common ancestor\");\n                }\n\n                // Case 4: containers are siblings or descendants of siblings\n                childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);\n                childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);\n\n                if (childA === childB) {\n                    // This shouldn't be possible\n                    throw module.createError(\"comparePoints got to case 4 and childA and childB are the same!\");\n                } else {\n                    n = root.firstChild;\n                    while (n) {\n                        if (n === childA) {\n                            return -1;\n                        } else if (n === childB) {\n                            return 1;\n                        }\n                        n = n.nextSibling;\n                    }\n                }\n            }\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Test for IE's crash (IE 6/7) or exception (IE >= 8) when a reference to garbage-collected text node is queried\n        var crashyTextNodes = false;\n\n        function isBrokenNode(node) {\n            var n;\n            try {\n                n = node.parentNode;\n                return false;\n            } catch (e) {\n                return true;\n            }\n        }\n\n        (function() {\n            var el = document.createElement(\"b\");\n            el.innerHTML = \"1\";\n            var textNode = el.firstChild;\n            el.innerHTML = \"<br />\";\n            crashyTextNodes = isBrokenNode(textNode);\n\n            api.features.crashyTextNodes = crashyTextNodes;\n        })();\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        function inspectNode(node) {\n            if (!node) {\n                return \"[No node]\";\n            }\n            if (crashyTextNodes && isBrokenNode(node)) {\n                return \"[Broken node]\";\n            }\n            if (isCharacterDataNode(node)) {\n                return '\"' + node.data + '\"';\n            }\n            if (node.nodeType == 1) {\n                var idAttr = node.id ? ' id=\"' + node.id + '\"' : \"\";\n                return \"<\" + node.nodeName + idAttr + \">[index:\" + getNodeIndex(node) + \",length:\" + node.childNodes.length + \"][\" + (node.innerHTML || \"[innerHTML not supported]\").slice(0, 25) + \"]\";\n            }\n            return node.nodeName;\n        }\n\n        function fragmentFromNodeChildren(node) {\n            var fragment = getDocument(node).createDocumentFragment(), child;\n            while ( (child = node.firstChild) ) {\n                fragment.appendChild(child);\n            }\n            return fragment;\n        }\n\n        var getComputedStyleProperty;\n        if (typeof window.getComputedStyle != UNDEF) {\n            getComputedStyleProperty = function(el, propName) {\n                return getWindow(el).getComputedStyle(el, null)[propName];\n            };\n        } else if (typeof document.documentElement.currentStyle != UNDEF) {\n            getComputedStyleProperty = function(el, propName) {\n                return el.currentStyle ? el.currentStyle[propName] : \"\";\n            };\n        } else {\n            module.fail(\"No means of obtaining computed style properties found\");\n        }\n\n        function createTestElement(doc, html, contentEditable) {\n            var body = getBody(doc);\n            var el = doc.createElement(\"div\");\n            el.contentEditable = \"\" + !!contentEditable;\n            if (html) {\n                el.innerHTML = html;\n            }\n\n            // Insert the test element at the start of the body to prevent scrolling to the bottom in iOS (issue #292)\n            var bodyFirstChild = body.firstChild;\n            if (bodyFirstChild) {\n                body.insertBefore(el, bodyFirstChild);\n            } else {\n                body.appendChild(el);\n            }\n\n            return el;\n        }\n\n        function removeNode(node) {\n            return node.parentNode.removeChild(node);\n        }\n\n        function NodeIterator(root) {\n            this.root = root;\n            this._next = root;\n        }\n\n        NodeIterator.prototype = {\n            _current: null,\n\n            hasNext: function() {\n                return !!this._next;\n            },\n\n            next: function() {\n                var n = this._current = this._next;\n                var child, next;\n                if (this._current) {\n                    child = n.firstChild;\n                    if (child) {\n                        this._next = child;\n                    } else {\n                        next = null;\n                        while ((n !== this.root) && !(next = n.nextSibling)) {\n                            n = n.parentNode;\n                        }\n                        this._next = next;\n                    }\n                }\n                return this._current;\n            },\n\n            detach: function() {\n                this._current = this._next = this.root = null;\n            }\n        };\n\n        function createIterator(root) {\n            return new NodeIterator(root);\n        }\n\n        function DomPosition(node, offset) {\n            this.node = node;\n            this.offset = offset;\n        }\n\n        DomPosition.prototype = {\n            equals: function(pos) {\n                return !!pos && this.node === pos.node && this.offset == pos.offset;\n            },\n\n            inspect: function() {\n                return \"[DomPosition(\" + inspectNode(this.node) + \":\" + this.offset + \")]\";\n            },\n\n            toString: function() {\n                return this.inspect();\n            }\n        };\n\n        function DOMException(codeName) {\n            this.code = this[codeName];\n            this.codeName = codeName;\n            this.message = \"DOMException: \" + this.codeName;\n        }\n\n        DOMException.prototype = {\n            INDEX_SIZE_ERR: 1,\n            HIERARCHY_REQUEST_ERR: 3,\n            WRONG_DOCUMENT_ERR: 4,\n            NO_MODIFICATION_ALLOWED_ERR: 7,\n            NOT_FOUND_ERR: 8,\n            NOT_SUPPORTED_ERR: 9,\n            INVALID_STATE_ERR: 11,\n            INVALID_NODE_TYPE_ERR: 24\n        };\n\n        DOMException.prototype.toString = function() {\n            return this.message;\n        };\n\n        api.dom = {\n            arrayContains: arrayContains,\n            isHtmlNamespace: isHtmlNamespace,\n            parentElement: parentElement,\n            getNodeIndex: getNodeIndex,\n            getNodeLength: getNodeLength,\n            getCommonAncestor: getCommonAncestor,\n            isAncestorOf: isAncestorOf,\n            isOrIsAncestorOf: isOrIsAncestorOf,\n            getClosestAncestorIn: getClosestAncestorIn,\n            isCharacterDataNode: isCharacterDataNode,\n            isTextOrCommentNode: isTextOrCommentNode,\n            insertAfter: insertAfter,\n            splitDataNode: splitDataNode,\n            getDocument: getDocument,\n            getWindow: getWindow,\n            getIframeWindow: getIframeWindow,\n            getIframeDocument: getIframeDocument,\n            getBody: getBody,\n            isWindow: isWindow,\n            getContentDocument: getContentDocument,\n            getRootContainer: getRootContainer,\n            comparePoints: comparePoints,\n            isBrokenNode: isBrokenNode,\n            inspectNode: inspectNode,\n            getComputedStyleProperty: getComputedStyleProperty,\n            createTestElement: createTestElement,\n            removeNode: removeNode,\n            fragmentFromNodeChildren: fragmentFromNodeChildren,\n            createIterator: createIterator,\n            DomPosition: DomPosition\n        };\n\n        api.DOMException = DOMException;\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Pure JavaScript implementation of DOM Range\n    api.createCoreModule(\"DomRange\", [\"DomUtil\"], function(api, module) {\n        var dom = api.dom;\n        var util = api.util;\n        var DomPosition = dom.DomPosition;\n        var DOMException = api.DOMException;\n\n        var isCharacterDataNode = dom.isCharacterDataNode;\n        var getNodeIndex = dom.getNodeIndex;\n        var isOrIsAncestorOf = dom.isOrIsAncestorOf;\n        var getDocument = dom.getDocument;\n        var comparePoints = dom.comparePoints;\n        var splitDataNode = dom.splitDataNode;\n        var getClosestAncestorIn = dom.getClosestAncestorIn;\n        var getNodeLength = dom.getNodeLength;\n        var arrayContains = dom.arrayContains;\n        var getRootContainer = dom.getRootContainer;\n        var crashyTextNodes = api.features.crashyTextNodes;\n\n        var removeNode = dom.removeNode;\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Utility functions\n\n        function isNonTextPartiallySelected(node, range) {\n            return (node.nodeType != 3) &&\n                   (isOrIsAncestorOf(node, range.startContainer) || isOrIsAncestorOf(node, range.endContainer));\n        }\n\n        function getRangeDocument(range) {\n            return range.document || getDocument(range.startContainer);\n        }\n\n        function getRangeRoot(range) {\n            return getRootContainer(range.startContainer);\n        }\n\n        function getBoundaryBeforeNode(node) {\n            return new DomPosition(node.parentNode, getNodeIndex(node));\n        }\n\n        function getBoundaryAfterNode(node) {\n            return new DomPosition(node.parentNode, getNodeIndex(node) + 1);\n        }\n\n        function insertNodeAtPosition(node, n, o) {\n            var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;\n            if (isCharacterDataNode(n)) {\n                if (o == n.length) {\n                    dom.insertAfter(node, n);\n                } else {\n                    n.parentNode.insertBefore(node, o == 0 ? n : splitDataNode(n, o));\n                }\n            } else if (o >= n.childNodes.length) {\n                n.appendChild(node);\n            } else {\n                n.insertBefore(node, n.childNodes[o]);\n            }\n            return firstNodeInserted;\n        }\n\n        function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {\n            assertRangeValid(rangeA);\n            assertRangeValid(rangeB);\n\n            if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {\n                throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n            }\n\n            var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset),\n                endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);\n\n            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n        }\n\n        function cloneSubtree(iterator) {\n            var partiallySelected;\n            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {\n                partiallySelected = iterator.isPartiallySelectedSubtree();\n                node = node.cloneNode(!partiallySelected);\n                if (partiallySelected) {\n                    subIterator = iterator.getSubtreeIterator();\n                    node.appendChild(cloneSubtree(subIterator));\n                    subIterator.detach();\n                }\n\n                if (node.nodeType == 10) { // DocumentType\n                    throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n                }\n                frag.appendChild(node);\n            }\n            return frag;\n        }\n\n        function iterateSubtree(rangeIterator, func, iteratorState) {\n            var it, n;\n            iteratorState = iteratorState || { stop: false };\n            for (var node, subRangeIterator; node = rangeIterator.next(); ) {\n                if (rangeIterator.isPartiallySelectedSubtree()) {\n                    if (func(node) === false) {\n                        iteratorState.stop = true;\n                        return;\n                    } else {\n                        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of\n                        // the node selected by the Range.\n                        subRangeIterator = rangeIterator.getSubtreeIterator();\n                        iterateSubtree(subRangeIterator, func, iteratorState);\n                        subRangeIterator.detach();\n                        if (iteratorState.stop) {\n                            return;\n                        }\n                    }\n                } else {\n                    // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its\n                    // descendants\n                    it = dom.createIterator(node);\n                    while ( (n = it.next()) ) {\n                        if (func(n) === false) {\n                            iteratorState.stop = true;\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n\n        function deleteSubtree(iterator) {\n            var subIterator;\n            while (iterator.next()) {\n                if (iterator.isPartiallySelectedSubtree()) {\n                    subIterator = iterator.getSubtreeIterator();\n                    deleteSubtree(subIterator);\n                    subIterator.detach();\n                } else {\n                    iterator.remove();\n                }\n            }\n        }\n\n        function extractSubtree(iterator) {\n            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {\n\n                if (iterator.isPartiallySelectedSubtree()) {\n                    node = node.cloneNode(false);\n                    subIterator = iterator.getSubtreeIterator();\n                    node.appendChild(extractSubtree(subIterator));\n                    subIterator.detach();\n                } else {\n                    iterator.remove();\n                }\n                if (node.nodeType == 10) { // DocumentType\n                    throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n                }\n                frag.appendChild(node);\n            }\n            return frag;\n        }\n\n        function getNodesInRange(range, nodeTypes, filter) {\n            var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;\n            var filterExists = !!filter;\n            if (filterNodeTypes) {\n                regex = new RegExp(\"^(\" + nodeTypes.join(\"|\") + \")$\");\n            }\n\n            var nodes = [];\n            iterateSubtree(new RangeIterator(range, false), function(node) {\n                if (filterNodeTypes && !regex.test(node.nodeType)) {\n                    return;\n                }\n                if (filterExists && !filter(node)) {\n                    return;\n                }\n                // Don't include a boundary container if it is a character data node and the range does not contain any\n                // of its character data. See issue 190.\n                var sc = range.startContainer;\n                if (node == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {\n                    return;\n                }\n\n                var ec = range.endContainer;\n                if (node == ec && isCharacterDataNode(ec) && range.endOffset == 0) {\n                    return;\n                }\n\n                nodes.push(node);\n            });\n            return nodes;\n        }\n\n        function inspect(range) {\n            var name = (typeof range.getName == \"undefined\") ? \"Range\" : range.getName();\n            return \"[\" + name + \"(\" + dom.inspectNode(range.startContainer) + \":\" + range.startOffset + \", \" +\n                    dom.inspectNode(range.endContainer) + \":\" + range.endOffset + \")]\";\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)\n\n        function RangeIterator(range, clonePartiallySelectedTextNodes) {\n            this.range = range;\n            this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n\n            if (!range.collapsed) {\n                this.sc = range.startContainer;\n                this.so = range.startOffset;\n                this.ec = range.endContainer;\n                this.eo = range.endOffset;\n                var root = range.commonAncestorContainer;\n\n                if (this.sc === this.ec && isCharacterDataNode(this.sc)) {\n                    this.isSingleCharacterDataNode = true;\n                    this._first = this._last = this._next = this.sc;\n                } else {\n                    this._first = this._next = (this.sc === root && !isCharacterDataNode(this.sc)) ?\n                        this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);\n                    this._last = (this.ec === root && !isCharacterDataNode(this.ec)) ?\n                        this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);\n                }\n            }\n        }\n\n        RangeIterator.prototype = {\n            _current: null,\n            _next: null,\n            _first: null,\n            _last: null,\n            isSingleCharacterDataNode: false,\n\n            reset: function() {\n                this._current = null;\n                this._next = this._first;\n            },\n\n            hasNext: function() {\n                return !!this._next;\n            },\n\n            next: function() {\n                // Move to next node\n                var current = this._current = this._next;\n                if (current) {\n                    this._next = (current !== this._last) ? current.nextSibling : null;\n\n                    // Check for partially selected text nodes\n                    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n                        if (current === this.ec) {\n                            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n                        }\n                        if (this._current === this.sc) {\n                            (current = current.cloneNode(true)).deleteData(0, this.so);\n                        }\n                    }\n                }\n\n                return current;\n            },\n\n            remove: function() {\n                var current = this._current, start, end;\n\n                if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {\n                    start = (current === this.sc) ? this.so : 0;\n                    end = (current === this.ec) ? this.eo : current.length;\n                    if (start != end) {\n                        current.deleteData(start, end - start);\n                    }\n                } else {\n                    if (current.parentNode) {\n                        removeNode(current);\n                    } else {\n                    }\n                }\n            },\n\n            // Checks if the current node is partially selected\n            isPartiallySelectedSubtree: function() {\n                var current = this._current;\n                return isNonTextPartiallySelected(current, this.range);\n            },\n\n            getSubtreeIterator: function() {\n                var subRange;\n                if (this.isSingleCharacterDataNode) {\n                    subRange = this.range.cloneRange();\n                    subRange.collapse(false);\n                } else {\n                    subRange = new Range(getRangeDocument(this.range));\n                    var current = this._current;\n                    var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);\n\n                    if (isOrIsAncestorOf(current, this.sc)) {\n                        startContainer = this.sc;\n                        startOffset = this.so;\n                    }\n                    if (isOrIsAncestorOf(current, this.ec)) {\n                        endContainer = this.ec;\n                        endOffset = this.eo;\n                    }\n\n                    updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);\n                }\n                return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);\n            },\n\n            detach: function() {\n                this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;\n            }\n        };\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];\n        var rootContainerNodeTypes = [2, 9, 11];\n        var readonlyNodeTypes = [5, 6, 10, 12];\n        var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];\n        var surroundNodeTypes = [1, 3, 4, 5, 7, 8];\n\n        function createAncestorFinder(nodeTypes) {\n            return function(node, selfIsAncestor) {\n                var t, n = selfIsAncestor ? node : node.parentNode;\n                while (n) {\n                    t = n.nodeType;\n                    if (arrayContains(nodeTypes, t)) {\n                        return n;\n                    }\n                    n = n.parentNode;\n                }\n                return null;\n            };\n        }\n\n        var getDocumentOrFragmentContainer = createAncestorFinder( [9, 11] );\n        var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);\n        var getDocTypeNotationEntityAncestor = createAncestorFinder( [6, 10, 12] );\n\n        function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {\n            if (getDocTypeNotationEntityAncestor(node, allowSelf)) {\n                throw new DOMException(\"INVALID_NODE_TYPE_ERR\");\n            }\n        }\n\n        function assertValidNodeType(node, invalidTypes) {\n            if (!arrayContains(invalidTypes, node.nodeType)) {\n                throw new DOMException(\"INVALID_NODE_TYPE_ERR\");\n            }\n        }\n\n        function assertValidOffset(node, offset) {\n            if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {\n                throw new DOMException(\"INDEX_SIZE_ERR\");\n            }\n        }\n\n        function assertSameDocumentOrFragment(node1, node2) {\n            if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {\n                throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n            }\n        }\n\n        function assertNodeNotReadOnly(node) {\n            if (getReadonlyAncestor(node, true)) {\n                throw new DOMException(\"NO_MODIFICATION_ALLOWED_ERR\");\n            }\n        }\n\n        function assertNode(node, codeName) {\n            if (!node) {\n                throw new DOMException(codeName);\n            }\n        }\n\n        function isValidOffset(node, offset) {\n            return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);\n        }\n\n        function isRangeValid(range) {\n            return (!!range.startContainer && !!range.endContainer &&\n                    !(crashyTextNodes && (dom.isBrokenNode(range.startContainer) || dom.isBrokenNode(range.endContainer))) &&\n                    getRootContainer(range.startContainer) == getRootContainer(range.endContainer) &&\n                    isValidOffset(range.startContainer, range.startOffset) &&\n                    isValidOffset(range.endContainer, range.endOffset));\n        }\n\n        function assertRangeValid(range) {\n            if (!isRangeValid(range)) {\n                throw new Error(\"Range error: Range is not valid. This usually happens after DOM mutation. Range: (\" + range.inspect() + \")\");\n            }\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Test the browser's innerHTML support to decide how to implement createContextualFragment\n        var styleEl = document.createElement(\"style\");\n        var htmlParsingConforms = false;\n        try {\n            styleEl.innerHTML = \"<b>x</b>\";\n            htmlParsingConforms = (styleEl.firstChild.nodeType == 3); // Opera incorrectly creates an element node\n        } catch (e) {\n            // IE 6 and 7 throw\n        }\n\n        api.features.htmlParsingConforms = htmlParsingConforms;\n\n        var createContextualFragment = htmlParsingConforms ?\n\n            // Implementation as per HTML parsing spec, trusting in the browser's implementation of innerHTML. See\n            // discussion and base code for this implementation at issue 67.\n            // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface\n            // Thanks to Aleks Williams.\n            function(fragmentStr) {\n                // \"Let node the context object's start's node.\"\n                var node = this.startContainer;\n                var doc = getDocument(node);\n\n                // \"If the context object's start's node is null, raise an INVALID_STATE_ERR\n                // exception and abort these steps.\"\n                if (!node) {\n                    throw new DOMException(\"INVALID_STATE_ERR\");\n                }\n\n                // \"Let element be as follows, depending on node's interface:\"\n                // Document, Document Fragment: null\n                var el = null;\n\n                // \"Element: node\"\n                if (node.nodeType == 1) {\n                    el = node;\n\n                // \"Text, Comment: node's parentElement\"\n                } else if (isCharacterDataNode(node)) {\n                    el = dom.parentElement(node);\n                }\n\n                // \"If either element is null or element's ownerDocument is an HTML document\n                // and element's local name is \"html\" and element's namespace is the HTML\n                // namespace\"\n                if (el === null || (\n                    el.nodeName == \"HTML\" &&\n                    dom.isHtmlNamespace(getDocument(el).documentElement) &&\n                    dom.isHtmlNamespace(el)\n                )) {\n\n                // \"let element be a new Element with \"body\" as its local name and the HTML\n                // namespace as its namespace.\"\"\n                    el = doc.createElement(\"body\");\n                } else {\n                    el = el.cloneNode(false);\n                }\n\n                // \"If the node's document is an HTML document: Invoke the HTML fragment parsing algorithm.\"\n                // \"If the node's document is an XML document: Invoke the XML fragment parsing algorithm.\"\n                // \"In either case, the algorithm must be invoked with fragment as the input\n                // and element as the context element.\"\n                el.innerHTML = fragmentStr;\n\n                // \"If this raises an exception, then abort these steps. Otherwise, let new\n                // children be the nodes returned.\"\n\n                // \"Let fragment be a new DocumentFragment.\"\n                // \"Append all new children to fragment.\"\n                // \"Return fragment.\"\n                return dom.fragmentFromNodeChildren(el);\n            } :\n\n            // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that\n            // previous versions of Rangy used (with the exception of using a body element rather than a div)\n            function(fragmentStr) {\n                var doc = getRangeDocument(this);\n                var el = doc.createElement(\"body\");\n                el.innerHTML = fragmentStr;\n\n                return dom.fragmentFromNodeChildren(el);\n            };\n\n        function splitRangeBoundaries(range, positionsToPreserve) {\n            assertRangeValid(range);\n\n            var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;\n            var startEndSame = (sc === ec);\n\n            if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n                splitDataNode(ec, eo, positionsToPreserve);\n            }\n\n            if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n                sc = splitDataNode(sc, so, positionsToPreserve);\n                if (startEndSame) {\n                    eo -= so;\n                    ec = sc;\n                } else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {\n                    eo++;\n                }\n                so = 0;\n            }\n            range.setStartAndEnd(sc, so, ec, eo);\n        }\n\n        function rangeToHtml(range) {\n            assertRangeValid(range);\n            var container = range.commonAncestorContainer.parentNode.cloneNode(false);\n            container.appendChild( range.cloneContents() );\n            return container.innerHTML;\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        var rangeProperties = [\"startContainer\", \"startOffset\", \"endContainer\", \"endOffset\", \"collapsed\",\n            \"commonAncestorContainer\"];\n\n        var s2s = 0, s2e = 1, e2e = 2, e2s = 3;\n        var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;\n\n        util.extend(api.rangePrototype, {\n            compareBoundaryPoints: function(how, range) {\n                assertRangeValid(this);\n                assertSameDocumentOrFragment(this.startContainer, range.startContainer);\n\n                var nodeA, offsetA, nodeB, offsetB;\n                var prefixA = (how == e2s || how == s2s) ? \"start\" : \"end\";\n                var prefixB = (how == s2e || how == s2s) ? \"start\" : \"end\";\n                nodeA = this[prefixA + \"Container\"];\n                offsetA = this[prefixA + \"Offset\"];\n                nodeB = range[prefixB + \"Container\"];\n                offsetB = range[prefixB + \"Offset\"];\n                return comparePoints(nodeA, offsetA, nodeB, offsetB);\n            },\n\n            insertNode: function(node) {\n                assertRangeValid(this);\n                assertValidNodeType(node, insertableNodeTypes);\n                assertNodeNotReadOnly(this.startContainer);\n\n                if (isOrIsAncestorOf(node, this.startContainer)) {\n                    throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n                }\n\n                // No check for whether the container of the start of the Range is of a type that does not allow\n                // children of the type of node: the browser's DOM implementation should do this for us when we attempt\n                // to add the node\n\n                var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);\n                this.setStartBefore(firstNodeInserted);\n            },\n\n            cloneContents: function() {\n                assertRangeValid(this);\n\n                var clone, frag;\n                if (this.collapsed) {\n                    return getRangeDocument(this).createDocumentFragment();\n                } else {\n                    if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {\n                        clone = this.startContainer.cloneNode(true);\n                        clone.data = clone.data.slice(this.startOffset, this.endOffset);\n                        frag = getRangeDocument(this).createDocumentFragment();\n                        frag.appendChild(clone);\n                        return frag;\n                    } else {\n                        var iterator = new RangeIterator(this, true);\n                        clone = cloneSubtree(iterator);\n                        iterator.detach();\n                    }\n                    return clone;\n                }\n            },\n\n            canSurroundContents: function() {\n                assertRangeValid(this);\n                assertNodeNotReadOnly(this.startContainer);\n                assertNodeNotReadOnly(this.endContainer);\n\n                // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n                // no non-text nodes.\n                var iterator = new RangeIterator(this, true);\n                var boundariesInvalid = (iterator._first && (isNonTextPartiallySelected(iterator._first, this)) ||\n                        (iterator._last && isNonTextPartiallySelected(iterator._last, this)));\n                iterator.detach();\n                return !boundariesInvalid;\n            },\n\n            surroundContents: function(node) {\n                assertValidNodeType(node, surroundNodeTypes);\n\n                if (!this.canSurroundContents()) {\n                    throw new DOMException(\"INVALID_STATE_ERR\");\n                }\n\n                // Extract the contents\n                var content = this.extractContents();\n\n                // Clear the children of the node\n                if (node.hasChildNodes()) {\n                    while (node.lastChild) {\n                        node.removeChild(node.lastChild);\n                    }\n                }\n\n                // Insert the new node and add the extracted contents\n                insertNodeAtPosition(node, this.startContainer, this.startOffset);\n                node.appendChild(content);\n\n                this.selectNode(node);\n            },\n\n            cloneRange: function() {\n                assertRangeValid(this);\n                var range = new Range(getRangeDocument(this));\n                var i = rangeProperties.length, prop;\n                while (i--) {\n                    prop = rangeProperties[i];\n                    range[prop] = this[prop];\n                }\n                return range;\n            },\n\n            toString: function() {\n                assertRangeValid(this);\n                var sc = this.startContainer;\n                if (sc === this.endContainer && isCharacterDataNode(sc)) {\n                    return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : \"\";\n                } else {\n                    var textParts = [], iterator = new RangeIterator(this, true);\n                    iterateSubtree(iterator, function(node) {\n                        // Accept only text or CDATA nodes, not comments\n                        if (node.nodeType == 3 || node.nodeType == 4) {\n                            textParts.push(node.data);\n                        }\n                    });\n                    iterator.detach();\n                    return textParts.join(\"\");\n                }\n            },\n\n            // The methods below are all non-standard. The following batch were introduced by Mozilla but have since\n            // been removed from Mozilla.\n\n            compareNode: function(node) {\n                assertRangeValid(this);\n\n                var parent = node.parentNode;\n                var nodeIndex = getNodeIndex(node);\n\n                if (!parent) {\n                    throw new DOMException(\"NOT_FOUND_ERR\");\n                }\n\n                var startComparison = this.comparePoint(parent, nodeIndex),\n                    endComparison = this.comparePoint(parent, nodeIndex + 1);\n\n                if (startComparison < 0) { // Node starts before\n                    return (endComparison > 0) ? n_b_a : n_b;\n                } else {\n                    return (endComparison > 0) ? n_a : n_i;\n                }\n            },\n\n            comparePoint: function(node, offset) {\n                assertRangeValid(this);\n                assertNode(node, \"HIERARCHY_REQUEST_ERR\");\n                assertSameDocumentOrFragment(node, this.startContainer);\n\n                if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {\n                    return -1;\n                } else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {\n                    return 1;\n                }\n                return 0;\n            },\n\n            createContextualFragment: createContextualFragment,\n\n            toHtml: function() {\n                return rangeToHtml(this);\n            },\n\n            // touchingIsIntersecting determines whether this method considers a node that borders a range intersects\n            // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)\n            intersectsNode: function(node, touchingIsIntersecting) {\n                assertRangeValid(this);\n                if (getRootContainer(node) != getRangeRoot(this)) {\n                    return false;\n                }\n\n                var parent = node.parentNode, offset = getNodeIndex(node);\n                if (!parent) {\n                    return true;\n                }\n\n                var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset),\n                    endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);\n\n                return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n            },\n\n            isPointInRange: function(node, offset) {\n                assertRangeValid(this);\n                assertNode(node, \"HIERARCHY_REQUEST_ERR\");\n                assertSameDocumentOrFragment(node, this.startContainer);\n\n                return (comparePoints(node, offset, this.startContainer, this.startOffset) >= 0) &&\n                       (comparePoints(node, offset, this.endContainer, this.endOffset) <= 0);\n            },\n\n            // The methods below are non-standard and invented by me.\n\n            // Sharing a boundary start-to-end or end-to-start does not count as intersection.\n            intersectsRange: function(range) {\n                return rangesIntersect(this, range, false);\n            },\n\n            // Sharing a boundary start-to-end or end-to-start does count as intersection.\n            intersectsOrTouchesRange: function(range) {\n                return rangesIntersect(this, range, true);\n            },\n\n            intersection: function(range) {\n                if (this.intersectsRange(range)) {\n                    var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),\n                        endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);\n\n                    var intersectionRange = this.cloneRange();\n                    if (startComparison == -1) {\n                        intersectionRange.setStart(range.startContainer, range.startOffset);\n                    }\n                    if (endComparison == 1) {\n                        intersectionRange.setEnd(range.endContainer, range.endOffset);\n                    }\n                    return intersectionRange;\n                }\n                return null;\n            },\n\n            union: function(range) {\n                if (this.intersectsOrTouchesRange(range)) {\n                    var unionRange = this.cloneRange();\n                    if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {\n                        unionRange.setStart(range.startContainer, range.startOffset);\n                    }\n                    if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {\n                        unionRange.setEnd(range.endContainer, range.endOffset);\n                    }\n                    return unionRange;\n                } else {\n                    throw new DOMException(\"Ranges do not intersect\");\n                }\n            },\n\n            containsNode: function(node, allowPartial) {\n                if (allowPartial) {\n                    return this.intersectsNode(node, false);\n                } else {\n                    return this.compareNode(node) == n_i;\n                }\n            },\n\n            containsNodeContents: function(node) {\n                return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;\n            },\n\n            containsRange: function(range) {\n                var intersection = this.intersection(range);\n                return intersection !== null && range.equals(intersection);\n            },\n\n            containsNodeText: function(node) {\n                var nodeRange = this.cloneRange();\n                nodeRange.selectNode(node);\n                var textNodes = nodeRange.getNodes([3]);\n                if (textNodes.length > 0) {\n                    nodeRange.setStart(textNodes[0], 0);\n                    var lastTextNode = textNodes.pop();\n                    nodeRange.setEnd(lastTextNode, lastTextNode.length);\n                    return this.containsRange(nodeRange);\n                } else {\n                    return this.containsNodeContents(node);\n                }\n            },\n\n            getNodes: function(nodeTypes, filter) {\n                assertRangeValid(this);\n                return getNodesInRange(this, nodeTypes, filter);\n            },\n\n            getDocument: function() {\n                return getRangeDocument(this);\n            },\n\n            collapseBefore: function(node) {\n                this.setEndBefore(node);\n                this.collapse(false);\n            },\n\n            collapseAfter: function(node) {\n                this.setStartAfter(node);\n                this.collapse(true);\n            },\n\n            getBookmark: function(containerNode) {\n                var doc = getRangeDocument(this);\n                var preSelectionRange = api.createRange(doc);\n                containerNode = containerNode || dom.getBody(doc);\n                preSelectionRange.selectNodeContents(containerNode);\n                var range = this.intersection(preSelectionRange);\n                var start = 0, end = 0;\n                if (range) {\n                    preSelectionRange.setEnd(range.startContainer, range.startOffset);\n                    start = preSelectionRange.toString().length;\n                    end = start + range.toString().length;\n                }\n\n                return {\n                    start: start,\n                    end: end,\n                    containerNode: containerNode\n                };\n            },\n\n            moveToBookmark: function(bookmark) {\n                var containerNode = bookmark.containerNode;\n                var charIndex = 0;\n                this.setStart(containerNode, 0);\n                this.collapse(true);\n                var nodeStack = [containerNode], node, foundStart = false, stop = false;\n                var nextCharIndex, i, childNodes;\n\n                while (!stop && (node = nodeStack.pop())) {\n                    if (node.nodeType == 3) {\n                        nextCharIndex = charIndex + node.length;\n                        if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {\n                            this.setStart(node, bookmark.start - charIndex);\n                            foundStart = true;\n                        }\n                        if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {\n                            this.setEnd(node, bookmark.end - charIndex);\n                            stop = true;\n                        }\n                        charIndex = nextCharIndex;\n                    } else {\n                        childNodes = node.childNodes;\n                        i = childNodes.length;\n                        while (i--) {\n                            nodeStack.push(childNodes[i]);\n                        }\n                    }\n                }\n            },\n\n            getName: function() {\n                return \"DomRange\";\n            },\n\n            equals: function(range) {\n                return Range.rangesEqual(this, range);\n            },\n\n            isValid: function() {\n                return isRangeValid(this);\n            },\n\n            inspect: function() {\n                return inspect(this);\n            },\n\n            detach: function() {\n                // In DOM4, detach() is now a no-op.\n            }\n        });\n\n        function copyComparisonConstantsToObject(obj) {\n            obj.START_TO_START = s2s;\n            obj.START_TO_END = s2e;\n            obj.END_TO_END = e2e;\n            obj.END_TO_START = e2s;\n\n            obj.NODE_BEFORE = n_b;\n            obj.NODE_AFTER = n_a;\n            obj.NODE_BEFORE_AND_AFTER = n_b_a;\n            obj.NODE_INSIDE = n_i;\n        }\n\n        function copyComparisonConstants(constructor) {\n            copyComparisonConstantsToObject(constructor);\n            copyComparisonConstantsToObject(constructor.prototype);\n        }\n\n        function createRangeContentRemover(remover, boundaryUpdater) {\n            return function() {\n                assertRangeValid(this);\n\n                var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;\n\n                var iterator = new RangeIterator(this, true);\n\n                // Work out where to position the range after content removal\n                var node, boundary;\n                if (sc !== root) {\n                    node = getClosestAncestorIn(sc, root, true);\n                    boundary = getBoundaryAfterNode(node);\n                    sc = boundary.node;\n                    so = boundary.offset;\n                }\n\n                // Check none of the range is read-only\n                iterateSubtree(iterator, assertNodeNotReadOnly);\n\n                iterator.reset();\n\n                // Remove the content\n                var returnValue = remover(iterator);\n                iterator.detach();\n\n                // Move to the new position\n                boundaryUpdater(this, sc, so, sc, so);\n\n                return returnValue;\n            };\n        }\n\n        function createPrototypeRange(constructor, boundaryUpdater) {\n            function createBeforeAfterNodeSetter(isBefore, isStart) {\n                return function(node) {\n                    assertValidNodeType(node, beforeAfterNodeTypes);\n                    assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);\n\n                    var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);\n                    (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);\n                };\n            }\n\n            function setRangeStart(range, node, offset) {\n                var ec = range.endContainer, eo = range.endOffset;\n                if (node !== range.startContainer || offset !== range.startOffset) {\n                    // Check the root containers of the range and the new boundary, and also check whether the new boundary\n                    // is after the current end. In either case, collapse the range to the new position\n                    if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {\n                        ec = node;\n                        eo = offset;\n                    }\n                    boundaryUpdater(range, node, offset, ec, eo);\n                }\n            }\n\n            function setRangeEnd(range, node, offset) {\n                var sc = range.startContainer, so = range.startOffset;\n                if (node !== range.endContainer || offset !== range.endOffset) {\n                    // Check the root containers of the range and the new boundary, and also check whether the new boundary\n                    // is after the current end. In either case, collapse the range to the new position\n                    if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {\n                        sc = node;\n                        so = offset;\n                    }\n                    boundaryUpdater(range, sc, so, node, offset);\n                }\n            }\n\n            // Set up inheritance\n            var F = function() {};\n            F.prototype = api.rangePrototype;\n            constructor.prototype = new F();\n\n            util.extend(constructor.prototype, {\n                setStart: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n\n                    setRangeStart(this, node, offset);\n                },\n\n                setEnd: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n\n                    setRangeEnd(this, node, offset);\n                },\n\n                /**\n                 * Convenience method to set a range's start and end boundaries. Overloaded as follows:\n                 * - Two parameters (node, offset) creates a collapsed range at that position\n                 * - Three parameters (node, startOffset, endOffset) creates a range contained with node starting at\n                 *   startOffset and ending at endOffset\n                 * - Four parameters (startNode, startOffset, endNode, endOffset) creates a range starting at startOffset in\n                 *   startNode and ending at endOffset in endNode\n                 */\n                setStartAndEnd: function() {\n                    var args = arguments;\n                    var sc = args[0], so = args[1], ec = sc, eo = so;\n\n                    switch (args.length) {\n                        case 3:\n                            eo = args[2];\n                            break;\n                        case 4:\n                            ec = args[2];\n                            eo = args[3];\n                            break;\n                    }\n\n                    boundaryUpdater(this, sc, so, ec, eo);\n                },\n\n                setBoundary: function(node, offset, isStart) {\n                    this[\"set\" + (isStart ? \"Start\" : \"End\")](node, offset);\n                },\n\n                setStartBefore: createBeforeAfterNodeSetter(true, true),\n                setStartAfter: createBeforeAfterNodeSetter(false, true),\n                setEndBefore: createBeforeAfterNodeSetter(true, false),\n                setEndAfter: createBeforeAfterNodeSetter(false, false),\n\n                collapse: function(isStart) {\n                    assertRangeValid(this);\n                    if (isStart) {\n                        boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);\n                    } else {\n                        boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);\n                    }\n                },\n\n                selectNodeContents: function(node) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n\n                    boundaryUpdater(this, node, 0, node, getNodeLength(node));\n                },\n\n                selectNode: function(node) {\n                    assertNoDocTypeNotationEntityAncestor(node, false);\n                    assertValidNodeType(node, beforeAfterNodeTypes);\n\n                    var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);\n                    boundaryUpdater(this, start.node, start.offset, end.node, end.offset);\n                },\n\n                extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),\n\n                deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),\n\n                canSurroundContents: function() {\n                    assertRangeValid(this);\n                    assertNodeNotReadOnly(this.startContainer);\n                    assertNodeNotReadOnly(this.endContainer);\n\n                    // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n                    // no non-text nodes.\n                    var iterator = new RangeIterator(this, true);\n                    var boundariesInvalid = (iterator._first && isNonTextPartiallySelected(iterator._first, this) ||\n                            (iterator._last && isNonTextPartiallySelected(iterator._last, this)));\n                    iterator.detach();\n                    return !boundariesInvalid;\n                },\n\n                splitBoundaries: function() {\n                    splitRangeBoundaries(this);\n                },\n\n                splitBoundariesPreservingPositions: function(positionsToPreserve) {\n                    splitRangeBoundaries(this, positionsToPreserve);\n                },\n\n                normalizeBoundaries: function() {\n                    assertRangeValid(this);\n\n                    var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;\n\n                    var mergeForward = function(node) {\n                        var sibling = node.nextSibling;\n                        if (sibling && sibling.nodeType == node.nodeType) {\n                            ec = node;\n                            eo = node.length;\n                            node.appendData(sibling.data);\n                            removeNode(sibling);\n                        }\n                    };\n\n                    var mergeBackward = function(node) {\n                        var sibling = node.previousSibling;\n                        if (sibling && sibling.nodeType == node.nodeType) {\n                            sc = node;\n                            var nodeLength = node.length;\n                            so = sibling.length;\n                            node.insertData(0, sibling.data);\n                            removeNode(sibling);\n                            if (sc == ec) {\n                                eo += so;\n                                ec = sc;\n                            } else if (ec == node.parentNode) {\n                                var nodeIndex = getNodeIndex(node);\n                                if (eo == nodeIndex) {\n                                    ec = node;\n                                    eo = nodeLength;\n                                } else if (eo > nodeIndex) {\n                                    eo--;\n                                }\n                            }\n                        }\n                    };\n\n                    var normalizeStart = true;\n                    var sibling;\n\n                    if (isCharacterDataNode(ec)) {\n                        if (eo == ec.length) {\n                            mergeForward(ec);\n                        } else if (eo == 0) {\n                            sibling = ec.previousSibling;\n                            if (sibling && sibling.nodeType == ec.nodeType) {\n                                eo = sibling.length;\n                                if (sc == ec) {\n                                    normalizeStart = false;\n                                }\n                                sibling.appendData(ec.data);\n                                removeNode(ec);\n                                ec = sibling;\n                            }\n                        }\n                    } else {\n                        if (eo > 0) {\n                            var endNode = ec.childNodes[eo - 1];\n                            if (endNode && isCharacterDataNode(endNode)) {\n                                mergeForward(endNode);\n                            }\n                        }\n                        normalizeStart = !this.collapsed;\n                    }\n\n                    if (normalizeStart) {\n                        if (isCharacterDataNode(sc)) {\n                            if (so == 0) {\n                                mergeBackward(sc);\n                            } else if (so == sc.length) {\n                                sibling = sc.nextSibling;\n                                if (sibling && sibling.nodeType == sc.nodeType) {\n                                    if (ec == sibling) {\n                                        ec = sc;\n                                        eo += sc.length;\n                                    }\n                                    sc.appendData(sibling.data);\n                                    removeNode(sibling);\n                                }\n                            }\n                        } else {\n                            if (so < sc.childNodes.length) {\n                                var startNode = sc.childNodes[so];\n                                if (startNode && isCharacterDataNode(startNode)) {\n                                    mergeBackward(startNode);\n                                }\n                            }\n                        }\n                    } else {\n                        sc = ec;\n                        so = eo;\n                    }\n\n                    boundaryUpdater(this, sc, so, ec, eo);\n                },\n\n                collapseToPoint: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n                    this.setStartAndEnd(node, offset);\n                }\n            });\n\n            copyComparisonConstants(constructor);\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Updates commonAncestorContainer and collapsed after boundary change\n        function updateCollapsedAndCommonAncestor(range) {\n            range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n            range.commonAncestorContainer = range.collapsed ?\n                range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);\n        }\n\n        function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {\n            range.startContainer = startContainer;\n            range.startOffset = startOffset;\n            range.endContainer = endContainer;\n            range.endOffset = endOffset;\n            range.document = dom.getDocument(startContainer);\n\n            updateCollapsedAndCommonAncestor(range);\n        }\n\n        function Range(doc) {\n            this.startContainer = doc;\n            this.startOffset = 0;\n            this.endContainer = doc;\n            this.endOffset = 0;\n            this.document = doc;\n            updateCollapsedAndCommonAncestor(this);\n        }\n\n        createPrototypeRange(Range, updateBoundaries);\n\n        util.extend(Range, {\n            rangeProperties: rangeProperties,\n            RangeIterator: RangeIterator,\n            copyComparisonConstants: copyComparisonConstants,\n            createPrototypeRange: createPrototypeRange,\n            inspect: inspect,\n            toHtml: rangeToHtml,\n            getRangeDocument: getRangeDocument,\n            rangesEqual: function(r1, r2) {\n                return r1.startContainer === r2.startContainer &&\n                    r1.startOffset === r2.startOffset &&\n                    r1.endContainer === r2.endContainer &&\n                    r1.endOffset === r2.endOffset;\n            }\n        });\n\n        api.DomRange = Range;\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Wrappers for the browser's native DOM Range and/or TextRange implementation\n    api.createCoreModule(\"WrappedRange\", [\"DomRange\"], function(api, module) {\n        var WrappedRange, WrappedTextRange;\n        var dom = api.dom;\n        var util = api.util;\n        var DomPosition = dom.DomPosition;\n        var DomRange = api.DomRange;\n        var getBody = dom.getBody;\n        var getContentDocument = dom.getContentDocument;\n        var isCharacterDataNode = dom.isCharacterDataNode;\n\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        if (api.features.implementsDomRange) {\n            // This is a wrapper around the browser's native DOM Range. It has two aims:\n            // - Provide workarounds for specific browser bugs\n            // - provide convenient extensions, which are inherited from Rangy's DomRange\n\n            (function() {\n                var rangeProto;\n                var rangeProperties = DomRange.rangeProperties;\n\n                function updateRangeProperties(range) {\n                    var i = rangeProperties.length, prop;\n                    while (i--) {\n                        prop = rangeProperties[i];\n                        range[prop] = range.nativeRange[prop];\n                    }\n                    // Fix for broken collapsed property in IE 9.\n                    range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n                }\n\n                function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {\n                    var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);\n                    var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);\n                    var nativeRangeDifferent = !range.equals(range.nativeRange);\n\n                    // Always set both boundaries for the benefit of IE9 (see issue 35)\n                    if (startMoved || endMoved || nativeRangeDifferent) {\n                        range.setEnd(endContainer, endOffset);\n                        range.setStart(startContainer, startOffset);\n                    }\n                }\n\n                var createBeforeAfterNodeSetter;\n\n                WrappedRange = function(range) {\n                    if (!range) {\n                        throw module.createError(\"WrappedRange: Range must be specified\");\n                    }\n                    this.nativeRange = range;\n                    updateRangeProperties(this);\n                };\n\n                DomRange.createPrototypeRange(WrappedRange, updateNativeRange);\n\n                rangeProto = WrappedRange.prototype;\n\n                rangeProto.selectNode = function(node) {\n                    this.nativeRange.selectNode(node);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.cloneContents = function() {\n                    return this.nativeRange.cloneContents();\n                };\n\n                // Due to a long-standing Firefox bug that I have not been able to find a reliable way to detect,\n                // insertNode() is never delegated to the native range.\n\n                rangeProto.surroundContents = function(node) {\n                    this.nativeRange.surroundContents(node);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.collapse = function(isStart) {\n                    this.nativeRange.collapse(isStart);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.cloneRange = function() {\n                    return new WrappedRange(this.nativeRange.cloneRange());\n                };\n\n                rangeProto.refresh = function() {\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.toString = function() {\n                    return this.nativeRange.toString();\n                };\n\n                // Create test range and node for feature detection\n\n                var testTextNode = document.createTextNode(\"test\");\n                getBody(document).appendChild(testTextNode);\n                var range = document.createRange();\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and\n                // correct for it\n\n                range.setStart(testTextNode, 0);\n                range.setEnd(testTextNode, 0);\n\n                try {\n                    range.setStart(testTextNode, 1);\n\n                    rangeProto.setStart = function(node, offset) {\n                        this.nativeRange.setStart(node, offset);\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.setEnd = function(node, offset) {\n                        this.nativeRange.setEnd(node, offset);\n                        updateRangeProperties(this);\n                    };\n\n                    createBeforeAfterNodeSetter = function(name) {\n                        return function(node) {\n                            this.nativeRange[name](node);\n                            updateRangeProperties(this);\n                        };\n                    };\n\n                } catch(ex) {\n\n                    rangeProto.setStart = function(node, offset) {\n                        try {\n                            this.nativeRange.setStart(node, offset);\n                        } catch (ex) {\n                            this.nativeRange.setEnd(node, offset);\n                            this.nativeRange.setStart(node, offset);\n                        }\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.setEnd = function(node, offset) {\n                        try {\n                            this.nativeRange.setEnd(node, offset);\n                        } catch (ex) {\n                            this.nativeRange.setStart(node, offset);\n                            this.nativeRange.setEnd(node, offset);\n                        }\n                        updateRangeProperties(this);\n                    };\n\n                    createBeforeAfterNodeSetter = function(name, oppositeName) {\n                        return function(node) {\n                            try {\n                                this.nativeRange[name](node);\n                            } catch (ex) {\n                                this.nativeRange[oppositeName](node);\n                                this.nativeRange[name](node);\n                            }\n                            updateRangeProperties(this);\n                        };\n                    };\n                }\n\n                rangeProto.setStartBefore = createBeforeAfterNodeSetter(\"setStartBefore\", \"setEndBefore\");\n                rangeProto.setStartAfter = createBeforeAfterNodeSetter(\"setStartAfter\", \"setEndAfter\");\n                rangeProto.setEndBefore = createBeforeAfterNodeSetter(\"setEndBefore\", \"setStartBefore\");\n                rangeProto.setEndAfter = createBeforeAfterNodeSetter(\"setEndAfter\", \"setStartAfter\");\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Always use DOM4-compliant selectNodeContents implementation: it's simpler and less code than testing\n                // whether the native implementation can be trusted\n                rangeProto.selectNodeContents = function(node) {\n                    this.setStartAndEnd(node, 0, dom.getNodeLength(node));\n                };\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for and correct WebKit bug that has the behaviour of compareBoundaryPoints round the wrong way for\n                // constants START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738\n\n                range.selectNodeContents(testTextNode);\n                range.setEnd(testTextNode, 3);\n\n                var range2 = document.createRange();\n                range2.selectNodeContents(testTextNode);\n                range2.setEnd(testTextNode, 4);\n                range2.setStart(testTextNode, 2);\n\n                if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 &&\n                        range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {\n                    // This is the wrong way round, so correct for it\n\n                    rangeProto.compareBoundaryPoints = function(type, range) {\n                        range = range.nativeRange || range;\n                        if (type == range.START_TO_END) {\n                            type = range.END_TO_START;\n                        } else if (type == range.END_TO_START) {\n                            type = range.START_TO_END;\n                        }\n                        return this.nativeRange.compareBoundaryPoints(type, range);\n                    };\n                } else {\n                    rangeProto.compareBoundaryPoints = function(type, range) {\n                        return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);\n                    };\n                }\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for IE deleteContents() and extractContents() bug and correct it. See issue 107.\n\n                var el = document.createElement(\"div\");\n                el.innerHTML = \"123\";\n                var textNode = el.firstChild;\n                var body = getBody(document);\n                body.appendChild(el);\n\n                range.setStart(textNode, 1);\n                range.setEnd(textNode, 2);\n                range.deleteContents();\n\n                if (textNode.data == \"13\") {\n                    // Behaviour is correct per DOM4 Range so wrap the browser's implementation of deleteContents() and\n                    // extractContents()\n                    rangeProto.deleteContents = function() {\n                        this.nativeRange.deleteContents();\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.extractContents = function() {\n                        var frag = this.nativeRange.extractContents();\n                        updateRangeProperties(this);\n                        return frag;\n                    };\n                } else {\n                }\n\n                body.removeChild(el);\n                body = null;\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for existence of createContextualFragment and delegate to it if it exists\n                if (util.isHostMethod(range, \"createContextualFragment\")) {\n                    rangeProto.createContextualFragment = function(fragmentStr) {\n                        return this.nativeRange.createContextualFragment(fragmentStr);\n                    };\n                }\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Clean up\n                getBody(document).removeChild(testTextNode);\n\n                rangeProto.getName = function() {\n                    return \"WrappedRange\";\n                };\n\n                api.WrappedRange = WrappedRange;\n\n                api.createNativeRange = function(doc) {\n                    doc = getContentDocument(doc, module, \"createNativeRange\");\n                    return doc.createRange();\n                };\n            })();\n        }\n\n        if (api.features.implementsTextRange) {\n            /*\n            This is a workaround for a bug where IE returns the wrong container element from the TextRange's parentElement()\n            method. For example, in the following (where pipes denote the selection boundaries):\n\n            <ul id=\"ul\"><li id=\"a\">| a </li><li id=\"b\"> b |</li></ul>\n\n            var range = document.selection.createRange();\n            alert(range.parentElement().id); // Should alert \"ul\" but alerts \"b\"\n\n            This method returns the common ancestor node of the following:\n            - the parentElement() of the textRange\n            - the parentElement() of the textRange after calling collapse(true)\n            - the parentElement() of the textRange after calling collapse(false)\n            */\n            var getTextRangeContainerElement = function(textRange) {\n                var parentEl = textRange.parentElement();\n                var range = textRange.duplicate();\n                range.collapse(true);\n                var startEl = range.parentElement();\n                range = textRange.duplicate();\n                range.collapse(false);\n                var endEl = range.parentElement();\n                var startEndContainer = (startEl == endEl) ? startEl : dom.getCommonAncestor(startEl, endEl);\n\n                return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);\n            };\n\n            var textRangeIsCollapsed = function(textRange) {\n                return textRange.compareEndPoints(\"StartToEnd\", textRange) == 0;\n            };\n\n            // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started\n            // out as an improved version of code found in Tim Cameron Ryan's IERange (http://code.google.com/p/ierange/)\n            // but has grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange\n            // bugs, handling for inputs and images, plus optimizations.\n            var getTextRangeBoundaryPosition = function(textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {\n                var workingRange = textRange.duplicate();\n                workingRange.collapse(isStart);\n                var containerElement = workingRange.parentElement();\n\n                // Sometimes collapsing a TextRange that's at the start of a text node can move it into the previous node, so\n                // check for that\n                if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {\n                    containerElement = wholeRangeContainerElement;\n                }\n\n\n                // Deal with nodes that cannot \"contain rich HTML markup\". In practice, this means form inputs, images and\n                // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx\n                if (!containerElement.canHaveHTML) {\n                    var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));\n                    return {\n                        boundaryPosition: pos,\n                        nodeInfo: {\n                            nodeIndex: pos.offset,\n                            containerElement: pos.node\n                        }\n                    };\n                }\n\n                var workingNode = dom.getDocument(containerElement).createElement(\"span\");\n\n                // Workaround for HTML5 Shiv's insane violation of document.createElement(). See Rangy issue 104 and HTML5\n                // Shiv issue 64: https://github.com/aFarkas/html5shiv/issues/64\n                if (workingNode.parentNode) {\n                    dom.removeNode(workingNode);\n                }\n\n                var comparison, workingComparisonType = isStart ? \"StartToStart\" : \"StartToEnd\";\n                var previousNode, nextNode, boundaryPosition, boundaryNode;\n                var start = (startInfo && startInfo.containerElement == containerElement) ? startInfo.nodeIndex : 0;\n                var childNodeCount = containerElement.childNodes.length;\n                var end = childNodeCount;\n\n                // Check end first. Code within the loop assumes that the endth child node of the container is definitely\n                // after the range boundary.\n                var nodeIndex = end;\n\n                while (true) {\n                    if (nodeIndex == childNodeCount) {\n                        containerElement.appendChild(workingNode);\n                    } else {\n                        containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);\n                    }\n                    workingRange.moveToElementText(workingNode);\n                    comparison = workingRange.compareEndPoints(workingComparisonType, textRange);\n                    if (comparison == 0 || start == end) {\n                        break;\n                    } else if (comparison == -1) {\n                        if (end == start + 1) {\n                            // We know the endth child node is after the range boundary, so we must be done.\n                            break;\n                        } else {\n                            start = nodeIndex;\n                        }\n                    } else {\n                        end = (end == start + 1) ? start : nodeIndex;\n                    }\n                    nodeIndex = Math.floor((start + end) / 2);\n                    containerElement.removeChild(workingNode);\n                }\n\n\n                // We've now reached or gone past the boundary of the text range we're interested in\n                // so have identified the node we want\n                boundaryNode = workingNode.nextSibling;\n\n                if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {\n                    // This is a character data node (text, comment, cdata). The working range is collapsed at the start of\n                    // the node containing the text range's boundary, so we move the end of the working range to the\n                    // boundary point and measure the length of its text to get the boundary's offset within the node.\n                    workingRange.setEndPoint(isStart ? \"EndToStart\" : \"EndToEnd\", textRange);\n\n                    var offset;\n\n                    if (/[\\r\\n]/.test(boundaryNode.data)) {\n                        /*\n                        For the particular case of a boundary within a text node containing rendered line breaks (within a\n                        <pre> element, for example), we need a slightly complicated approach to get the boundary's offset in\n                        IE. The facts:\n\n                        - Each line break is represented as \\r in the text node's data/nodeValue properties\n                        - Each line break is represented as \\r\\n in the TextRange's 'text' property\n                        - The 'text' property of the TextRange does not contain trailing line breaks\n\n                        To get round the problem presented by the final fact above, we can use the fact that TextRange's\n                        moveStart() and moveEnd() methods return the actual number of characters moved, which is not\n                        necessarily the same as the number of characters it was instructed to move. The simplest approach is\n                        to use this to store the characters moved when moving both the start and end of the range to the\n                        start of the document body and subtracting the start offset from the end offset (the\n                        \"move-negative-gazillion\" method). However, this is extremely slow when the document is large and\n                        the range is near the end of it. Clearly doing the mirror image (i.e. moving the range boundaries to\n                        the end of the document) has the same problem.\n\n                        Another approach that works is to use moveStart() to move the start boundary of the range up to the\n                        end boundary one character at a time and incrementing a counter with the value returned by the\n                        moveStart() call. However, the check for whether the start boundary has reached the end boundary is\n                        expensive, so this method is slow (although unlike \"move-negative-gazillion\" is largely unaffected\n                        by the location of the range within the document).\n\n                        The approach used below is a hybrid of the two methods above. It uses the fact that a string\n                        containing the TextRange's 'text' property with each \\r\\n converted to a single \\r character cannot\n                        be longer than the text of the TextRange, so the start of the range is moved that length initially\n                        and then a character at a time to make up for any trailing line breaks not contained in the 'text'\n                        property. This has good performance in most situations compared to the previous two methods.\n                        */\n                        var tempRange = workingRange.duplicate();\n                        var rangeLength = tempRange.text.replace(/\\r\\n/g, \"\\r\").length;\n\n                        offset = tempRange.moveStart(\"character\", rangeLength);\n                        while ( (comparison = tempRange.compareEndPoints(\"StartToEnd\", tempRange)) == -1) {\n                            offset++;\n                            tempRange.moveStart(\"character\", 1);\n                        }\n                    } else {\n                        offset = workingRange.text.length;\n                    }\n                    boundaryPosition = new DomPosition(boundaryNode, offset);\n                } else {\n\n                    // If the boundary immediately follows a character data node and this is the end boundary, we should favour\n                    // a position within that, and likewise for a start boundary preceding a character data node\n                    previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;\n                    nextNode = (isCollapsed || isStart) && workingNode.nextSibling;\n                    if (nextNode && isCharacterDataNode(nextNode)) {\n                        boundaryPosition = new DomPosition(nextNode, 0);\n                    } else if (previousNode && isCharacterDataNode(previousNode)) {\n                        boundaryPosition = new DomPosition(previousNode, previousNode.data.length);\n                    } else {\n                        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));\n                    }\n                }\n\n                // Clean up\n                dom.removeNode(workingNode);\n\n                return {\n                    boundaryPosition: boundaryPosition,\n                    nodeInfo: {\n                        nodeIndex: nodeIndex,\n                        containerElement: containerElement\n                    }\n                };\n            };\n\n            // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that\n            // node. This function started out as an optimized version of code found in Tim Cameron Ryan's IERange\n            // (http://code.google.com/p/ierange/)\n            var createBoundaryTextRange = function(boundaryPosition, isStart) {\n                var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;\n                var doc = dom.getDocument(boundaryPosition.node);\n                var workingNode, childNodes, workingRange = getBody(doc).createTextRange();\n                var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);\n\n                if (nodeIsDataNode) {\n                    boundaryNode = boundaryPosition.node;\n                    boundaryParent = boundaryNode.parentNode;\n                } else {\n                    childNodes = boundaryPosition.node.childNodes;\n                    boundaryNode = (boundaryOffset < childNodes.length) ? childNodes[boundaryOffset] : null;\n                    boundaryParent = boundaryPosition.node;\n                }\n\n                // Position the range immediately before the node containing the boundary\n                workingNode = doc.createElement(\"span\");\n\n                // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within\n                // the element rather than immediately before or after it\n                workingNode.innerHTML = \"&#feff;\";\n\n                // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report\n                // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12\n                if (boundaryNode) {\n                    boundaryParent.insertBefore(workingNode, boundaryNode);\n                } else {\n                    boundaryParent.appendChild(workingNode);\n                }\n\n                workingRange.moveToElementText(workingNode);\n                workingRange.collapse(!isStart);\n\n                // Clean up\n                boundaryParent.removeChild(workingNode);\n\n                // Move the working range to the text offset, if required\n                if (nodeIsDataNode) {\n                    workingRange[isStart ? \"moveStart\" : \"moveEnd\"](\"character\", boundaryOffset);\n                }\n\n                return workingRange;\n            };\n\n            /*------------------------------------------------------------------------------------------------------------*/\n\n            // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy's DomRange as a\n            // prototype\n\n            WrappedTextRange = function(textRange) {\n                this.textRange = textRange;\n                this.refresh();\n            };\n\n            WrappedTextRange.prototype = new DomRange(document);\n\n            WrappedTextRange.prototype.refresh = function() {\n                var start, end, startBoundary;\n\n                // TextRange's parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.\n                var rangeContainerElement = getTextRangeContainerElement(this.textRange);\n\n                if (textRangeIsCollapsed(this.textRange)) {\n                    end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true,\n                        true).boundaryPosition;\n                } else {\n                    startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);\n                    start = startBoundary.boundaryPosition;\n\n                    // An optimization used here is that if the start and end boundaries have the same parent element, the\n                    // search scope for the end boundary can be limited to exclude the portion of the element that precedes\n                    // the start boundary\n                    end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false,\n                        startBoundary.nodeInfo).boundaryPosition;\n                }\n\n                this.setStart(start.node, start.offset);\n                this.setEnd(end.node, end.offset);\n            };\n\n            WrappedTextRange.prototype.getName = function() {\n                return \"WrappedTextRange\";\n            };\n\n            DomRange.copyComparisonConstants(WrappedTextRange);\n\n            var rangeToTextRange = function(range) {\n                if (range.collapsed) {\n                    return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n                } else {\n                    var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n                    var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);\n                    var textRange = getBody( DomRange.getRangeDocument(range) ).createTextRange();\n                    textRange.setEndPoint(\"StartToStart\", startRange);\n                    textRange.setEndPoint(\"EndToEnd\", endRange);\n                    return textRange;\n                }\n            };\n\n            WrappedTextRange.rangeToTextRange = rangeToTextRange;\n\n            WrappedTextRange.prototype.toTextRange = function() {\n                return rangeToTextRange(this);\n            };\n\n            api.WrappedTextRange = WrappedTextRange;\n\n            // IE 9 and above have both implementations and Rangy makes both available. The next few lines sets which\n            // implementation to use by default.\n            if (!api.features.implementsDomRange || api.config.preferTextRange) {\n                // Add WrappedTextRange as the Range property of the global object to allow expression like Range.END_TO_END to work\n                var globalObj = (function(f) { return f(\"return this;\")(); })(Function);\n                if (typeof globalObj.Range == \"undefined\") {\n                    globalObj.Range = WrappedTextRange;\n                }\n\n                api.createNativeRange = function(doc) {\n                    doc = getContentDocument(doc, module, \"createNativeRange\");\n                    return getBody(doc).createTextRange();\n                };\n\n                api.WrappedRange = WrappedTextRange;\n            }\n        }\n\n        api.createRange = function(doc) {\n            doc = getContentDocument(doc, module, \"createRange\");\n            return new api.WrappedRange(api.createNativeRange(doc));\n        };\n\n        api.createRangyRange = function(doc) {\n            doc = getContentDocument(doc, module, \"createRangyRange\");\n            return new DomRange(doc);\n        };\n\n        util.createAliasForDeprecatedMethod(api, \"createIframeRange\", \"createRange\");\n        util.createAliasForDeprecatedMethod(api, \"createIframeRangyRange\", \"createRangyRange\");\n\n        api.addShimListener(function(win) {\n            var doc = win.document;\n            if (typeof doc.createRange == \"undefined\") {\n                doc.createRange = function() {\n                    return api.createRange(doc);\n                };\n            }\n            doc = win = null;\n        });\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // This module creates a selection object wrapper that conforms as closely as possible to the Selection specification\n    // in the HTML Editing spec (http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections)\n    api.createCoreModule(\"WrappedSelection\", [\"DomRange\", \"WrappedRange\"], function(api, module) {\n        api.config.checkSelectionRanges = true;\n\n        var BOOLEAN = \"boolean\";\n        var NUMBER = \"number\";\n        var dom = api.dom;\n        var util = api.util;\n        var isHostMethod = util.isHostMethod;\n        var DomRange = api.DomRange;\n        var WrappedRange = api.WrappedRange;\n        var DOMException = api.DOMException;\n        var DomPosition = dom.DomPosition;\n        var getNativeSelection;\n        var selectionIsCollapsed;\n        var features = api.features;\n        var CONTROL = \"Control\";\n        var getDocument = dom.getDocument;\n        var getBody = dom.getBody;\n        var rangesEqual = DomRange.rangesEqual;\n\n\n        // Utility function to support direction parameters in the API that may be a string (\"backward\", \"backwards\",\n        // \"forward\" or \"forwards\") or a Boolean (true for backwards).\n        function isDirectionBackward(dir) {\n            return (typeof dir == \"string\") ? /^backward(s)?$/i.test(dir) : !!dir;\n        }\n\n        function getWindow(win, methodName) {\n            if (!win) {\n                return window;\n            } else if (dom.isWindow(win)) {\n                return win;\n            } else if (win instanceof WrappedSelection) {\n                return win.win;\n            } else {\n                var doc = dom.getContentDocument(win, module, methodName);\n                return dom.getWindow(doc);\n            }\n        }\n\n        function getWinSelection(winParam) {\n            return getWindow(winParam, \"getWinSelection\").getSelection();\n        }\n\n        function getDocSelection(winParam) {\n            return getWindow(winParam, \"getDocSelection\").document.selection;\n        }\n\n        function winSelectionIsBackward(sel) {\n            var backward = false;\n            if (sel.anchorNode) {\n                backward = (dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);\n            }\n            return backward;\n        }\n\n        // Test for the Range/TextRange and Selection features required\n        // Test for ability to retrieve selection\n        var implementsWinGetSelection = isHostMethod(window, \"getSelection\"),\n            implementsDocSelection = util.isHostObject(document, \"selection\");\n\n        features.implementsWinGetSelection = implementsWinGetSelection;\n        features.implementsDocSelection = implementsDocSelection;\n\n        var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);\n\n        if (useDocumentSelection) {\n            getNativeSelection = getDocSelection;\n            api.isSelectionValid = function(winParam) {\n                var doc = getWindow(winParam, \"isSelectionValid\").document, nativeSel = doc.selection;\n\n                // Check whether the selection TextRange is actually contained within the correct document\n                return (nativeSel.type != \"None\" || getDocument(nativeSel.createRange().parentElement()) == doc);\n            };\n        } else if (implementsWinGetSelection) {\n            getNativeSelection = getWinSelection;\n            api.isSelectionValid = function() {\n                return true;\n            };\n        } else {\n            module.fail(\"Neither document.selection or window.getSelection() detected.\");\n            return false;\n        }\n\n        api.getNativeSelection = getNativeSelection;\n\n        var testSelection = getNativeSelection();\n\n        // In Firefox, the selection is null in an iframe with display: none. See issue #138.\n        if (!testSelection) {\n            module.fail(\"Native selection was null (possibly issue 138?)\");\n            return false;\n        }\n\n        var testRange = api.createNativeRange(document);\n        var body = getBody(document);\n\n        // Obtaining a range from a selection\n        var selectionHasAnchorAndFocus = util.areHostProperties(testSelection,\n            [\"anchorNode\", \"focusNode\", \"anchorOffset\", \"focusOffset\"]);\n\n        features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;\n\n        // Test for existence of native selection extend() method\n        var selectionHasExtend = isHostMethod(testSelection, \"extend\");\n        features.selectionHasExtend = selectionHasExtend;\n\n        // Test if rangeCount exists\n        var selectionHasRangeCount = (typeof testSelection.rangeCount == NUMBER);\n        features.selectionHasRangeCount = selectionHasRangeCount;\n\n        var selectionSupportsMultipleRanges = false;\n        var collapsedNonEditableSelectionsSupported = true;\n\n        var addRangeBackwardToNative = selectionHasExtend ?\n            function(nativeSelection, range) {\n                var doc = DomRange.getRangeDocument(range);\n                var endRange = api.createRange(doc);\n                endRange.collapseToPoint(range.endContainer, range.endOffset);\n                nativeSelection.addRange(getNativeRange(endRange));\n                nativeSelection.extend(range.startContainer, range.startOffset);\n            } : null;\n\n        if (util.areHostMethods(testSelection, [\"addRange\", \"getRangeAt\", \"removeAllRanges\"]) &&\n                typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {\n\n            (function() {\n                // Previously an iframe was used but this caused problems in some circumstances in IE, so tests are\n                // performed on the current document's selection. See issue 109.\n\n                // Note also that if a selection previously existed, it is wiped and later restored by these tests. This\n                // will result in the selection direction begin reversed if the original selection was backwards and the\n                // browser does not support setting backwards selections (Internet Explorer, I'm looking at you).\n                var sel = window.getSelection();\n                if (sel) {\n                    // Store the current selection\n                    var originalSelectionRangeCount = sel.rangeCount;\n                    var selectionHasMultipleRanges = (originalSelectionRangeCount > 1);\n                    var originalSelectionRanges = [];\n                    var originalSelectionBackward = winSelectionIsBackward(sel);\n                    for (var i = 0; i < originalSelectionRangeCount; ++i) {\n                        originalSelectionRanges[i] = sel.getRangeAt(i);\n                    }\n\n                    // Create some test elements\n                    var testEl = dom.createTestElement(document, \"\", false);\n                    var textNode = testEl.appendChild( document.createTextNode(\"\\u00a0\\u00a0\\u00a0\") );\n\n                    // Test whether the native selection will allow a collapsed selection within a non-editable element\n                    var r1 = document.createRange();\n\n                    r1.setStart(textNode, 1);\n                    r1.collapse(true);\n                    sel.removeAllRanges();\n                    sel.addRange(r1);\n                    collapsedNonEditableSelectionsSupported = (sel.rangeCount == 1);\n                    sel.removeAllRanges();\n\n                    // Test whether the native selection is capable of supporting multiple ranges.\n                    if (!selectionHasMultipleRanges) {\n                        // Doing the original feature test here in Chrome 36 (and presumably later versions) prints a\n                        // console error of \"Discontiguous selection is not supported.\" that cannot be suppressed. There's\n                        // nothing we can do about this while retaining the feature test so we have to resort to a browser\n                        // sniff. I'm not happy about it. See\n                        // https://code.google.com/p/chromium/issues/detail?id=399791\n                        var chromeMatch = window.navigator.appVersion.match(/Chrome\\/(.*?) /);\n                        if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {\n                            selectionSupportsMultipleRanges = false;\n                        } else {\n                            var r2 = r1.cloneRange();\n                            r1.setStart(textNode, 0);\n                            r2.setEnd(textNode, 3);\n                            r2.setStart(textNode, 2);\n                            sel.addRange(r1);\n                            sel.addRange(r2);\n                            selectionSupportsMultipleRanges = (sel.rangeCount == 2);\n                        }\n                    }\n\n                    // Clean up\n                    dom.removeNode(testEl);\n                    sel.removeAllRanges();\n\n                    for (i = 0; i < originalSelectionRangeCount; ++i) {\n                        if (i == 0 && originalSelectionBackward) {\n                            if (addRangeBackwardToNative) {\n                                addRangeBackwardToNative(sel, originalSelectionRanges[i]);\n                            } else {\n                                api.warn(\"Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend\");\n                                sel.addRange(originalSelectionRanges[i]);\n                            }\n                        } else {\n                            sel.addRange(originalSelectionRanges[i]);\n                        }\n                    }\n                }\n            })();\n        }\n\n        features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;\n        features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;\n\n        // ControlRanges\n        var implementsControlRange = false, testControlRange;\n\n        if (body && isHostMethod(body, \"createControlRange\")) {\n            testControlRange = body.createControlRange();\n            if (util.areHostProperties(testControlRange, [\"item\", \"add\"])) {\n                implementsControlRange = true;\n            }\n        }\n        features.implementsControlRange = implementsControlRange;\n\n        // Selection collapsedness\n        if (selectionHasAnchorAndFocus) {\n            selectionIsCollapsed = function(sel) {\n                return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;\n            };\n        } else {\n            selectionIsCollapsed = function(sel) {\n                return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;\n            };\n        }\n\n        function updateAnchorAndFocusFromRange(sel, range, backward) {\n            var anchorPrefix = backward ? \"end\" : \"start\", focusPrefix = backward ? \"start\" : \"end\";\n            sel.anchorNode = range[anchorPrefix + \"Container\"];\n            sel.anchorOffset = range[anchorPrefix + \"Offset\"];\n            sel.focusNode = range[focusPrefix + \"Container\"];\n            sel.focusOffset = range[focusPrefix + \"Offset\"];\n        }\n\n        function updateAnchorAndFocusFromNativeSelection(sel) {\n            var nativeSel = sel.nativeSelection;\n            sel.anchorNode = nativeSel.anchorNode;\n            sel.anchorOffset = nativeSel.anchorOffset;\n            sel.focusNode = nativeSel.focusNode;\n            sel.focusOffset = nativeSel.focusOffset;\n        }\n\n        function updateEmptySelection(sel) {\n            sel.anchorNode = sel.focusNode = null;\n            sel.anchorOffset = sel.focusOffset = 0;\n            sel.rangeCount = 0;\n            sel.isCollapsed = true;\n            sel._ranges.length = 0;\n        }\n\n        function getNativeRange(range) {\n            var nativeRange;\n            if (range instanceof DomRange) {\n                nativeRange = api.createNativeRange(range.getDocument());\n                nativeRange.setEnd(range.endContainer, range.endOffset);\n                nativeRange.setStart(range.startContainer, range.startOffset);\n            } else if (range instanceof WrappedRange) {\n                nativeRange = range.nativeRange;\n            } else if (features.implementsDomRange && (range instanceof dom.getWindow(range.startContainer).Range)) {\n                nativeRange = range;\n            }\n            return nativeRange;\n        }\n\n        function rangeContainsSingleElement(rangeNodes) {\n            if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {\n                return false;\n            }\n            for (var i = 1, len = rangeNodes.length; i < len; ++i) {\n                if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function getSingleElementFromRange(range) {\n            var nodes = range.getNodes();\n            if (!rangeContainsSingleElement(nodes)) {\n                throw module.createError(\"getSingleElementFromRange: range \" + range.inspect() + \" did not consist of a single element\");\n            }\n            return nodes[0];\n        }\n\n        // Simple, quick test which only needs to distinguish between a TextRange and a ControlRange\n        function isTextRange(range) {\n            return !!range && typeof range.text != \"undefined\";\n        }\n\n        function updateFromTextRange(sel, range) {\n            // Create a Range from the selected TextRange\n            var wrappedRange = new WrappedRange(range);\n            sel._ranges = [wrappedRange];\n\n            updateAnchorAndFocusFromRange(sel, wrappedRange, false);\n            sel.rangeCount = 1;\n            sel.isCollapsed = wrappedRange.collapsed;\n        }\n\n        function updateControlSelection(sel) {\n            // Update the wrapped selection based on what's now in the native selection\n            sel._ranges.length = 0;\n            if (sel.docSelection.type == \"None\") {\n                updateEmptySelection(sel);\n            } else {\n                var controlRange = sel.docSelection.createRange();\n                if (isTextRange(controlRange)) {\n                    // This case (where the selection type is \"Control\" and calling createRange() on the selection returns\n                    // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected\n                    // ControlRange have been removed from the ControlRange and removed from the document.\n                    updateFromTextRange(sel, controlRange);\n                } else {\n                    sel.rangeCount = controlRange.length;\n                    var range, doc = getDocument(controlRange.item(0));\n                    for (var i = 0; i < sel.rangeCount; ++i) {\n                        range = api.createRange(doc);\n                        range.selectNode(controlRange.item(i));\n                        sel._ranges.push(range);\n                    }\n                    sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;\n                    updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);\n                }\n            }\n        }\n\n        function addRangeToControlSelection(sel, range) {\n            var controlRange = sel.docSelection.createRange();\n            var rangeElement = getSingleElementFromRange(range);\n\n            // Create a new ControlRange containing all the elements in the selected ControlRange plus the element\n            // contained by the supplied range\n            var doc = getDocument(controlRange.item(0));\n            var newControlRange = getBody(doc).createControlRange();\n            for (var i = 0, len = controlRange.length; i < len; ++i) {\n                newControlRange.add(controlRange.item(i));\n            }\n            try {\n                newControlRange.add(rangeElement);\n            } catch (ex) {\n                throw module.createError(\"addRange(): Element within the specified Range could not be added to control selection (does it have layout?)\");\n            }\n            newControlRange.select();\n\n            // Update the wrapped selection based on what's now in the native selection\n            updateControlSelection(sel);\n        }\n\n        var getSelectionRangeAt;\n\n        if (isHostMethod(testSelection, \"getRangeAt\")) {\n            // try/catch is present because getRangeAt() must have thrown an error in some browser and some situation.\n            // Unfortunately, I didn't write a comment about the specifics and am now scared to take it out. Let that be a\n            // lesson to us all, especially me.\n            getSelectionRangeAt = function(sel, index) {\n                try {\n                    return sel.getRangeAt(index);\n                } catch (ex) {\n                    return null;\n                }\n            };\n        } else if (selectionHasAnchorAndFocus) {\n            getSelectionRangeAt = function(sel) {\n                var doc = getDocument(sel.anchorNode);\n                var range = api.createRange(doc);\n                range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);\n\n                // Handle the case when the selection was selected backwards (from the end to the start in the\n                // document)\n                if (range.collapsed !== this.isCollapsed) {\n                    range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);\n                }\n\n                return range;\n            };\n        }\n\n        function WrappedSelection(selection, docSelection, win) {\n            this.nativeSelection = selection;\n            this.docSelection = docSelection;\n            this._ranges = [];\n            this.win = win;\n            this.refresh();\n        }\n\n        WrappedSelection.prototype = api.selectionPrototype;\n\n        function deleteProperties(sel) {\n            sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;\n            sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;\n            sel.detached = true;\n        }\n\n        var cachedRangySelections = [];\n\n        function actOnCachedSelection(win, action) {\n            var i = cachedRangySelections.length, cached, sel;\n            while (i--) {\n                cached = cachedRangySelections[i];\n                sel = cached.selection;\n                if (action == \"deleteAll\") {\n                    deleteProperties(sel);\n                } else if (cached.win == win) {\n                    if (action == \"delete\") {\n                        cachedRangySelections.splice(i, 1);\n                        return true;\n                    } else {\n                        return sel;\n                    }\n                }\n            }\n            if (action == \"deleteAll\") {\n                cachedRangySelections.length = 0;\n            }\n            return null;\n        }\n\n        var getSelection = function(win) {\n            // Check if the parameter is a Rangy Selection object\n            if (win && win instanceof WrappedSelection) {\n                win.refresh();\n                return win;\n            }\n\n            win = getWindow(win, \"getNativeSelection\");\n\n            var sel = actOnCachedSelection(win);\n            var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;\n            if (sel) {\n                sel.nativeSelection = nativeSel;\n                sel.docSelection = docSel;\n                sel.refresh();\n            } else {\n                sel = new WrappedSelection(nativeSel, docSel, win);\n                cachedRangySelections.push( { win: win, selection: sel } );\n            }\n            return sel;\n        };\n\n        api.getSelection = getSelection;\n\n        util.createAliasForDeprecatedMethod(api, \"getIframeSelection\", \"getSelection\");\n\n        var selProto = WrappedSelection.prototype;\n\n        function createControlSelection(sel, ranges) {\n            // Ensure that the selection becomes of type \"Control\"\n            var doc = getDocument(ranges[0].startContainer);\n            var controlRange = getBody(doc).createControlRange();\n            for (var i = 0, el, len = ranges.length; i < len; ++i) {\n                el = getSingleElementFromRange(ranges[i]);\n                try {\n                    controlRange.add(el);\n                } catch (ex) {\n                    throw module.createError(\"setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)\");\n                }\n            }\n            controlRange.select();\n\n            // Update the wrapped selection based on what's now in the native selection\n            updateControlSelection(sel);\n        }\n\n        // Selecting a range\n        if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, [\"removeAllRanges\", \"addRange\"])) {\n            selProto.removeAllRanges = function() {\n                this.nativeSelection.removeAllRanges();\n                updateEmptySelection(this);\n            };\n\n            var addRangeBackward = function(sel, range) {\n                addRangeBackwardToNative(sel.nativeSelection, range);\n                sel.refresh();\n            };\n\n            if (selectionHasRangeCount) {\n                selProto.addRange = function(range, direction) {\n                    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n                        addRangeToControlSelection(this, range);\n                    } else {\n                        if (isDirectionBackward(direction) && selectionHasExtend) {\n                            addRangeBackward(this, range);\n                        } else {\n                            var previousRangeCount;\n                            if (selectionSupportsMultipleRanges) {\n                                previousRangeCount = this.rangeCount;\n                            } else {\n                                this.removeAllRanges();\n                                previousRangeCount = 0;\n                            }\n                            // Clone the native range so that changing the selected range does not affect the selection.\n                            // This is contrary to the spec but is the only way to achieve consistency between browsers. See\n                            // issue 80.\n                            var clonedNativeRange = getNativeRange(range).cloneRange();\n                            try {\n                                this.nativeSelection.addRange(clonedNativeRange);\n                            } catch (ex) {\n                            }\n\n                            // Check whether adding the range was successful\n                            this.rangeCount = this.nativeSelection.rangeCount;\n\n                            if (this.rangeCount == previousRangeCount + 1) {\n                                // The range was added successfully\n\n                                // Check whether the range that we added to the selection is reflected in the last range extracted from\n                                // the selection\n                                if (api.config.checkSelectionRanges) {\n                                    var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);\n                                    if (nativeRange && !rangesEqual(nativeRange, range)) {\n                                        // Happens in WebKit with, for example, a selection placed at the start of a text node\n                                        range = new WrappedRange(nativeRange);\n                                    }\n                                }\n                                this._ranges[this.rangeCount - 1] = range;\n                                updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));\n                                this.isCollapsed = selectionIsCollapsed(this);\n                            } else {\n                                // The range was not added successfully. The simplest thing is to refresh\n                                this.refresh();\n                            }\n                        }\n                    }\n                };\n            } else {\n                selProto.addRange = function(range, direction) {\n                    if (isDirectionBackward(direction) && selectionHasExtend) {\n                        addRangeBackward(this, range);\n                    } else {\n                        this.nativeSelection.addRange(getNativeRange(range));\n                        this.refresh();\n                    }\n                };\n            }\n\n            selProto.setRanges = function(ranges) {\n                if (implementsControlRange && implementsDocSelection && ranges.length > 1) {\n                    createControlSelection(this, ranges);\n                } else {\n                    this.removeAllRanges();\n                    for (var i = 0, len = ranges.length; i < len; ++i) {\n                        this.addRange(ranges[i]);\n                    }\n                }\n            };\n        } else if (isHostMethod(testSelection, \"empty\") && isHostMethod(testRange, \"select\") &&\n                   implementsControlRange && useDocumentSelection) {\n\n            selProto.removeAllRanges = function() {\n                // Added try/catch as fix for issue #21\n                try {\n                    this.docSelection.empty();\n\n                    // Check for empty() not working (issue #24)\n                    if (this.docSelection.type != \"None\") {\n                        // Work around failure to empty a control selection by instead selecting a TextRange and then\n                        // calling empty()\n                        var doc;\n                        if (this.anchorNode) {\n                            doc = getDocument(this.anchorNode);\n                        } else if (this.docSelection.type == CONTROL) {\n                            var controlRange = this.docSelection.createRange();\n                            if (controlRange.length) {\n                                doc = getDocument( controlRange.item(0) );\n                            }\n                        }\n                        if (doc) {\n                            var textRange = getBody(doc).createTextRange();\n                            textRange.select();\n                            this.docSelection.empty();\n                        }\n                    }\n                } catch(ex) {}\n                updateEmptySelection(this);\n            };\n\n            selProto.addRange = function(range) {\n                if (this.docSelection.type == CONTROL) {\n                    addRangeToControlSelection(this, range);\n                } else {\n                    api.WrappedTextRange.rangeToTextRange(range).select();\n                    this._ranges[0] = range;\n                    this.rangeCount = 1;\n                    this.isCollapsed = this._ranges[0].collapsed;\n                    updateAnchorAndFocusFromRange(this, range, false);\n                }\n            };\n\n            selProto.setRanges = function(ranges) {\n                this.removeAllRanges();\n                var rangeCount = ranges.length;\n                if (rangeCount > 1) {\n                    createControlSelection(this, ranges);\n                } else if (rangeCount) {\n                    this.addRange(ranges[0]);\n                }\n            };\n        } else {\n            module.fail(\"No means of selecting a Range or TextRange was found\");\n            return false;\n        }\n\n        selProto.getRangeAt = function(index) {\n            if (index < 0 || index >= this.rangeCount) {\n                throw new DOMException(\"INDEX_SIZE_ERR\");\n            } else {\n                // Clone the range to preserve selection-range independence. See issue 80.\n                return this._ranges[index].cloneRange();\n            }\n        };\n\n        var refreshSelection;\n\n        if (useDocumentSelection) {\n            refreshSelection = function(sel) {\n                var range;\n                if (api.isSelectionValid(sel.win)) {\n                    range = sel.docSelection.createRange();\n                } else {\n                    range = getBody(sel.win.document).createTextRange();\n                    range.collapse(true);\n                }\n\n                if (sel.docSelection.type == CONTROL) {\n                    updateControlSelection(sel);\n                } else if (isTextRange(range)) {\n                    updateFromTextRange(sel, range);\n                } else {\n                    updateEmptySelection(sel);\n                }\n            };\n        } else if (isHostMethod(testSelection, \"getRangeAt\") && typeof testSelection.rangeCount == NUMBER) {\n            refreshSelection = function(sel) {\n                if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {\n                    updateControlSelection(sel);\n                } else {\n                    sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;\n                    if (sel.rangeCount) {\n                        for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));\n                        }\n                        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));\n                        sel.isCollapsed = selectionIsCollapsed(sel);\n                    } else {\n                        updateEmptySelection(sel);\n                    }\n                }\n            };\n        } else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {\n            refreshSelection = function(sel) {\n                var range, nativeSel = sel.nativeSelection;\n                if (nativeSel.anchorNode) {\n                    range = getSelectionRangeAt(nativeSel, 0);\n                    sel._ranges = [range];\n                    sel.rangeCount = 1;\n                    updateAnchorAndFocusFromNativeSelection(sel);\n                    sel.isCollapsed = selectionIsCollapsed(sel);\n                } else {\n                    updateEmptySelection(sel);\n                }\n            };\n        } else {\n            module.fail(\"No means of obtaining a Range or TextRange from the user's selection was found\");\n            return false;\n        }\n\n        selProto.refresh = function(checkForChanges) {\n            var oldRanges = checkForChanges ? this._ranges.slice(0) : null;\n            var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;\n\n            refreshSelection(this);\n            if (checkForChanges) {\n                // Check the range count first\n                var i = oldRanges.length;\n                if (i != this._ranges.length) {\n                    return true;\n                }\n\n                // Now check the direction. Checking the anchor position is the same is enough since we're checking all the\n                // ranges after this\n                if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {\n                    return true;\n                }\n\n                // Finally, compare each range in turn\n                while (i--) {\n                    if (!rangesEqual(oldRanges[i], this._ranges[i])) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        };\n\n        // Removal of a single range\n        var removeRangeManually = function(sel, range) {\n            var ranges = sel.getAllRanges();\n            sel.removeAllRanges();\n            for (var i = 0, len = ranges.length; i < len; ++i) {\n                if (!rangesEqual(range, ranges[i])) {\n                    sel.addRange(ranges[i]);\n                }\n            }\n            if (!sel.rangeCount) {\n                updateEmptySelection(sel);\n            }\n        };\n\n        if (implementsControlRange && implementsDocSelection) {\n            selProto.removeRange = function(range) {\n                if (this.docSelection.type == CONTROL) {\n                    var controlRange = this.docSelection.createRange();\n                    var rangeElement = getSingleElementFromRange(range);\n\n                    // Create a new ControlRange containing all the elements in the selected ControlRange minus the\n                    // element contained by the supplied range\n                    var doc = getDocument(controlRange.item(0));\n                    var newControlRange = getBody(doc).createControlRange();\n                    var el, removed = false;\n                    for (var i = 0, len = controlRange.length; i < len; ++i) {\n                        el = controlRange.item(i);\n                        if (el !== rangeElement || removed) {\n                            newControlRange.add(controlRange.item(i));\n                        } else {\n                            removed = true;\n                        }\n                    }\n                    newControlRange.select();\n\n                    // Update the wrapped selection based on what's now in the native selection\n                    updateControlSelection(this);\n                } else {\n                    removeRangeManually(this, range);\n                }\n            };\n        } else {\n            selProto.removeRange = function(range) {\n                removeRangeManually(this, range);\n            };\n        }\n\n        // Detecting if a selection is backward\n        var selectionIsBackward;\n        if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {\n            selectionIsBackward = winSelectionIsBackward;\n\n            selProto.isBackward = function() {\n                return selectionIsBackward(this);\n            };\n        } else {\n            selectionIsBackward = selProto.isBackward = function() {\n                return false;\n            };\n        }\n\n        // Create an alias for backwards compatibility. From 1.3, everything is \"backward\" rather than \"backwards\"\n        selProto.isBackwards = selProto.isBackward;\n\n        // Selection stringifier\n        // This is conformant to the old HTML5 selections draft spec but differs from WebKit and Mozilla's implementation.\n        // The current spec does not yet define this method.\n        selProto.toString = function() {\n            var rangeTexts = [];\n            for (var i = 0, len = this.rangeCount; i < len; ++i) {\n                rangeTexts[i] = \"\" + this._ranges[i];\n            }\n            return rangeTexts.join(\"\");\n        };\n\n        function assertNodeInSameDocument(sel, node) {\n            if (sel.win.document != getDocument(node)) {\n                throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n            }\n        }\n\n        // No current browser conforms fully to the spec for this method, so Rangy's own method is always used\n        selProto.collapse = function(node, offset) {\n            assertNodeInSameDocument(this, node);\n            var range = api.createRange(node);\n            range.collapseToPoint(node, offset);\n            this.setSingleRange(range);\n            this.isCollapsed = true;\n        };\n\n        selProto.collapseToStart = function() {\n            if (this.rangeCount) {\n                var range = this._ranges[0];\n                this.collapse(range.startContainer, range.startOffset);\n            } else {\n                throw new DOMException(\"INVALID_STATE_ERR\");\n            }\n        };\n\n        selProto.collapseToEnd = function() {\n            if (this.rangeCount) {\n                var range = this._ranges[this.rangeCount - 1];\n                this.collapse(range.endContainer, range.endOffset);\n            } else {\n                throw new DOMException(\"INVALID_STATE_ERR\");\n            }\n        };\n\n        // The spec is very specific on how selectAllChildren should be implemented and not all browsers implement it as\n        // specified so the native implementation is never used by Rangy.\n        selProto.selectAllChildren = function(node) {\n            assertNodeInSameDocument(this, node);\n            var range = api.createRange(node);\n            range.selectNodeContents(node);\n            this.setSingleRange(range);\n        };\n\n        selProto.deleteFromDocument = function() {\n            // Sepcial behaviour required for IE's control selections\n            if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n                var controlRange = this.docSelection.createRange();\n                var element;\n                while (controlRange.length) {\n                    element = controlRange.item(0);\n                    controlRange.remove(element);\n                    dom.removeNode(element);\n                }\n                this.refresh();\n            } else if (this.rangeCount) {\n                var ranges = this.getAllRanges();\n                if (ranges.length) {\n                    this.removeAllRanges();\n                    for (var i = 0, len = ranges.length; i < len; ++i) {\n                        ranges[i].deleteContents();\n                    }\n                    // The spec says nothing about what the selection should contain after calling deleteContents on each\n                    // range. Firefox moves the selection to where the final selected range was, so we emulate that\n                    this.addRange(ranges[len - 1]);\n                }\n            }\n        };\n\n        // The following are non-standard extensions\n        selProto.eachRange = function(func, returnValue) {\n            for (var i = 0, len = this._ranges.length; i < len; ++i) {\n                if ( func( this.getRangeAt(i) ) ) {\n                    return returnValue;\n                }\n            }\n        };\n\n        selProto.getAllRanges = function() {\n            var ranges = [];\n            this.eachRange(function(range) {\n                ranges.push(range);\n            });\n            return ranges;\n        };\n\n        selProto.setSingleRange = function(range, direction) {\n            this.removeAllRanges();\n            this.addRange(range, direction);\n        };\n\n        selProto.callMethodOnEachRange = function(methodName, params) {\n            var results = [];\n            this.eachRange( function(range) {\n                results.push( range[methodName].apply(range, params || []) );\n            } );\n            return results;\n        };\n\n        function createStartOrEndSetter(isStart) {\n            return function(node, offset) {\n                var range;\n                if (this.rangeCount) {\n                    range = this.getRangeAt(0);\n                    range[\"set\" + (isStart ? \"Start\" : \"End\")](node, offset);\n                } else {\n                    range = api.createRange(this.win.document);\n                    range.setStartAndEnd(node, offset);\n                }\n                this.setSingleRange(range, this.isBackward());\n            };\n        }\n\n        selProto.setStart = createStartOrEndSetter(true);\n        selProto.setEnd = createStartOrEndSetter(false);\n\n        // Add select() method to Range prototype. Any existing selection will be removed.\n        api.rangePrototype.select = function(direction) {\n            getSelection( this.getDocument() ).setSingleRange(this, direction);\n        };\n\n        selProto.changeEachRange = function(func) {\n            var ranges = [];\n            var backward = this.isBackward();\n\n            this.eachRange(function(range) {\n                func(range);\n                ranges.push(range);\n            });\n\n            this.removeAllRanges();\n            if (backward && ranges.length == 1) {\n                this.addRange(ranges[0], \"backward\");\n            } else {\n                this.setRanges(ranges);\n            }\n        };\n\n        selProto.containsNode = function(node, allowPartial) {\n            return this.eachRange( function(range) {\n                return range.containsNode(node, allowPartial);\n            }, true ) || false;\n        };\n\n        selProto.getBookmark = function(containerNode) {\n            return {\n                backward: this.isBackward(),\n                rangeBookmarks: this.callMethodOnEachRange(\"getBookmark\", [containerNode])\n            };\n        };\n\n        selProto.moveToBookmark = function(bookmark) {\n            var selRanges = [];\n            for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++]; ) {\n                range = api.createRange(this.win);\n                range.moveToBookmark(rangeBookmark);\n                selRanges.push(range);\n            }\n            if (bookmark.backward) {\n                this.setSingleRange(selRanges[0], \"backward\");\n            } else {\n                this.setRanges(selRanges);\n            }\n        };\n\n        selProto.saveRanges = function() {\n            return {\n                backward: this.isBackward(),\n                ranges: this.callMethodOnEachRange(\"cloneRange\")\n            };\n        };\n\n        selProto.restoreRanges = function(selRanges) {\n            this.removeAllRanges();\n            for (var i = 0, range; range = selRanges.ranges[i]; ++i) {\n                this.addRange(range, (selRanges.backward && i == 0));\n            }\n        };\n\n        selProto.toHtml = function() {\n            var rangeHtmls = [];\n            this.eachRange(function(range) {\n                rangeHtmls.push( DomRange.toHtml(range) );\n            });\n            return rangeHtmls.join(\"\");\n        };\n\n        if (features.implementsTextRange) {\n            selProto.getNativeTextRange = function() {\n                var sel, textRange;\n                if ( (sel = this.docSelection) ) {\n                    var range = sel.createRange();\n                    if (isTextRange(range)) {\n                        return range;\n                    } else {\n                        throw module.createError(\"getNativeTextRange: selection is a control selection\");\n                    }\n                } else if (this.rangeCount > 0) {\n                    return api.WrappedTextRange.rangeToTextRange( this.getRangeAt(0) );\n                } else {\n                    throw module.createError(\"getNativeTextRange: selection contains no range\");\n                }\n            };\n        }\n\n        function inspect(sel) {\n            var rangeInspects = [];\n            var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);\n            var focus = new DomPosition(sel.focusNode, sel.focusOffset);\n            var name = (typeof sel.getName == \"function\") ? sel.getName() : \"Selection\";\n\n            if (typeof sel.rangeCount != \"undefined\") {\n                for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                    rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));\n                }\n            }\n            return \"[\" + name + \"(Ranges: \" + rangeInspects.join(\", \") +\n                    \")(anchor: \" + anchor.inspect() + \", focus: \" + focus.inspect() + \"]\";\n        }\n\n        selProto.getName = function() {\n            return \"WrappedSelection\";\n        };\n\n        selProto.inspect = function() {\n            return inspect(this);\n        };\n\n        selProto.detach = function() {\n            actOnCachedSelection(this.win, \"delete\");\n            deleteProperties(this);\n        };\n\n        WrappedSelection.detachAll = function() {\n            actOnCachedSelection(null, \"deleteAll\");\n        };\n\n        WrappedSelection.inspect = inspect;\n        WrappedSelection.isDirectionBackward = isDirectionBackward;\n\n        api.Selection = WrappedSelection;\n\n        api.selectionPrototype = selProto;\n\n        api.addShimListener(function(win) {\n            if (typeof win.getSelection == \"undefined\") {\n                win.getSelection = function() {\n                    return getSelection(win);\n                };\n            }\n            win = null;\n        });\n    });\n    \n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Wait for document to load before initializing\n    var docReady = false;\n\n    var loadHandler = function(e) {\n        if (!docReady) {\n            docReady = true;\n            if (!api.initialized && api.config.autoInitialize) {\n                init();\n            }\n        }\n    };\n\n    if (isBrowser) {\n        // Test whether the document has already been loaded and initialize immediately if so\n        if (document.readyState == \"complete\") {\n            loadHandler();\n        } else {\n            if (isHostMethod(document, \"addEventListener\")) {\n                document.addEventListener(\"DOMContentLoaded\", loadHandler, false);\n            }\n\n            // Add a fallback in case the DOMContentLoaded event isn't supported\n            addListener(window, \"load\", loadHandler);\n        }\n    }\n\n    return api;\n}, this);\n\n/**\n * Class Applier module for Rangy.\n * Adds, removes and toggles classes on Ranges and Selections\n *\n * Part of Rangy, a cross-browser JavaScript range and selection library\n * https://github.com/timdown/rangy\n *\n * Depends on Rangy core.\n *\n * Copyright 2015, Tim Down\n * Licensed under the MIT license.\n * Version: 1.3.1-dev\n * Build date: 20 May 2015\n */\n;(function(factory, root) {\n    if (typeof define == \"function\" && define.amd) {\n        // AMD. Register as an anonymous module with a dependency on Rangy.\n        define([\"./rangy-core\"], factory);\n    } else if (typeof module != \"undefined\" && typeof exports == \"object\") {\n        // Node/CommonJS style\n        module.exports = factory( require(\"rangy\") );\n    } else {\n        // No AMD or CommonJS support so we use the rangy property of root (probably the global variable)\n        factory(root.rangy);\n    }\n})(function(rangy) {\n    rangy.createModule(\"ClassApplier\", [\"WrappedSelection\"], function(api, module) {\n        var dom = api.dom;\n        var DomPosition = dom.DomPosition;\n        var contains = dom.arrayContains;\n        var util = api.util;\n        var forEach = util.forEach;\n\n\n        var defaultTagName = \"span\";\n        var createElementNSSupported = util.isHostMethod(document, \"createElementNS\");\n\n        function each(obj, func) {\n            for (var i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    if (func(i, obj[i]) === false) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        function trim(str) {\n            return str.replace(/^\\s\\s*/, \"\").replace(/\\s\\s*$/, \"\");\n        }\n\n        function classNameContainsClass(fullClassName, className) {\n            return !!fullClassName && new RegExp(\"(?:^|\\\\s)\" + className + \"(?:\\\\s|$)\").test(fullClassName);\n        }\n\n        // Inefficient, inelegant nonsense for IE's svg element, which has no classList and non-HTML className implementation\n        function hasClass(el, className) {\n            if (typeof el.classList == \"object\") {\n                return el.classList.contains(className);\n            } else {\n                var classNameSupported = (typeof el.className == \"string\");\n                var elClass = classNameSupported ? el.className : el.getAttribute(\"class\");\n                return classNameContainsClass(elClass, className);\n            }\n        }\n\n        function addClass(el, className) {\n            if (typeof el.classList == \"object\") {\n                el.classList.add(className);\n            } else {\n                var classNameSupported = (typeof el.className == \"string\");\n                var elClass = classNameSupported ? el.className : el.getAttribute(\"class\");\n                if (elClass) {\n                    if (!classNameContainsClass(elClass, className)) {\n                        elClass += \" \" + className;\n                    }\n                } else {\n                    elClass = className;\n                }\n                if (classNameSupported) {\n                    el.className = elClass;\n                } else {\n                    el.setAttribute(\"class\", elClass);\n                }\n            }\n        }\n\n        var removeClass = (function() {\n            function replacer(matched, whiteSpaceBefore, whiteSpaceAfter) {\n                return (whiteSpaceBefore && whiteSpaceAfter) ? \" \" : \"\";\n            }\n\n            return function(el, className) {\n                if (typeof el.classList == \"object\") {\n                    el.classList.remove(className);\n                } else {\n                    var classNameSupported = (typeof el.className == \"string\");\n                    var elClass = classNameSupported ? el.className : el.getAttribute(\"class\");\n                    elClass = elClass.replace(new RegExp(\"(^|\\\\s)\" + className + \"(\\\\s|$)\"), replacer);\n                    if (classNameSupported) {\n                        el.className = elClass;\n                    } else {\n                        el.setAttribute(\"class\", elClass);\n                    }\n                }\n            };\n        })();\n\n        function getClass(el) {\n            var classNameSupported = (typeof el.className == \"string\");\n            return classNameSupported ? el.className : el.getAttribute(\"class\");\n        }\n\n        function sortClassName(className) {\n            return className && className.split(/\\s+/).sort().join(\" \");\n        }\n\n        function getSortedClassName(el) {\n            return sortClassName( getClass(el) );\n        }\n\n        function haveSameClasses(el1, el2) {\n            return getSortedClassName(el1) == getSortedClassName(el2);\n        }\n\n        function hasAllClasses(el, className) {\n            var classes = className.split(/\\s+/);\n            for (var i = 0, len = classes.length; i < len; ++i) {\n                if (!hasClass(el, trim(classes[i]))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function canTextBeStyled(textNode) {\n            var parent = textNode.parentNode;\n            return (parent && parent.nodeType == 1 && !/^(textarea|style|script|select|iframe)$/i.test(parent.nodeName));\n        }\n\n        function movePosition(position, oldParent, oldIndex, newParent, newIndex) {\n            var posNode = position.node, posOffset = position.offset;\n            var newNode = posNode, newOffset = posOffset;\n\n            if (posNode == newParent && posOffset > newIndex) {\n                ++newOffset;\n            }\n\n            if (posNode == oldParent && (posOffset == oldIndex  || posOffset == oldIndex + 1)) {\n                newNode = newParent;\n                newOffset += newIndex - oldIndex;\n            }\n\n            if (posNode == oldParent && posOffset > oldIndex + 1) {\n                --newOffset;\n            }\n\n            position.node = newNode;\n            position.offset = newOffset;\n        }\n\n        function movePositionWhenRemovingNode(position, parentNode, index) {\n            if (position.node == parentNode && position.offset > index) {\n                --position.offset;\n            }\n        }\n\n        function movePreservingPositions(node, newParent, newIndex, positionsToPreserve) {\n            // For convenience, allow newIndex to be -1 to mean \"insert at the end\".\n            if (newIndex == -1) {\n                newIndex = newParent.childNodes.length;\n            }\n\n            var oldParent = node.parentNode;\n            var oldIndex = dom.getNodeIndex(node);\n\n            forEach(positionsToPreserve, function(position) {\n                movePosition(position, oldParent, oldIndex, newParent, newIndex);\n            });\n\n            // Now actually move the node.\n            if (newParent.childNodes.length == newIndex) {\n                newParent.appendChild(node);\n            } else {\n                newParent.insertBefore(node, newParent.childNodes[newIndex]);\n            }\n        }\n\n        function removePreservingPositions(node, positionsToPreserve) {\n\n            var oldParent = node.parentNode;\n            var oldIndex = dom.getNodeIndex(node);\n\n            forEach(positionsToPreserve, function(position) {\n                movePositionWhenRemovingNode(position, oldParent, oldIndex);\n            });\n\n            dom.removeNode(node);\n        }\n\n        function moveChildrenPreservingPositions(node, newParent, newIndex, removeNode, positionsToPreserve) {\n            var child, children = [];\n            while ( (child = node.firstChild) ) {\n                movePreservingPositions(child, newParent, newIndex++, positionsToPreserve);\n                children.push(child);\n            }\n            if (removeNode) {\n                removePreservingPositions(node, positionsToPreserve);\n            }\n            return children;\n        }\n\n        function replaceWithOwnChildrenPreservingPositions(element, positionsToPreserve) {\n            return moveChildrenPreservingPositions(element, element.parentNode, dom.getNodeIndex(element), true, positionsToPreserve);\n        }\n\n        function rangeSelectsAnyText(range, textNode) {\n            var textNodeRange = range.cloneRange();\n            textNodeRange.selectNodeContents(textNode);\n\n            var intersectionRange = textNodeRange.intersection(range);\n            var text = intersectionRange ? intersectionRange.toString() : \"\";\n\n            return text != \"\";\n        }\n\n        function getEffectiveTextNodes(range) {\n            var nodes = range.getNodes([3]);\n\n            // Optimization as per issue 145\n\n            // Remove non-intersecting text nodes from the start of the range\n            var start = 0, node;\n            while ( (node = nodes[start]) && !rangeSelectsAnyText(range, node) ) {\n                ++start;\n            }\n\n            // Remove non-intersecting text nodes from the start of the range\n            var end = nodes.length - 1;\n            while ( (node = nodes[end]) && !rangeSelectsAnyText(range, node) ) {\n                --end;\n            }\n\n            return nodes.slice(start, end + 1);\n        }\n\n        function elementsHaveSameNonClassAttributes(el1, el2) {\n            if (el1.attributes.length != el2.attributes.length) return false;\n            for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {\n                attr1 = el1.attributes[i];\n                name = attr1.name;\n                if (name != \"class\") {\n                    attr2 = el2.attributes.getNamedItem(name);\n                    if ( (attr1 === null) != (attr2 === null) ) return false;\n                    if (attr1.specified != attr2.specified) return false;\n                    if (attr1.specified && attr1.nodeValue !== attr2.nodeValue) return false;\n                }\n            }\n            return true;\n        }\n\n        function elementHasNonClassAttributes(el, exceptions) {\n            for (var i = 0, len = el.attributes.length, attrName; i < len; ++i) {\n                attrName = el.attributes[i].name;\n                if ( !(exceptions && contains(exceptions, attrName)) && el.attributes[i].specified && attrName != \"class\") {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        var getComputedStyleProperty = dom.getComputedStyleProperty;\n        var isEditableElement = (function() {\n            var testEl = document.createElement(\"div\");\n            return typeof testEl.isContentEditable == \"boolean\" ?\n                function (node) {\n                    return node && node.nodeType == 1 && node.isContentEditable;\n                } :\n                function (node) {\n                    if (!node || node.nodeType != 1 || node.contentEditable == \"false\") {\n                        return false;\n                    }\n                    return node.contentEditable == \"true\" || isEditableElement(node.parentNode);\n                };\n        })();\n\n        function isEditingHost(node) {\n            var parent;\n            return node && node.nodeType == 1 &&\n                (( (parent = node.parentNode) && parent.nodeType == 9 && parent.designMode == \"on\") ||\n                (isEditableElement(node) && !isEditableElement(node.parentNode)));\n        }\n\n        function isEditable(node) {\n            return (isEditableElement(node) || (node.nodeType != 1 && isEditableElement(node.parentNode))) && !isEditingHost(node);\n        }\n\n        var inlineDisplayRegex = /^inline(-block|-table)?$/i;\n\n        function isNonInlineElement(node) {\n            return node && node.nodeType == 1 && !inlineDisplayRegex.test(getComputedStyleProperty(node, \"display\"));\n        }\n\n        // White space characters as defined by HTML 4 (http://www.w3.org/TR/html401/struct/text.html)\n        var htmlNonWhiteSpaceRegex = /[^\\r\\n\\t\\f \\u200B]/;\n\n        function isUnrenderedWhiteSpaceNode(node) {\n            if (node.data.length == 0) {\n                return true;\n            }\n            if (htmlNonWhiteSpaceRegex.test(node.data)) {\n                return false;\n            }\n            var cssWhiteSpace = getComputedStyleProperty(node.parentNode, \"whiteSpace\");\n            switch (cssWhiteSpace) {\n                case \"pre\":\n                case \"pre-wrap\":\n                case \"-moz-pre-wrap\":\n                    return false;\n                case \"pre-line\":\n                    if (/[\\r\\n]/.test(node.data)) {\n                        return false;\n                    }\n            }\n\n            // We now have a whitespace-only text node that may be rendered depending on its context. If it is adjacent to a\n            // non-inline element, it will not be rendered. This seems to be a good enough definition.\n            return isNonInlineElement(node.previousSibling) || isNonInlineElement(node.nextSibling);\n        }\n\n        function getRangeBoundaries(ranges) {\n            var positions = [], i, range;\n            for (i = 0; range = ranges[i++]; ) {\n                positions.push(\n                    new DomPosition(range.startContainer, range.startOffset),\n                    new DomPosition(range.endContainer, range.endOffset)\n                );\n            }\n            return positions;\n        }\n\n        function updateRangesFromBoundaries(ranges, positions) {\n            for (var i = 0, range, start, end, len = ranges.length; i < len; ++i) {\n                range = ranges[i];\n                start = positions[i * 2];\n                end = positions[i * 2 + 1];\n                range.setStartAndEnd(start.node, start.offset, end.node, end.offset);\n            }\n        }\n\n        function isSplitPoint(node, offset) {\n            if (dom.isCharacterDataNode(node)) {\n                if (offset == 0) {\n                    return !!node.previousSibling;\n                } else if (offset == node.length) {\n                    return !!node.nextSibling;\n                } else {\n                    return true;\n                }\n            }\n\n            return offset > 0 && offset < node.childNodes.length;\n        }\n\n        function splitNodeAt(node, descendantNode, descendantOffset, positionsToPreserve) {\n            var newNode, parentNode;\n            var splitAtStart = (descendantOffset == 0);\n\n            if (dom.isAncestorOf(descendantNode, node)) {\n                return node;\n            }\n\n            if (dom.isCharacterDataNode(descendantNode)) {\n                var descendantIndex = dom.getNodeIndex(descendantNode);\n                if (descendantOffset == 0) {\n                    descendantOffset = descendantIndex;\n                } else if (descendantOffset == descendantNode.length) {\n                    descendantOffset = descendantIndex + 1;\n                } else {\n                    throw module.createError(\"splitNodeAt() should not be called with offset in the middle of a data node (\" +\n                        descendantOffset + \" in \" + descendantNode.data);\n                }\n                descendantNode = descendantNode.parentNode;\n            }\n\n            if (isSplitPoint(descendantNode, descendantOffset)) {\n                // descendantNode is now guaranteed not to be a text or other character node\n                newNode = descendantNode.cloneNode(false);\n                parentNode = descendantNode.parentNode;\n                if (newNode.id) {\n                    newNode.removeAttribute(\"id\");\n                }\n                var child, newChildIndex = 0;\n\n                while ( (child = descendantNode.childNodes[descendantOffset]) ) {\n                    movePreservingPositions(child, newNode, newChildIndex++, positionsToPreserve);\n                }\n                movePreservingPositions(newNode, parentNode, dom.getNodeIndex(descendantNode) + 1, positionsToPreserve);\n                return (descendantNode == node) ? newNode : splitNodeAt(node, parentNode, dom.getNodeIndex(newNode), positionsToPreserve);\n            } else if (node != descendantNode) {\n                newNode = descendantNode.parentNode;\n\n                // Work out a new split point in the parent node\n                var newNodeIndex = dom.getNodeIndex(descendantNode);\n\n                if (!splitAtStart) {\n                    newNodeIndex++;\n                }\n                return splitNodeAt(node, newNode, newNodeIndex, positionsToPreserve);\n            }\n            return node;\n        }\n\n        function areElementsMergeable(el1, el2) {\n            return el1.namespaceURI == el2.namespaceURI &&\n                el1.tagName.toLowerCase() == el2.tagName.toLowerCase() &&\n                haveSameClasses(el1, el2) &&\n                elementsHaveSameNonClassAttributes(el1, el2) &&\n                getComputedStyleProperty(el1, \"display\") == \"inline\" &&\n                getComputedStyleProperty(el2, \"display\") == \"inline\";\n        }\n\n        function createAdjacentMergeableTextNodeGetter(forward) {\n            var siblingPropName = forward ? \"nextSibling\" : \"previousSibling\";\n\n            return function(textNode, checkParentElement) {\n                var el = textNode.parentNode;\n                var adjacentNode = textNode[siblingPropName];\n                if (adjacentNode) {\n                    // Can merge if the node's previous/next sibling is a text node\n                    if (adjacentNode && adjacentNode.nodeType == 3) {\n                        return adjacentNode;\n                    }\n                } else if (checkParentElement) {\n                    // Compare text node parent element with its sibling\n                    adjacentNode = el[siblingPropName];\n                    if (adjacentNode && adjacentNode.nodeType == 1 && areElementsMergeable(el, adjacentNode)) {\n                        var adjacentNodeChild = adjacentNode[forward ? \"firstChild\" : \"lastChild\"];\n                        if (adjacentNodeChild && adjacentNodeChild.nodeType == 3) {\n                            return adjacentNodeChild;\n                        }\n                    }\n                }\n                return null;\n            };\n        }\n\n        var getPreviousMergeableTextNode = createAdjacentMergeableTextNodeGetter(false),\n            getNextMergeableTextNode = createAdjacentMergeableTextNodeGetter(true);\n\n    \n        function Merge(firstNode) {\n            this.isElementMerge = (firstNode.nodeType == 1);\n            this.textNodes = [];\n            var firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;\n            if (firstTextNode) {\n                this.textNodes[0] = firstTextNode;\n            }\n        }\n\n        Merge.prototype = {\n            doMerge: function(positionsToPreserve) {\n                var textNodes = this.textNodes;\n                var firstTextNode = textNodes[0];\n                if (textNodes.length > 1) {\n                    var firstTextNodeIndex = dom.getNodeIndex(firstTextNode);\n                    var textParts = [], combinedTextLength = 0, textNode, parent;\n                    forEach(textNodes, function(textNode, i) {\n                        parent = textNode.parentNode;\n                        if (i > 0) {\n                            parent.removeChild(textNode);\n                            if (!parent.hasChildNodes()) {\n                                dom.removeNode(parent);\n                            }\n                            if (positionsToPreserve) {\n                                forEach(positionsToPreserve, function(position) {\n                                    // Handle case where position is inside the text node being merged into a preceding node\n                                    if (position.node == textNode) {\n                                        position.node = firstTextNode;\n                                        position.offset += combinedTextLength;\n                                    }\n                                    // Handle case where both text nodes precede the position within the same parent node\n                                    if (position.node == parent && position.offset > firstTextNodeIndex) {\n                                        --position.offset;\n                                        if (position.offset == firstTextNodeIndex + 1 && i < len - 1) {\n                                            position.node = firstTextNode;\n                                            position.offset = combinedTextLength;\n                                        }\n                                    }\n                                });\n                            }\n                        }\n                        textParts[i] = textNode.data;\n                        combinedTextLength += textNode.data.length;\n                    });\n                    firstTextNode.data = textParts.join(\"\");\n                }\n                return firstTextNode.data;\n            },\n\n            getLength: function() {\n                var i = this.textNodes.length, len = 0;\n                while (i--) {\n                    len += this.textNodes[i].length;\n                }\n                return len;\n            },\n\n            toString: function() {\n                var textParts = [];\n                forEach(this.textNodes, function(textNode, i) {\n                    textParts[i] = \"'\" + textNode.data + \"'\";\n                });\n                return \"[Merge(\" + textParts.join(\",\") + \")]\";\n            }\n        };\n\n        var optionProperties = [\"elementTagName\", \"ignoreWhiteSpace\", \"applyToEditableOnly\", \"useExistingElements\",\n            \"removeEmptyElements\", \"onElementCreate\"];\n\n        // TODO: Populate this with every attribute name that corresponds to a property with a different name. Really??\n        var attrNamesForProperties = {};\n\n        function ClassApplier(className, options, tagNames) {\n            var normalize, i, len, propName, applier = this;\n            applier.cssClass = applier.className = className; // cssClass property is for backward compatibility\n\n            var elementPropertiesFromOptions = null, elementAttributes = {};\n\n            // Initialize from options object\n            if (typeof options == \"object\" && options !== null) {\n                if (typeof options.elementTagName !== \"undefined\") {\n                    options.elementTagName = options.elementTagName.toLowerCase();\n                }\n                tagNames = options.tagNames;\n                elementPropertiesFromOptions = options.elementProperties;\n                elementAttributes = options.elementAttributes;\n\n                for (i = 0; propName = optionProperties[i++]; ) {\n                    if (options.hasOwnProperty(propName)) {\n                        applier[propName] = options[propName];\n                    }\n                }\n                normalize = options.normalize;\n            } else {\n                normalize = options;\n            }\n\n            // Backward compatibility: the second parameter can also be a Boolean indicating to normalize after unapplying\n            applier.normalize = (typeof normalize == \"undefined\") ? true : normalize;\n\n            // Initialize element properties and attribute exceptions\n            applier.attrExceptions = [];\n            var el = document.createElement(applier.elementTagName);\n            applier.elementProperties = applier.copyPropertiesToElement(elementPropertiesFromOptions, el, true);\n            each(elementAttributes, function(attrName, attrValue) {\n                applier.attrExceptions.push(attrName);\n                // Ensure each attribute value is a string\n                elementAttributes[attrName] = \"\" + attrValue;\n            });\n            applier.elementAttributes = elementAttributes;\n\n            applier.elementSortedClassName = applier.elementProperties.hasOwnProperty(\"className\") ?\n                sortClassName(applier.elementProperties.className + \" \" + className) : className;\n\n            // Initialize tag names\n            applier.applyToAnyTagName = false;\n            var type = typeof tagNames;\n            if (type == \"string\") {\n                if (tagNames == \"*\") {\n                    applier.applyToAnyTagName = true;\n                } else {\n                    applier.tagNames = trim(tagNames.toLowerCase()).split(/\\s*,\\s*/);\n                }\n            } else if (type == \"object\" && typeof tagNames.length == \"number\") {\n                applier.tagNames = [];\n                for (i = 0, len = tagNames.length; i < len; ++i) {\n                    if (tagNames[i] == \"*\") {\n                        applier.applyToAnyTagName = true;\n                    } else {\n                        applier.tagNames.push(tagNames[i].toLowerCase());\n                    }\n                }\n            } else {\n                applier.tagNames = [applier.elementTagName];\n            }\n        }\n\n        ClassApplier.prototype = {\n            elementTagName: defaultTagName,\n            elementProperties: {},\n            elementAttributes: {},\n            ignoreWhiteSpace: true,\n            applyToEditableOnly: false,\n            useExistingElements: true,\n            removeEmptyElements: true,\n            onElementCreate: null,\n\n            copyPropertiesToElement: function(props, el, createCopy) {\n                var s, elStyle, elProps = {}, elPropsStyle, propValue, elPropValue, attrName;\n\n                for (var p in props) {\n                    if (props.hasOwnProperty(p)) {\n                        propValue = props[p];\n                        elPropValue = el[p];\n\n                        // Special case for class. The copied properties object has the applier's class as well as its own\n                        // to simplify checks when removing styling elements\n                        if (p == \"className\") {\n                            addClass(el, propValue);\n                            addClass(el, this.className);\n                            el[p] = sortClassName(el[p]);\n                            if (createCopy) {\n                                elProps[p] = propValue;\n                            }\n                        }\n\n                        // Special case for style\n                        else if (p == \"style\") {\n                            elStyle = elPropValue;\n                            if (createCopy) {\n                                elProps[p] = elPropsStyle = {};\n                            }\n                            for (s in props[p]) {\n                                if (props[p].hasOwnProperty(s)) {\n                                    elStyle[s] = propValue[s];\n                                    if (createCopy) {\n                                        elPropsStyle[s] = elStyle[s];\n                                    }\n                                }\n                            }\n                            this.attrExceptions.push(p);\n                        } else {\n                            el[p] = propValue;\n                            // Copy the property back from the dummy element so that later comparisons to check whether\n                            // elements may be removed are checking against the right value. For example, the href property\n                            // of an element returns a fully qualified URL even if it was previously assigned a relative\n                            // URL.\n                            if (createCopy) {\n                                elProps[p] = el[p];\n\n                                // Not all properties map to identically-named attributes\n                                attrName = attrNamesForProperties.hasOwnProperty(p) ? attrNamesForProperties[p] : p;\n                                this.attrExceptions.push(attrName);\n                            }\n                        }\n                    }\n                }\n\n                return createCopy ? elProps : \"\";\n            },\n\n            copyAttributesToElement: function(attrs, el) {\n                for (var attrName in attrs) {\n                    if (attrs.hasOwnProperty(attrName) && !/^class(?:Name)?$/i.test(attrName)) {\n                        el.setAttribute(attrName, attrs[attrName]);\n                    }\n                }\n            },\n\n            appliesToElement: function(el) {\n                return contains(this.tagNames, el.tagName.toLowerCase());\n            },\n\n            getEmptyElements: function(range) {\n                var applier = this;\n                return range.getNodes([1], function(el) {\n                    return applier.appliesToElement(el) && !el.hasChildNodes();\n                });\n            },\n\n            hasClass: function(node) {\n                return node.nodeType == 1 &&\n                    (this.applyToAnyTagName || this.appliesToElement(node)) &&\n                    hasClass(node, this.className);\n            },\n\n            getSelfOrAncestorWithClass: function(node) {\n                while (node) {\n                    if (this.hasClass(node)) {\n                        return node;\n                    }\n                    node = node.parentNode;\n                }\n                return null;\n            },\n\n            isModifiable: function(node) {\n                return !this.applyToEditableOnly || isEditable(node);\n            },\n\n            // White space adjacent to an unwrappable node can be ignored for wrapping\n            isIgnorableWhiteSpaceNode: function(node) {\n                return this.ignoreWhiteSpace && node && node.nodeType == 3 && isUnrenderedWhiteSpaceNode(node);\n            },\n\n            // Normalizes nodes after applying a class to a Range.\n            postApply: function(textNodes, range, positionsToPreserve, isUndo) {\n                var firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];\n\n                var merges = [], currentMerge;\n\n                var rangeStartNode = firstNode, rangeEndNode = lastNode;\n                var rangeStartOffset = 0, rangeEndOffset = lastNode.length;\n\n                var textNode, precedingTextNode;\n\n                // Check for every required merge and create a Merge object for each\n                forEach(textNodes, function(textNode) {\n                    precedingTextNode = getPreviousMergeableTextNode(textNode, !isUndo);\n                    if (precedingTextNode) {\n                        if (!currentMerge) {\n                            currentMerge = new Merge(precedingTextNode);\n                            merges.push(currentMerge);\n                        }\n                        currentMerge.textNodes.push(textNode);\n                        if (textNode === firstNode) {\n                            rangeStartNode = currentMerge.textNodes[0];\n                            rangeStartOffset = rangeStartNode.length;\n                        }\n                        if (textNode === lastNode) {\n                            rangeEndNode = currentMerge.textNodes[0];\n                            rangeEndOffset = currentMerge.getLength();\n                        }\n                    } else {\n                        currentMerge = null;\n                    }\n                });\n\n                // Test whether the first node after the range needs merging\n                var nextTextNode = getNextMergeableTextNode(lastNode, !isUndo);\n\n                if (nextTextNode) {\n                    if (!currentMerge) {\n                        currentMerge = new Merge(lastNode);\n                        merges.push(currentMerge);\n                    }\n                    currentMerge.textNodes.push(nextTextNode);\n                }\n\n                // Apply the merges\n                if (merges.length) {\n                    for (i = 0, len = merges.length; i < len; ++i) {\n                        merges[i].doMerge(positionsToPreserve);\n                    }\n\n                    // Set the range boundaries\n                    range.setStartAndEnd(rangeStartNode, rangeStartOffset, rangeEndNode, rangeEndOffset);\n                }\n            },\n\n            createContainer: function(parentNode) {\n                var doc = dom.getDocument(parentNode);\n                var namespace;\n                var el = createElementNSSupported && !dom.isHtmlNamespace(parentNode) && (namespace = parentNode.namespaceURI) ?\n                    doc.createElementNS(parentNode.namespaceURI, this.elementTagName) :\n                    doc.createElement(this.elementTagName);\n\n                this.copyPropertiesToElement(this.elementProperties, el, false);\n                this.copyAttributesToElement(this.elementAttributes, el);\n                addClass(el, this.className);\n                if (this.onElementCreate) {\n                    this.onElementCreate(el, this);\n                }\n                return el;\n            },\n\n            elementHasProperties: function(el, props) {\n                var applier = this;\n                return each(props, function(p, propValue) {\n                    if (p == \"className\") {\n                        // For checking whether we should reuse an existing element, we just want to check that the element\n                        // has all the classes specified in the className property. When deciding whether the element is\n                        // removable when unapplying a class, there is separate special handling to check whether the\n                        // element has extra classes so the same simple check will do.\n                        return hasAllClasses(el, propValue);\n                    } else if (typeof propValue == \"object\") {\n                        if (!applier.elementHasProperties(el[p], propValue)) {\n                            return false;\n                        }\n                    } else if (el[p] !== propValue) {\n                        return false;\n                    }\n                });\n            },\n\n            elementHasAttributes: function(el, attrs) {\n                return each(attrs, function(name, value) {\n                    if (el.getAttribute(name) !== value) {\n                        return false;\n                    }\n                });\n            },\n\n            applyToTextNode: function(textNode, positionsToPreserve) {\n\n                // Check whether the text node can be styled. Text within a <style> or <script> element, for example,\n                // should not be styled. See issue 283.\n                if (canTextBeStyled(textNode)) {\n                    var parent = textNode.parentNode;\n                    if (parent.childNodes.length == 1 &&\n                        this.useExistingElements &&\n                        this.appliesToElement(parent) &&\n                        this.elementHasProperties(parent, this.elementProperties) &&\n                        this.elementHasAttributes(parent, this.elementAttributes)) {\n\n                        addClass(parent, this.className);\n                    } else {\n                        var textNodeParent = textNode.parentNode;\n                        var el = this.createContainer(textNodeParent);\n                        textNodeParent.insertBefore(el, textNode);\n                        el.appendChild(textNode);\n                    }\n                }\n\n            },\n\n            isRemovable: function(el) {\n                return el.tagName.toLowerCase() == this.elementTagName &&\n                    getSortedClassName(el) == this.elementSortedClassName &&\n                    this.elementHasProperties(el, this.elementProperties) &&\n                    !elementHasNonClassAttributes(el, this.attrExceptions) &&\n                    this.elementHasAttributes(el, this.elementAttributes) &&\n                    this.isModifiable(el);\n            },\n\n            isEmptyContainer: function(el) {\n                var childNodeCount = el.childNodes.length;\n                return el.nodeType == 1 &&\n                    this.isRemovable(el) &&\n                    (childNodeCount == 0 || (childNodeCount == 1 && this.isEmptyContainer(el.firstChild)));\n            },\n\n            removeEmptyContainers: function(range) {\n                var applier = this;\n                var nodesToRemove = range.getNodes([1], function(el) {\n                    return applier.isEmptyContainer(el);\n                });\n\n                var rangesToPreserve = [range];\n                var positionsToPreserve = getRangeBoundaries(rangesToPreserve);\n\n                forEach(nodesToRemove, function(node) {\n                    removePreservingPositions(node, positionsToPreserve);\n                });\n\n                // Update the range from the preserved boundary positions\n                updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);\n            },\n\n            undoToTextNode: function(textNode, range, ancestorWithClass, positionsToPreserve) {\n                if (!range.containsNode(ancestorWithClass)) {\n                    // Split out the portion of the ancestor from which we can remove the class\n                    //var parent = ancestorWithClass.parentNode, index = dom.getNodeIndex(ancestorWithClass);\n                    var ancestorRange = range.cloneRange();\n                    ancestorRange.selectNode(ancestorWithClass);\n                    if (ancestorRange.isPointInRange(range.endContainer, range.endOffset)) {\n                        splitNodeAt(ancestorWithClass, range.endContainer, range.endOffset, positionsToPreserve);\n                        range.setEndAfter(ancestorWithClass);\n                    }\n                    if (ancestorRange.isPointInRange(range.startContainer, range.startOffset)) {\n                        ancestorWithClass = splitNodeAt(ancestorWithClass, range.startContainer, range.startOffset, positionsToPreserve);\n                    }\n                }\n\n                if (this.isRemovable(ancestorWithClass)) {\n                    replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);\n                } else {\n                    removeClass(ancestorWithClass, this.className);\n                }\n            },\n\n            splitAncestorWithClass: function(container, offset, positionsToPreserve) {\n                var ancestorWithClass = this.getSelfOrAncestorWithClass(container);\n                if (ancestorWithClass) {\n                    splitNodeAt(ancestorWithClass, container, offset, positionsToPreserve);\n                }\n            },\n\n            undoToAncestor: function(ancestorWithClass, positionsToPreserve) {\n                if (this.isRemovable(ancestorWithClass)) {\n                    replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);\n                } else {\n                    removeClass(ancestorWithClass, this.className);\n                }\n            },\n\n            applyToRange: function(range, rangesToPreserve) {\n                var applier = this;\n                rangesToPreserve = rangesToPreserve || [];\n\n                // Create an array of range boundaries to preserve\n                var positionsToPreserve = getRangeBoundaries(rangesToPreserve || []);\n\n                range.splitBoundariesPreservingPositions(positionsToPreserve);\n\n                // Tidy up the DOM by removing empty containers\n                if (applier.removeEmptyElements) {\n                    applier.removeEmptyContainers(range);\n                }\n\n                var textNodes = getEffectiveTextNodes(range);\n\n                if (textNodes.length) {\n                    forEach(textNodes, function(textNode) {\n                        if (!applier.isIgnorableWhiteSpaceNode(textNode) && !applier.getSelfOrAncestorWithClass(textNode) &&\n                                applier.isModifiable(textNode)) {\n                            applier.applyToTextNode(textNode, positionsToPreserve);\n                        }\n                    });\n                    var lastTextNode = textNodes[textNodes.length - 1];\n                    range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);\n                    if (applier.normalize) {\n                        applier.postApply(textNodes, range, positionsToPreserve, false);\n                    }\n\n                    // Update the ranges from the preserved boundary positions\n                    updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);\n                }\n\n                // Apply classes to any appropriate empty elements\n                var emptyElements = applier.getEmptyElements(range);\n\n                forEach(emptyElements, function(el) {\n                    addClass(el, applier.className);\n                });\n            },\n\n            applyToRanges: function(ranges) {\n\n                var i = ranges.length;\n                while (i--) {\n                    this.applyToRange(ranges[i], ranges);\n                }\n\n\n                return ranges;\n            },\n\n            applyToSelection: function(win) {\n                var sel = api.getSelection(win);\n                sel.setRanges( this.applyToRanges(sel.getAllRanges()) );\n            },\n\n            undoToRange: function(range, rangesToPreserve) {\n                var applier = this;\n                // Create an array of range boundaries to preserve\n                rangesToPreserve = rangesToPreserve || [];\n                var positionsToPreserve = getRangeBoundaries(rangesToPreserve);\n\n\n                range.splitBoundariesPreservingPositions(positionsToPreserve);\n\n                // Tidy up the DOM by removing empty containers\n                if (applier.removeEmptyElements) {\n                    applier.removeEmptyContainers(range, positionsToPreserve);\n                }\n\n                var textNodes = getEffectiveTextNodes(range);\n                var textNode, ancestorWithClass;\n                var lastTextNode = textNodes[textNodes.length - 1];\n\n                if (textNodes.length) {\n                    applier.splitAncestorWithClass(range.endContainer, range.endOffset, positionsToPreserve);\n                    applier.splitAncestorWithClass(range.startContainer, range.startOffset, positionsToPreserve);\n                    for (var i = 0, len = textNodes.length; i < len; ++i) {\n                        textNode = textNodes[i];\n                        ancestorWithClass = applier.getSelfOrAncestorWithClass(textNode);\n                        if (ancestorWithClass && applier.isModifiable(textNode)) {\n                            applier.undoToAncestor(ancestorWithClass, positionsToPreserve);\n                        }\n                    }\n                    // Ensure the range is still valid\n                    range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);\n\n\n                    if (applier.normalize) {\n                        applier.postApply(textNodes, range, positionsToPreserve, true);\n                    }\n\n                    // Update the ranges from the preserved boundary positions\n                    updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);\n                }\n\n                // Remove class from any appropriate empty elements\n                var emptyElements = applier.getEmptyElements(range);\n\n                forEach(emptyElements, function(el) {\n                    removeClass(el, applier.className);\n                });\n            },\n\n            undoToRanges: function(ranges) {\n                // Get ranges returned in document order\n                var i = ranges.length;\n\n                while (i--) {\n                    this.undoToRange(ranges[i], ranges);\n                }\n\n                return ranges;\n            },\n\n            undoToSelection: function(win) {\n                var sel = api.getSelection(win);\n                var ranges = api.getSelection(win).getAllRanges();\n                this.undoToRanges(ranges);\n                sel.setRanges(ranges);\n            },\n\n            isAppliedToRange: function(range) {\n                if (range.collapsed || range.toString() == \"\") {\n                    return !!this.getSelfOrAncestorWithClass(range.commonAncestorContainer);\n                } else {\n                    var textNodes = range.getNodes( [3] );\n                    if (textNodes.length)\n                    for (var i = 0, textNode; textNode = textNodes[i++]; ) {\n                        if (!this.isIgnorableWhiteSpaceNode(textNode) && rangeSelectsAnyText(range, textNode) &&\n                                this.isModifiable(textNode) && !this.getSelfOrAncestorWithClass(textNode)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            },\n\n            isAppliedToRanges: function(ranges) {\n                var i = ranges.length;\n                if (i == 0) {\n                    return false;\n                }\n                while (i--) {\n                    if (!this.isAppliedToRange(ranges[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            },\n\n            isAppliedToSelection: function(win) {\n                var sel = api.getSelection(win);\n                return this.isAppliedToRanges(sel.getAllRanges());\n            },\n\n            toggleRange: function(range) {\n                if (this.isAppliedToRange(range)) {\n                    this.undoToRange(range);\n                } else {\n                    this.applyToRange(range);\n                }\n            },\n\n            toggleSelection: function(win) {\n                if (this.isAppliedToSelection(win)) {\n                    this.undoToSelection(win);\n                } else {\n                    this.applyToSelection(win);\n                }\n            },\n\n            getElementsWithClassIntersectingRange: function(range) {\n                var elements = [];\n                var applier = this;\n                range.getNodes([3], function(textNode) {\n                    var el = applier.getSelfOrAncestorWithClass(textNode);\n                    if (el && !contains(elements, el)) {\n                        elements.push(el);\n                    }\n                });\n                return elements;\n            },\n\n            detach: function() {}\n        };\n\n        function createClassApplier(className, options, tagNames) {\n            return new ClassApplier(className, options, tagNames);\n        }\n\n        ClassApplier.util = {\n            hasClass: hasClass,\n            addClass: addClass,\n            removeClass: removeClass,\n            getClass: getClass,\n            hasSameClasses: haveSameClasses,\n            hasAllClasses: hasAllClasses,\n            replaceWithOwnChildren: replaceWithOwnChildrenPreservingPositions,\n            elementsHaveSameNonClassAttributes: elementsHaveSameNonClassAttributes,\n            elementHasNonClassAttributes: elementHasNonClassAttributes,\n            splitNodeAt: splitNodeAt,\n            isEditableElement: isEditableElement,\n            isEditingHost: isEditingHost,\n            isEditable: isEditable\n        };\n\n        api.CssClassApplier = api.ClassApplier = ClassApplier;\n        api.createClassApplier = createClassApplier;\n        util.createAliasForDeprecatedMethod(api, \"createCssClassApplier\", \"createClassApplier\", module);\n    });\n    \n    return rangy;\n}, this);\n\n\n\n\n\n/*\n * Undo.js - A undo/redo framework for JavaScript\n * \n * http://jzaefferer.github.com/undo\n *\n * Copyright (c) 2011 Jrn Zaefferer\n * \n * MIT licensed.\n */\n;(function() {\n\n// based on Backbone.js' inherits\t\nvar ctor = function(){};\nvar inherits = function(parent, protoProps) {\n\tvar child;\n\n\tif (protoProps && protoProps.hasOwnProperty('constructor')) {\n\t\tchild = protoProps.constructor;\n\t} else {\n\t\tchild = function(){ return parent.apply(this, arguments); };\n\t}\n\n\tctor.prototype = parent.prototype;\n\tchild.prototype = new ctor();\n\t\n\tif (protoProps) extend(child.prototype, protoProps);\n\t\n\tchild.prototype.constructor = child;\n\tchild.__super__ = parent.prototype;\n\treturn child;\n};\n\nfunction extend(target, ref) {\n\tvar name, value;\n\tfor ( name in ref ) {\n\t\tvalue = ref[name];\n\t\tif (value !== undefined) {\n\t\t\ttarget[ name ] = value;\n\t\t}\n\t}\n\treturn target;\n};\n\nvar Undo = {\n\tversion: '0.1.15'\n};\n\nUndo.Stack = function() {\n\tthis.commands = [];\n\tthis.stackPosition = -1;\n\tthis.savePosition = -1;\n};\n\nextend(Undo.Stack.prototype, {\n\texecute: function(command) {\n\t\tthis._clearRedo();\n\t\tcommand.execute();\n\t\tthis.commands.push(command);\n\t\tthis.stackPosition++;\n\t\tthis.changed();\n\t},\n\tundo: function() {\n\t\tthis.commands[this.stackPosition].undo();\n\t\tthis.stackPosition--;\n\t\tthis.changed();\n\t},\n\tcanUndo: function() {\n\t\treturn this.stackPosition >= 0;\n\t},\n\tredo: function() {\n\t\tthis.stackPosition++;\n\t\tthis.commands[this.stackPosition].redo();\n\t\tthis.changed();\n\t},\n\tcanRedo: function() {\n\t\treturn this.stackPosition < this.commands.length - 1;\n\t},\n\tsave: function() {\n\t\tthis.savePosition = this.stackPosition;\n\t\tthis.changed();\n\t},\n\tdirty: function() {\n\t\treturn this.stackPosition != this.savePosition;\n\t},\n\t_clearRedo: function() {\n\t\t// TODO there's probably a more efficient way for this\n\t\tthis.commands = this.commands.slice(0, this.stackPosition + 1);\n\t},\n\tchanged: function() {\n\t\t// do nothing, override\n\t}\n});\n\nUndo.Command = function(name) {\n\tthis.name = name;\n};\n\nvar up = new Error(\"override me!\");\n\nextend(Undo.Command.prototype, {\n\texecute: function() {\n\t\tthrow up;\n\t},\n\tundo: function() {\n\t\tthrow up;\n\t},\n\tredo: function() {\n\t\tthis.execute();\n\t}\n});\n\nUndo.Command.extend = function(protoProps) {\n\tvar child = inherits(this, protoProps);\n\tchild.extend = Undo.Command.extend;\n\treturn child;\n};\n\t\n// AMD support\nif (typeof define === \"function\" && define.amd) {\n\t// Define as an anonymous module\n\tdefine(Undo);\n} else if(typeof module != \"undefined\" && module.exports){\n\tmodule.exports = Undo \n}else {\n\tthis.Undo = Undo;\n}\n}).call(this);\n\n\n\n(function(e,h){var g=e.rangy||null,c=e.Undo||null,f=e.Key={backspace:8,tab:9,enter:13,shift:16,ctrl:17,alt:18,pause:19,capsLock:20,escape:27,pageUp:33,pageDown:34,end:35,home:36,leftArrow:37,upArrow:38,rightArrow:39,downArrow:40,insert:45,\"delete\":46,\"0\":48,\"1\":49,\"2\":50,\"3\":51,\"4\":52,\"5\":53,\"6\":54,\"7\":55,\"8\":56,\"9\":57,a:65,b:66,c:67,d:68,e:69,f:70,g:71,h:72,i:73,j:74,k:75,l:76,m:77,n:78,o:79,p:80,q:81,r:82,s:83,t:84,u:85,v:86,w:87,x:88,y:89,z:90,leftWindow:91,rightWindowKey:92,select:93,numpad0:96,numpad1:97,numpad2:98,numpad3:99,numpad4:100,numpad5:101,numpad6:102,numpad7:103,numpad8:104,numpad9:105,multiply:106,add:107,subtract:109,decimalPoint:110,divide:111,f1:112,f2:113,f3:114,f4:115,f5:116,f6:117,f7:118,f8:119,f9:120,f10:121,f11:122,f12:123,numLock:144,scrollLock:145,semiColon:186,equalSign:187,comma:188,dash:189,period:190,forwardSlash:191,graveAccent:192,openBracket:219,backSlash:220,closeBracket:221,singleQuote:222},b=(function(){var d=function(q){var v=this,r=a.deepExtend({},d.defaultSettings),n=this.settings=a.deepExtend(r,q),k=new d.Cache(),t=new d.Selection(),o=new d.Action(this),u=new d.Cursor(this),s=new d.Undoable(this),m,l,p;for(p in r){if(r.hasOwnProperty(p)){if(typeof r[p]!==\"object\"&&r.hasOwnProperty(p)&&n.element.getAttribute(\"data-medium-\"+f)){l=n.element.getAttribute(\"data-medium-\"+f);if(l.toLowerCase()===\"false\"||l.toLowerCase()===\"true\"){l=l.toLowerCase()===\"true\"}n[p]=l}}}if(n.modifiers){for(p in n.modifiers){if(n.modifiers.hasOwnProperty(p)){if(typeof(f[p])!==\"undefined\"){n.modifiers[f[p]]=n.modifiers[p]}}}}if(n.keyContext){for(p in n.keyContext){if(n.keyContext.hasOwnProperty(p)){if(typeof(f[p])!==\"undefined\"){n.keyContext[f[p]]=n.keyContext[p]}}}}m=n.element;m.contentEditable=true;m.className+=(\" \"+n.cssClasses.editor)+(\" \"+n.cssClasses.editor+\"-\"+n.mode);n.tags=(n.tags||{});if(n.tags.outerLevel){n.tags.outerLevel=n.tags.outerLevel.concat([n.tags.paragraph,n.tags.horizontalRule])}this.settings=n;this.element=m;m.medium=this;this.action=o;this.cache=k;this.cursor=u;this.utils=a;this.selection=t;v.clean();v.placeholders();o.preserveElementFocus();this.dirty=false;this.undoable=s;this.makeUndoable=s.makeUndoable;if(n.drag){v.drag=new d.Drag(v);v.drag.setup()}o.setup();k.initialized=true;this.makeUndoable(true)};d.prototype={placeholders:function(){if(!e.getComputedStyle){return}var u=this.settings,p=this.placeholder||(this.placeholder=h.createElement(\"div\")),m=this.element,k=p.style,q=e.getComputedStyle(m,null),o=function(s){return q.getPropertyValue(s)},r=a.text(m),t=this.cursor,n=m.children.length,l=d.activeElement===m;m.placeholder=p;if(!l&&r.length<1&&n<2){if(m.placeHolderActive){return}if(!m.innerHTML.match(\"<\"+u.tags.paragraph)){m.innerHTML=\"\"}if(u.placeholder.length>0){if(!p.setup){p.setup=true;k.background=o(\"background\");k.backgroundColor=o(\"background-color\");k.fontSize=o(\"font-size\");k.color=q.color;k.marginTop=o(\"margin-top\");k.marginBottom=o(\"margin-bottom\");k.marginLeft=o(\"margin-left\");k.marginRight=o(\"margin-right\");k.paddingTop=o(\"padding-top\");k.paddingBottom=o(\"padding-bottom\");k.paddingLeft=o(\"padding-left\");k.paddingRight=o(\"padding-right\");k.borderTopWidth=o(\"border-top-width\");k.borderTopColor=o(\"border-top-color\");k.borderTopStyle=o(\"border-top-style\");k.borderBottomWidth=o(\"border-bottom-width\");k.borderBottomColor=o(\"border-bottom-color\");k.borderBottomStyle=o(\"border-bottom-style\");k.borderLeftWidth=o(\"border-left-width\");k.borderLeftColor=o(\"border-left-color\");k.borderLeftStyle=o(\"border-left-style\");k.borderRightWidth=o(\"border-right-width\");k.borderRightColor=o(\"border-right-color\");k.borderRightStyle=o(\"border-right-style\");p.className=u.cssClasses.placeholder+\" \"+u.cssClasses.placeholder+\"-\"+u.mode;p.innerHTML=\"<div>\"+u.placeholder+\"</div>\";m.parentNode.insertBefore(p,m)}m.className+=\" \"+u.cssClasses.clear;k.display=\"\";k.minHeight=m.clientHeight+\"px\";k.minWidth=m.clientWidth+\"px\";if(u.mode!==d.inlineMode&&u.mode!==d.inlineRichMode){this.setupContents();if(n===0&&m.firstChild){t.set(this,0,m.firstChild)}}}m.placeHolderActive=true}else{if(m.placeHolderActive){m.placeHolderActive=false;k.display=\"none\";m.className=a.trim(m.className.replace(u.cssClasses.clear,\"\"));this.setupContents()}}},clean:function(k){var w=this.settings,n=w.cssClasses.placeholder,o=(w.attributes||{}).remove||[],x=w.tags||{},r=x.outerLevel||null,t=x.innerLevel||null,y={},v={},q=(x.paragraph||\"\").toUpperCase(),m=this.html,p,u,l;k=k||w.element;if(w.mode===d.inlineRichMode){r=w.tags.innerLevel}if(r!==null){for(l=0;l<r.length;l++){y[r[l].toUpperCase()]=true}}if(t!==null){for(l=0;l<t.length;l++){v[t[l].toUpperCase()]=true}}a.traverseAll(k,{element:function(E,z,C,A){var D=E.nodeName,s=true,B;for(l=0;l<o.length;l++){p=o[l];if(E.hasAttribute(p)){B=E.getAttribute(p);if(B!==n&&(!B.match(\"medium-\")&&p===\"class\")){E.removeAttribute(p)}}}if(r===null&&t===null){return}if(C===1&&y[D]!==undefined){s=false}else{if(C>1&&v[D]!==undefined){s=false}}if(s){if(e.getComputedStyle(E,null).getPropertyValue(\"display\")===\"block\"){if(q.length>0&&q!==D){a.changeTag(E,q)}if(C>1){while(A.childNodes.length>z){A.parentNode.insertBefore(A.lastChild,A.nextSibling)}}}else{switch(D){case\"BR\":if(E===E.parentNode.lastChild){if(E===E.parentNode.firstChild){break}u=h.createTextNode(\"\");u.innerHTML=\"&nbsp\";E.parentNode.insertBefore(u,E);break}default:while(E.firstChild!==null){E.parentNode.insertBefore(E.firstChild,E)}a.detachNode(E);break}}}}})},insertHtml:function(l,o,m){var k=(new d.Html(this,l)).insert(this.settings.beforeInsertHtml),n=k[k.length-1];if(m===true){a.triggerEvent(this.element,\"change\")}if(o){o.apply(k)}switch(n.nodeName){case\"UL\":case\"OL\":case\"DL\":if(n.lastChild!==null){this.cursor.moveCursorToEnd(n.lastChild);break}default:this.cursor.moveCursorToEnd(n)}return this},addTag:function(l,k,m,o){if(!this.settings.beforeAddTag(l,k,m,o)){var p=h.createElement(l),n;if(typeof m!==\"undefined\"&&m===false){p.contentEditable=false}if(p.innerHTML.length==0){p.innerHTML=\" \"}if(o&&o.nextSibling){o.parentNode.insertBefore(p,o.nextSibling);n=o.nextSibling}else{this.element.appendChild(p);n=this.lastChild()}if(k){this.cache.focusedElement=n;this.cursor.set(this,0,n)}return p}return null},invokeElement:function(m,l,o){var n=this.settings,k=l.remove||[];l=l||{};switch(n.mode){case d.inlineMode:case d.partialMode:return this;default:}if(k.length>0){if(!a.arrayContains(n,\"class\")){k.push(\"class\")}}(new d.Element(this,m,l)).invoke(this.settings.beforeInvokeElement);if(o===true){a.triggerEvent(this.element,\"change\")}return this},value:function(k){if(typeof k!==\"undefined\"){this.element.innerHTML=k;this.clean();this.placeholders();this.makeUndoable()}else{return this.element.innerHTML}return this},focus:function(){var k=this.element;k.focus();return this},select:function(){a.selectNode(d.activeElement=this.element);return this},isActive:function(){return(d.activeElement===this.element)},setupContents:function(){var n=this.element,l=n.children,o=n.childNodes,k,m=this.settings;if(!m.tags.paragraph||l.length>0||m.mode===d.inlineMode||m.mode===d.inlineRichMode){return d.Utilities}if(o.length>0){k=h.createElement(m.tags.paragraph);if(n.innerHTML.match(\"^[&]nbsp[;]\")){n.innerHTML=n.innerHTML.substring(6,n.innerHTML.length-1)}k.innerHTML=n.innerHTML;n.innerHTML=\"\";n.appendChild(k)}else{k=h.createElement(m.tags.paragraph);k.innerHTML=\"&nbsp;\";n.appendChild(k);this.cursor.set(this,0,n.firstChild)}return this},destroy:function(){var l=this.element,k=this.settings,m=this.placeholder||null;if(m!==null&&m.setup&&m.parentNode!==null){m.parentNode.removeChild(m);delete l.placeHolderActive}l.removeAttribute(\"contenteditable\");l.className=a.trim(l.className.replace(k.cssClasses.editor,\"\").replace(k.cssClasses.clear,\"\").replace(k.cssClasses.editor+\"-\"+k.mode,\"\"));this.action.destroy();if(this.settings.drag){this.drag.destroy()}},clear:function(){this.element.innerHTML=\"\";this.placeholders()},splitAtCaret:function(){if(!this.isActive()){return null}var k=(e.getSelection||h.selection),q=k(),r=q.focusOffset,p=q.focusNode,m=this.element,l=h.createRange(),o=h.createRange(),n;l.setStart(p,r);o.selectNodeContents(m);l.setEnd(o.endContainer,o.endOffset);n=l.extractContents();return n},deleteSelection:function(){if(!this.isActive()){return}var l=g.getSelection(),k;if(l.rangeCount>0){k=l.getRangeAt(0);k.deleteContents()}},lastChild:function(){return this.element.lastChild},bold:function(){switch(this.settings.mode){case d.partialMode:case d.inlineMode:return this}(new d.Element(this,\"bold\")).setClean(false).invoke(this.settings.beforeInvokeElement);return this},underline:function(){switch(this.settings.mode){case d.partialMode:case d.inlineMode:return this}(new d.Element(this,\"underline\")).setClean(false).invoke(this.settings.beforeInvokeElement);return this},italicize:function(){switch(this.settings.mode){case d.partialMode:case d.inlineMode:return this}(new d.Element(this,\"italic\")).setClean(false).invoke(this.settings.beforeInvokeElement);return this},quote:function(){return this},paste:function(s){var p=this.value(),l=p.length,r,n=this.settings,q=this.selection,m=this.element,t=this,o=function(u){u=u||\"\";if(u.length>0){m.focus();d.activeElement=m;q.restoreSelection(k);u=a.encodeHtml(u);r=u.length+l;if(n.maxLength>0&&r>n.maxLength){u=u.substring(0,n.maxLength-l)}if(n.mode!==d.inlineMode){u=u.replace(/\\n/g,\"<br>\")}(new d.Html(t,u)).setClean(false).insert(n.beforeInsertHtml,true);t.clean();t.placeholders()}};t.makeUndoable();if(s!==undefined){o(s)}else{if(n.pasteAsText){var k=q.saveSelection();a.pasteHook(this,o)}else{setTimeout(function(){t.clean();t.placeholders()},20)}}return true},undo:function(){var l=this.undoable,k=l.stack,m=k.canUndo();if(m){k.undo()}return this},redo:function(){var l=this.undoable,k=l.stack,m=k.canRedo();if(m){k.redo()}return this}};d.inlineMode=\"inline\";d.partialMode=\"partial\";d.richMode=\"rich\";d.inlineRichMode=\"inlineRich\";d.Messages={pastHere:\"Paste Here\"};d.defaultSettings={element:null,modifier:\"auto\",placeholder:\"\",autofocus:false,autoHR:true,mode:d.richMode,maxLength:-1,modifiers:{b:\"bold\",i:\"italicize\",u:\"underline\"},tags:{\"break\":\"br\",horizontalRule:\"hr\",paragraph:\"p\",outerLevel:[\"pre\",\"blockquote\",\"figure\"],innerLevel:[\"a\",\"b\",\"u\",\"i\",\"img\",\"strong\"]},cssClasses:{editor:\"Medium\",pasteHook:\"Medium-paste-hook\",placeholder:\"Medium-placeholder\",clear:\"Medium-clear\"},attributes:{remove:[\"style\",\"class\"]},pasteAsText:true,beforeInvokeElement:function(){},beforeInsertHtml:function(){},maxLengthReached:function(k){},beforeAddTag:function(l,k,m,n){},onBlur:function(){},onFocus:function(){},keyContext:null,drag:false};(function(l,k,n){function m(o){if(o.hasOwnProperty(\"target\")&&o.target.getAttribute(\"contenteditable\")===\"false\"){a.preventDefaultEvent(o);return false}return true}l.Action=function(o){this.medium=o;this.handledEvents={keydown:null,keyup:null,blur:null,focus:null,paste:null,click:null}};l.Action.prototype={setup:function(){this.handleFocus().handleBlur().handleKeyDown().handleKeyUp().handlePaste().handleClick()},destroy:function(){var o=this.medium.element;a.removeEvent(o,\"focus\",this.handledEvents.focus).removeEvent(o,\"blur\",this.handledEvents.blur).removeEvent(o,\"keydown\",this.handledEvents.keydown).removeEvent(o,\"keyup\",this.handledEvents.keyup).removeEvent(o,\"paste\",this.handledEvents.paste).removeEvent(o,\"click\",this.handledEvents.click)},handleFocus:function(){var o=this.medium,p=o.element;a.addEvent(p,\"focus\",this.handledEvents.focus=function(q){q=q||k.event;if(!m(q)){return false}l.activeElement=p;o.cache.originalVal=q.target.textContent;o.settings.onFocus(q);o.placeholders()});return this},handleBlur:function(){var o=this.medium,p=o.element;a.addEvent(p,\"blur\",this.handledEvents.blur=function(q){q=q||k.event;if(l.activeElement===p){l.activeElement=null}o.settings.onBlur(q);o.placeholders()});return this},handleKeyDown:function(){var s=this,p=this.medium,r=p.settings,o=p.cache,q=p.element;a.addEvent(q,\"keydown\",this.handledEvents.keydown=function(z){z=z||k.event;if(!m(z)){return false}var u=true;if(z.keyCode===229){return}a.isCommand(r,z,function(){o.cmd=true},function(){o.cmd=false});a.isShift(z,function(){o.shift=true},function(){o.shift=false});a.isModifier(r,z,function(C){if(o.cmd){if((r.mode===l.inlineMode)||(r.mode===l.partialMode)){a.preventDefaultEvent(z);return false}var B=typeof C;var A=null;if(B===\"function\"){A=C}else{A=p[C]}u=A.call(p,z);if(u===false||u===p){a.preventDefaultEvent(z);a.stopPropagation(z)}return true}return false});if(r.maxLength!==-1){var t=a.text(q).length,v=false,y=k.getSelection(),x=a.isSpecial(z),w=a.isNavigational(z);if(y){v=!y.isCollapsed}if(x||w){return true}if(t>=r.maxLength&&!v){r.maxLengthReached(q);a.preventDefaultEvent(z);return false}}switch(z.keyCode){case f.enter:if(s.enterKey(z)===false){a.preventDefaultEvent(z)}break;case f.escape:if(s.escKey(z)===false){a.preventDefaultEvent(z)}break;case f.backspace:case f[\"delete\"]:s.backspaceOrDeleteKey(z);break}return u});return this},handleKeyUp:function(){var s=this,p=this.medium,r=p.settings,o=p.cache,t=p.cursor,q=p.element;a.addEvent(q,\"keyup\",this.handledEvents.keyup=function(w){w=w||k.event;if(!m(w)){return false}a.isCommand(r,w,function(){o.cmd=false},function(){o.cmd=true});p.clean();p.placeholders();var v;if(r.keyContext!==null&&(v=r.keyContext[w.keyCode])){var u=t.parent();if(u){v.call(p,w,u)}}s.preserveElementFocus()});return this},handlePaste:function(){var w=this.medium,o=w.element,v,q,u,p,s,t,r;a.addEvent(o,\"paste\",this.handledEvents.paste=function(x){x=x||k.event;if(!m(x)){return false}q=0;a.preventDefaultEvent(x);v=\"\";s=x.clipboardData;if(s&&(p=s.getData)){r=s.types;u=r.length;for(q=0;q<u;q++){t=r[q];switch(t){case\"text/plain\":return w.paste(s.getData(\"text/plain\"))}}}w.paste()});return this},handleClick:function(){var o=this.medium,p=o.element,q=o.cursor;a.addEvent(p,\"click\",this.handledEvents.click=function(r){if(!m(r)){q.caretToAfter(r.target)}});return this},escKey:function(s){var p=this.medium,r=p.element,q=p.settings,o=p.cache;if(q.mode===l.inlineMode||q.mode===l.inlineRichMode){s.target.textContent=o.originalVal;if(q.element.blur){q.element.blur()}else{if(q.element.onblur){q.element.onblur()}}return false}},enterKey:function(v){var z=this.medium,q=z.element,s=z.settings,o=z.cache,y=z.cursor;if(s.mode===l.inlineMode||s.mode===l.inlineRichMode){if(s.element.blur){s.element.blur()}else{if(s.element.onblur){s.element.onblur()}}return false}if(o.shift){if(s.tags[\"break\"]){z.addTag(s.tags[\"break\"],true);return false}}else{var w=a.atCaret(z)||{},r=q.children,p=w===q.lastChild?q.lastChild:null,u,x,t;if(p&&p!==q.firstChild&&s.autoHR&&s.mode!==l.partialMode&&s.tags.horizontalRule){a.preventDefaultEvent(v);u=a.text(p)===\"\"&&p.nodeName.toLowerCase()===s.tags.paragraph;if(u&&r.length>=2){x=r[r.length-2];if(x.nodeName.toLowerCase()===s.tags.horizontalRule){u=false}}if(u){z.addTag(s.tags.horizontalRule,false,true,w);w=w.nextSibling}if((t=z.addTag(s.tags.paragraph,true,null,w))!==null){t.innerHTML=\"\";y.set(z,0,t)}}}return true},backspaceOrDeleteKey:function(s){var v=this.medium,u=v.cursor,r=v.settings,p=v.element;if(r.onBackspaceOrDelete!==undefined){var w=r.onBackspaceOrDelete.call(v,s,p);if(w){return}}if(p.lastChild===null){return}var o=p.lastChild,q=o.previousSibling,t=g.getSelection().anchorNode;if(o&&r.tags.horizontalRule&&o.nodeName.toLocaleLowerCase()===r.tags.horizontalRule){p.removeChild(o)}else{if(o&&q&&a.text(o).length<1&&q.nodeName.toLowerCase()===r.tags.horizontalRule&&o.nodeName.toLowerCase()===r.tags.paragraph){p.removeChild(o);p.removeChild(q)}else{if(p.childNodes.length===1&&o&&!a.text(o).length){a.preventDefaultEvent(s);v.setupContents()}else{if(t&&t===p){v.deleteSelection();v.setupContents();u.set(v,0,p.firstChild)}}}}},preserveElementFocus:function(){var w=k.getSelection?k.getSelection().anchorNode:document.activeElement;if(w){var x=this.medium,o=x.cache,p=x.element,y=x.settings,v=w.parentNode,q=p.children,u=v!==o.focusedElement,r=0,t;if(v===y.element){v=w}for(t=0;t<q.length;t++){if(v===q[t]){r=t;break}}if(u){o.focusedElement=v;o.focusedElementIndex=r}}}}})(d,e,h);(function(k){k.Cache=function(){this.initialized=false;this.cmd=false;this.focusedElement=null;this.originalVal=null}})(d);(function(k){k.Cursor=function(l){this.medium=l};k.Cursor.prototype={set:function(s,o){var l;if(h.createRange){var n=e.getSelection(),r=this.medium.lastChild(),q=a.text(r).length-1,m=o?o:r,p=((typeof s!==\"undefined\")&&(s!==null)?s:q);l=h.createRange();l.setStart(m,p);l.collapse(true);n.removeAllRanges();n.addRange(l)}else{l=h.body.createTextRange();l.moveToElementText(o);l.collapse(false);l.select()}},moveCursorToEnd:function(n){var m=g.getSelection(),l=g.createRange();l.setStartAfter(n);l.setEnd(n,n.length||n.childNodes.length);m.removeAllRanges();m.addRange(l)},moveCursorToAfter:function(m){var n=g.getSelection();if(n.rangeCount){var l=n.getRangeAt(0);l.collapse(false);l.collapseAfter(m);n.setSingleRange(l)}},parent:function(){var m=null,l;if(e.getSelection){l=e.getSelection().getRangeAt(0);m=l.commonAncestorContainer;m=(m.nodeType===1?m:m.parentNode)}else{if(h.selection){m=h.selection.createRange().parentElement()}}if(m.tagName==\"SPAN\"){m=m.parentNode}return m},caretToBeginning:function(l){this.set(0,l)},caretToEnd:function(l){this.moveCursorToEnd(l)},caretToAfter:function(l){this.moveCursorToAfter(l)}}})(d);(function(k){k.Drag=function(m){this.medium=m;var o=this,l=this.iconSrc.replace(/[{][{]([a-zA-Z]+)[}][}]/g,function(q,p){if(o.hasOwnProperty(p)){return o[p]}return q}),n=this.icon=h.createElement(\"img\");n.className=this.buttonClass;n.setAttribute(\"contenteditable\",\"false\");n.setAttribute(\"src\",l);this.hide();this.element=null;this.protectedElement=null;this.handledEvents={dragstart:null,dragend:null,mouseover:null,mouseout:null,mousemove:null}};k.Drag.prototype={elementClass:\"Medium-focused\",buttonClass:\"Medium-drag\",iconSrc:'data:image/svg+xml;utf8,<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"21.424px\" height=\"21.424px\" viewBox=\"0 0 21.424 21.424\" style=\"enable-background:new 0 0 21.424 21.424;\" xml:space=\"preserve\">\t<g>\t\t<g>\t\t\t<path style=\"fill:{{iconColor}};\" d=\"M13.616,17.709L13.616,17.709h0.781l-3.686,3.715l-3.685-3.715h0.781l0,0H13.616z M13.616,17.709 M14.007,17.709 M12.555,19.566 M8.87,19.566 M7.418,17.709 M7.809,17.709 M10.712,17.709\"/>\t\t\t<path style=\"fill:{{iconColor}};\" d=\"M13.616,3.715L13.616,3.715h0.781L10.712,0L7.027,3.715h0.781l0,0H13.616z M13.616,3.715 M14.007,3.715 M12.555,1.858 M8.87,1.858 M7.418,3.715 M7.809,3.715 M10.712,3.715\"/>\t\t\t<path style=\"fill:{{iconColor}};\" d=\"M3.716,13.616L3.716,13.616v0.781L0,10.712l3.716-3.685v0.781l0,0V13.616z M3.716,13.616 M3.716,14.007 M1.858,12.555 M1.858,8.87 M3.716,7.417 M3.716,7.808 M3.716,10.712\"/>\t\t\t<path style=\"fill:{{iconColor}};\" d=\"M17.709,13.616L17.709,13.616v0.781l3.715-3.685l-3.715-3.685v0.781l0,0V13.616z M17.709,13.616 M17.709,14.007 M19.566,12.555 M19.566,8.87 M17.709,7.417 M17.709,7.808 M17.709,10.712\"/>\t\t</g>\t\t<path style=\"fill-rule:evenodd;clip-rule:evenodd;fill:{{iconColor}};\" d=\"M10.712,6.608c2.267,0,4.104,1.838,4.104,4.104 c0,2.266-1.837,4.104-4.104,4.104c-2.266,0-4.104-1.837-4.104-4.104C6.608,8.446,8.446,6.608,10.712,6.608L10.712,6.608z M10.712,7.515c-1.765,0-3.196,1.432-3.196,3.197s1.432,3.197,3.196,3.197c1.766,0,3.197-1.432,3.197-3.197 S12.478,7.515,10.712,7.515z\"/>\t</g></svg>',iconColor:\"#231F20\",setup:function(){this.handleDragstart().handleDragend().handleMouseover().handleMouseout().handleMousemove();return this},destroy:function(){a.removeEvent(this.icon,\"dragstart\",this.handledEvents.dragstart).removeEvent(this.icon,\"dragend\",this.handledEvents.dragend).removeEvent(this.icon,\"mouseover\",this.handledEvents.mouseover).removeEvent(this.icon,\"mouseout\",this.handledEvents.mouseout).removeEvent(this.medium.element,\"mousemove\",this.handledEvents.mousemove);return this},hide:function(){a.hide(this.icon);return this},handleDragstart:function(){var l=this;a.addEvent(this.icon,\"dragstart\",this.handledEvents.dragstart=function(m){if(l.protectedElement!==null){return}m=m||e.event;l.protectedElement=a.detachNode(l.element);l.icon.style.opacity=0});return this},handleDragend:function(){var l=this;a.addEvent(this.icon,\"dragend\",this.handledEvents.dragend=h.body.ondragend=function(m){if(l.protectedElement===null){return}setTimeout(function(){l.cleanCanvas();l.protectedElement=null},1)});return this},handleMouseover:function(){var l=this;a.addEvent(this.icon,\"mouseover\",this.handledEvents.mouseover=function(m){if(l.protectedElement!==null){return}a.stopPropagation(m).addClass(l.element,l.elementClass)});return this},handleMouseout:function(){var l=this;a.addEvent(this.icon,\"mouseout\",this.handledEvents.mouseout=function(m){if(l.protectedElement!==null){return}a.stopPropagation(m).removeClass(l.element,l.elementClass)});return this},handleMousemove:function(){var l=this;a.addEvent(this.medium.element,\"mousemove\",this.handledEvents.mousemove=function(n){n=n||e.event;var m=n.target||{};if(m.getAttribute(\"contenteditable\")===\"false\"){l.show(m)}});return this},show:function(m){if(m===this.icon&&this.protectedElement===null){return}this.element=m;var l=this.icon.style,o=m.offsetLeft,n=m.offsetTop;m.dragIcon=this.icon;m.parentNode.appendChild(this.icon);l.opacity=1;l.left=o+\"px\";l.top=n+\"px\";a.show(this.icon);return this},cleanCanvas:function(){var n,l=false,m=h.getElementsByClassName(this.buttonClass);this.icon.style.opacity=1;while(m.length>0){if(a.isVisible(n=m[0])){if(!l){n.parentNode.insertBefore(this.element,n);l=true}a.detachNode(n)}}a.detachNode(this.icon);return this}}})(d);(function(k){k.Element=function(m,n,l){this.medium=m;this.element=m.element;switch(n.toLowerCase()){case\"bold\":this.tagName=\"b\";break;case\"italic\":this.tagName=\"i\";break;case\"underline\":this.tagName=\"u\";break;default:this.tagName=n}this.attributes=l||{};this.clean=true};k.Element.prototype={invoke:function(p){if(k.activeElement===this.element){if(p){p.apply(this)}var l=this.attributes,o=this.tagName.toLowerCase(),n,m;if(l.className!==undefined){m=(l.className.split[\" \"]||[l.className]).shift();delete l.className}else{m=\"medium-\"+o}n=g.createClassApplier(m,{elementTagName:o,elementAttributes:this.attributes});this.medium.makeUndoable();n.toggleSelection(e);if(this.clean){this.medium.clean();this.medium.placeholders()}}},setClean:function(l){this.clean=l;return this}}})(d);(function(k){k.Html=function(l,m){this.html=m;this.medium=l;this.clean=true;this.injector=new k.Injector()};k.Html.prototype={insert:function(n,m){if(k.activeElement===this.medium.element){if(n){n.apply(this)}var l=this.injector.inject(this.html,m);if(this.clean){this.medium.clean();this.medium.placeholders()}this.medium.makeUndoable();return l}else{return null}},setClean:function(l){this.clean=l;return this}}})(d);(function(k){k.Injector=function(){};k.Injector.prototype={inject:function(n){var m=[],p,l=false;if(typeof n===\"string\"){var s=h.createElement(\"div\");s.innerHTML=n;p=s.childNodes;l=true}else{p=n}this.insertHTML('<span id=\"Medium-wedge\"></span>');var r=h.getElementById(\"Medium-wedge\"),q=r.parentNode,o=0;r.removeAttribute(\"id\");if(l){while(o<p.length){m.push(p[o]);o++}while(p.length>0){q.insertBefore(p[0],r)}}else{m.push(p);q.insertBefore(p,r)}q.removeChild(r);r=null;return m},insertHTML:function(r,t){var n,s;if(e.getSelection){n=e.getSelection();if(n.getRangeAt&&n.rangeCount){s=n.getRangeAt(0);s.deleteContents();var o=h.createElement(\"div\");o.innerHTML=r;var u=h.createDocumentFragment(),p,m;while((p=o.firstChild)){m=u.appendChild(p)}var l=u.firstChild;s.insertNode(u);if(m){s=s.cloneRange();s.setStartAfter(m);if(t){s.setStartBefore(l)}else{s.collapse(true)}n.removeAllRanges();n.addRange(s)}}}else{if((n=h.selection)&&n.type!=\"Control\"){var q=n.createRange();q.collapse(true);n.createRange().pasteHTML(r);if(t){s=n.createRange();s.setEndPoint(\"StartToStart\",q);s.select()}}}}}})(d);(function(k){k.Selection=function(){};k.Selection.prototype={saveSelection:function(){if(e.getSelection){var l=e.getSelection();if(l.rangeCount>0){return l.getRangeAt(0)}}else{if(h.selection&&h.selection.createRange){return h.selection.createRange()}}return null},restoreSelection:function(l){if(l){if(e.getSelection){var m=e.getSelection();m.removeAllRanges();m.addRange(l)}else{if(h.selection&&l.select){l.select()}}}}}})(d);(function(k){k.Toolbar=function(l,n){this.medium=l;var m=h.createElement(\"div\");m.innerHTML=this.html;this.buttons=n;this.element=m.children[0];h.body.appendChild(this.element);this.active=false;this.busy=true;this.handledEvents={scroll:null,mouseup:null,keyup:null}};k.Toolbar.prototype={fixedClass:\"Medium-toolbar-fixed\",showClass:\"Medium-toolbar-show\",hideClass:\"Medium-toolbar-hide\",html:'<div class=\"Medium-toolbar\">\t\t\t\t<div class=\"Medium-tail-outer\">\t\t\t\t\t<div class=\"Medium-tail-inner\"></div>\t\t\t\t</div>\t\t\t\t<div id=\"Medium-buttons\"></div>\t\t\t\t<table id=\"Medium-options\">\t\t\t\t\t<tbody>\t\t\t\t\t\t<tr>\t\t\t\t\t\t</tr>\t\t\t\t\t</tbody>\t\t\t\t</table>\t\t\t</div>',setup:function(){this.handleScroll().handleMouseup().handleKeyup()},destroy:function(){a.removeEvent(e,\"scroll\",this.handledEvents.scroll).removeEvent(h,\"mouseup\",this.handledEvents.mouseup).removeEvent(h,\"keyup\",this.handledEvents.keyup)},handleScroll:function(){var l=this;a.addEvent(e,\"scroll\",this.handledEvents.scroll=function(){if(l.active){l.goToSelection()}});return this},handleMouseup:function(){var l=this;a.addEvent(h,\"mouseup\",this.handledEvents.mouseup=function(){if(k.activeElement===l.medium.element&&!l.busy){l.goToSelection()}});return this},handleKeyup:function(){var l=this;a.addEvent(h,\"keyup\",this.handledEvents.keyup=function(){if(k.activeElement===l.medium.element&&!l.busy){l.goToSelection()}});return this},goToSelection:function(){var n=this.getHighlighted(),o=n.boundary.top-5,m=this.element,l=m.style;if(e.scrollTop>0){a.addClass(m,this.fixedClass)}else{a.removeClass(m,this.fixedClass)}if(n!==null){if(n.range.startOffset===n.range.endOffset&&!n.text){a.removeClass(m,this.showClass).addClass(m,this.hideClass);this.active=false}else{a.removeClass(m,this.hideClass).removeClass(m,this.showClass);l.opacity=0.01;a.addClass(m,this.showClass);l.opacity=1;l.top=(o-65)+\"px\";l.left=((n.boundary.left+(n.boundary.width/2))-(m.clientWidth/2))+\"px\";this.active=true}}},getHighlighted:function(){var m=e.getSelection(),l=(m.anchorNode?m.getRangeAt(0):false);if(!l){return null}return{selection:m,range:l,text:a.trim(l.toString()),boundary:l.getBoundingClientRect()}}}})(d);(function(k){k.Undoable=function(o){var r=this,p=o.settings.element,s,n,l=new Undo.Stack(),q=Undo.Command.extend({constructor:function(t,u){this.oldValue=t;this.newValue=u},execute:function(){},undo:function(){p.innerHTML=this.oldValue;o.canUndo=l.canUndo();o.canRedo=l.canRedo();o.dirty=l.dirty()},redo:function(){p.innerHTML=this.newValue;o.canUndo=l.canUndo();o.canRedo=l.canRedo();o.dirty=l.dirty()}}),m=function(u){var t=p.innerHTML;if(u){n=p.innerHTML;l.execute(new q(n,n))}else{if(t!=n){if(!r.movingThroughStack){l.execute(new q(n,t));n=t;o.dirty=l.dirty()}a.triggerEvent(o.settings.element,\"change\")}}};this.medium=o;this.timer=s;this.stack=l;this.makeUndoable=m;this.EditCommand=q;this.movingThroughStack=false;a.addEvent(p,\"keyup\",function(t){if(t.ctrlKey||t.keyCode===f.z){a.preventDefaultEvent(t);return}clearTimeout(s);s=setTimeout(function(){m()},250)}).addEvent(p,\"keydown\",function(t){if(!t.ctrlKey||t.keyCode!==f.z){r.movingThroughStack=false;return}a.preventDefaultEvent(t);r.movingThroughStack=true;if(t.shiftKey){l.canRedo()&&l.redo()}else{l.canUndo()&&l.undo()}})}})(d);d.Utilities={isCommand:function(l,n,m,k){if((l.modifier===\"ctrl\"&&n.ctrlKey)||(l.modifier===\"cmd\"&&n.metaKey)||(l.modifier===\"auto\"&&(n.ctrlKey||n.metaKey))){return m.call()}else{return k.call()}},isShift:function(m,l,k){if(m.shiftKey){return l.call()}else{return k.call()}},isModifier:function(l,n,k){var m=l.modifiers[n.keyCode];if(m){return k.call(null,m)}return false},special:(function(){var k={};k[f.backspace]=true;k[f.shift]=true;k[f.ctrl]=true;k[f.alt]=true;k[f[\"delete\"]]=true;k[f.cmd]=true;return k})(),isSpecial:function(k){return typeof d.Utilities.special[k.keyCode]!==\"undefined\"},navigational:(function(){var k={};k[f.upArrow]=true;k[f.downArrow]=true;k[f.leftArrow]=true;k[f.rightArrow]=true;return k})(),isNavigational:function(k){return typeof d.Utilities.navigational[k.keyCode]!==\"undefined\"},addEvents:function(o,p,q){var n=0,m,r=p.split(\" \"),k=r.length,l=d.Utilities;for(;n<k;n++){m=r[n];if(m.length>0){l.addEvent(o,m,q)}}return d.Utilities},addEvent:function i(l,k,m){if(l.addEventListener){l.addEventListener(k,m,false)}else{if(l.attachEvent){l.attachEvent(\"on\"+k,m)}else{l[\"on\"+k]=m}}return d.Utilities},removeEvent:function j(l,k,m){if(l.removeEventListener){l.removeEventListener(k,m,false)}else{if(l.detachEvent){l.detachEvent(\"on\"+k,m)}else{l[\"on\"+k]=null}}return d.Utilities},preventDefaultEvent:function(k){if(k.preventDefault){k.preventDefault()}else{k.returnValue=false}return d.Utilities},stopPropagation:function(k){k=k||e.event;k.cancelBubble=true;if(k.stopPropagation!==undefined){k.stopPropagation()}return d.Utilities},isEventSupported:function(m,k){k=\"on\"+k;var n=h.createElement(m.tagName),l=(k in n);if(!l){n.setAttribute(k,\"return;\");l=typeof n[k]==\"function\"}n=null;return l},triggerEvent:function(l,k){var m;if(h.createEvent){m=h.createEvent(\"HTMLEvents\");m.initEvent(k,true,true);m.eventName=k;l.dispatchEvent(m)}else{m=h.createEventObject();l.fireEvent(\"on\"+k,m)}return d.Utilities},deepExtend:function(k,n){var m,l;for(m in n){if(n.hasOwnProperty(m)){l=n[m];if(l!==undefined&&l!==null&&l.constructor!==undefined&&l.constructor===Object){k[m]=k[m]||{};d.Utilities.deepExtend(k[m],l)}else{k[m]=l}}}return k},pasteHook:function(w,r){w.makeUndoable();var o=h.createElement(\"div\"),l=w.element,v,m,p,x=w.settings,t,q=h.body,u=q.parentNode,k=u.scrollTop,n=u.scrollLeft;o.className=x.cssClasses.pasteHook;o.setAttribute(\"contenteditable\",true);q.appendChild(o);a.selectNode(o);u.scrollTop=k;u.scrollLeft=n;setTimeout(function(){t=a.text(o);l.focus();if(x.maxLength>0){v=a.text(l);m=v.length;p=m+t.length;if(p>m){t=t.substring(0,x.maxLength-m)}}a.detachNode(o);u.scrollTop=k;u.scrollLeft=n;r(t)},0);return d.Utilities},traverseAll:function(n,k,q){var m=n.childNodes,p=m.length,l=0,o;q=q||1;k=k||{};if(p>0){for(;l<p;l++){o=m[l];switch(o.nodeType){case 1:d.Utilities.traverseAll(o,k,q+1);if(k.element!==undefined){k.element(o,l,q,n)}break;case 3:if(k.fragment!==undefined){k.fragment(o,l,q,n)}}p=m.length;if(o===n.lastChild){l=p}}}return d.Utilities},trim:function(k){return k.replace(/^[\\s]+|\\s+$/g,\"\")},arrayContains:function(m,k){var l=m.length;while(l--){if(m[l]===k){return true}}return false},addClass:function(l,k){if(l.classList){l.classList.add(k)}else{l.className+=\" \"+k}return d.Utilities},removeClass:function(l,k){if(l.classList){l.classList.remove(k)}else{l.className=l.className.replace(new RegExp(\"(^|\\b)\"+k.split(\" \").join(\"|\")+\"(\\b|$)\",\"gi\"),\" \")}return d.Utilities},hasClass:function(l,k){if(l.classList){return l.classList.contains(k)}else{return new RegExp(\"(^| )\"+k+\"( |$)\",\"gi\").test(l.className)}},isHidden:function(k){return k.offsetWidth===0||k.offsetHeight===0},isVisible:function(k){return k.offsetWidth!==0||k.offsetHeight!==0},encodeHtml:function(k){return h.createElement(\"a\").appendChild(h.createTextNode(k)).parentNode.innerHTML},text:function(k,l){if(l!==undefined){if(k===null){return this}if(k.textContent!==undefined){k.textContent=l}else{k.innerText=l}return this}else{if(k===null){return this}else{if(k.innerText!==undefined){return a.trim(k.innerText)}else{if(k.textContent!==undefined){return a.trim(k.textContent)}else{if(k.data!==undefined){return a.trim(k.data)}}}}}return\"\"},changeTag:function(o,m){var l=h.createElement(m),n,k;n=o.firstChild;while(n){k=n.nextSibling;l.appendChild(n);n=k}o.parentNode.insertBefore(l,o);o.parentNode.removeChild(o);return l},detachNode:function(k){if(k.parentNode!==null){k.parentNode.removeChild(k)}return this},selectNode:function(m){var k,l;m.focus();if(h.body.createTextRange){k=h.body.createTextRange();k.moveToElementText(m);k.select()}else{if(e.getSelection){l=e.getSelection();k=h.createRange();k.selectNodeContents(m);l.removeAllRanges();l.addRange(k)}}return this},baseAtCaret:function(m){if(!m.isActive()){return null}var n=e.getSelection?e.getSelection():document.selection;if(n.rangeCount){var l=n.getRangeAt(0),k=l.endContainer;switch(k.nodeType){case 3:if(k.data&&k.data.length!=l.endOffset){return false}break}return k}return null},atCaret:function(l){var k=this.baseAtCaret(l)||{},m=l.element;if(k===false){return null}while(k&&k.parentNode!==m){k=k.parentNode}if(k&&k.nodeType==1){return k}return null},hide:function(k){k.style.display=\"none\";return d.Utilities},show:function(k){k.style.display=\"\";return d.Utilities},hideAnim:function(k){k.style.opacity=1;return d.Utilities},showAnim:function(k){k.style.opacity=0.01;k.style.display=\"\";return d.Utilities},setWindow:function(k){e=k;return d.Utilities},setDocument:function(k){h=k;return d.Utilities}};g.rangePrototype.insertNodeAtEnd=function(l){var k=this.cloneRange();k.collapse(false);k.insertNode(l);k.detach();this.setEndAfter(l)};return d}()),a=b.Utilities;if(typeof define===\"function\"&&define.amd){define(function(){return b})}else{if(typeof module!==\"undefined\"&&module.exports){module.exports=b}else{if(typeof this!==\"undefined\"){this.Medium=b}}}}).call(this,window,document);"]}